<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】DISCLAIMER]]></title>
    <url>%2F9999%2F12%2F31%2FDISCLAIMER%2F</url>
    <content type="text"><![CDATA[本帖为置顶内容，最新内容请向下翻! 本博客仅供本蒟蒻复习用，建议初学者不要看本蒟蒻的博客。 而且本蒟蒻懒癌晚期，博客写的一点都不好。 有诗赞曰： 模拟只会猜题意 贪心只能过样例 数学上来先打表 D P 一般看规律 组合数学看运气 计算几何瞎暴力 图论一顿套模板 数论只会G C D 本站地址: oi.tiger0132.tk 欢迎互链。]]></content>
      <tags>
        <tag>DISCLAIMER</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【底层】【Internal】STL的指针失效]]></title>
    <url>%2F2018%2F02%2F24%2F%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91%E3%80%90Internal%E3%80%91STL%E7%9A%84%E6%8C%87%E9%92%88%E5%A4%B1%E6%95%88%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 U2FsdGVkX19lot70zhVp7cMAAguZXOPRNvpoxB129LkctRVZ9B/B/lxzbYSKsKG9tHnryhcFTAld4ZH/xwegbAXgWuY5qEoSEnh1ci04Jcc=]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【并查集】BZOJ1214 - 团伙]]></title>
    <url>%2F2018%2F02%2F22%2F%E3%80%90%E5%B9%B6%E6%9F%A5%E9%9B%86%E3%80%91BZOJ1214-%E5%9B%A2%E4%BC%99%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1214 - 团伙 有nnn个人，有mmm对朋友或敌人的关系。并且满足以下性质： 朋友的朋友也是朋友。 敌人的敌人也是朋友。 所有的朋友组成一个团伙。 现在问你根据这些信息，最多可能有几个团伙。 解法 首先题面中的最多省去，那么问题就转化为求团伙的数量。 求连通块数量可以很容易想到并查集。 朋友关系很好处理，只需要两两merge即可。 敌人咋处理？ 可以考虑把一个人AAA拆成两个点AAA和A′A&#x27;A​′​​。其中A′A&#x27;A​′​​代表A的所有敌人的集合。 那么根据敌人的敌人是朋友，可以得出，如果AAA和BBB是敌人，那么我们要merge以下两对： merge(A,B′)merge(A,B&#x27;)merge(A,B​′​​)和merge(A′,B)merge(A&#x27;,B)merge(A​′​​,B)。 于是只要开到两倍空间就好了。 统计连通块数只需统计111~nnn的连通块个数即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int par[10003];int src[10003];int n, m, a, b;char s[2];int ans;int find(int x) &#123; return par[x] == x ? x : par[x] = find(par[x]);&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 2 * n; i++) &#123; par[i] = i; &#125; while (m--) &#123; scanf("%1s%d%d", s, &amp;a, &amp;b); if (*s == 'F') &#123; merge(a, b); &#125; else &#123; merge(n + a, b); merge(a, n + b); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; src[find(i)] = 1; &#125; for (int i = 1; i &lt;= 2 * n; i++) &#123; ans += src[i]; &#125; printf("%d", ans);&#125; 拓展 求连通块个数当然用并查集啦！ 如果关系种类繁多，错综复杂，可以考虑把一个点&quot;拆&quot;成多个点。]]></content>
      <categories>
        <category>并查集</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【底层】【Internal】坑爹的编译器]]></title>
    <url>%2F2018%2F02%2F18%2F%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91%E3%80%90Internal%E3%80%91%E5%9D%91%E7%88%B9%E7%9A%84%E7%BC%96%E8%AF%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 U2FsdGVkX1+VkzYhPyYoy5FcjAkraSpF0/nKtVtGN9Y=]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Codeforces】Codeforces Round #464 (Div. 2) (+1)]]></title>
    <url>%2F2018%2F02%2F17%2F%E3%80%90Codeforces%E3%80%91Codeforces%20Round%20464%20(Div.%202)%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #464 (Div. 2) 今天的状态差到一种境界&gt;_&lt;。然后估计这几次比赛会炼成High Frequency Rating。 本来可以做出C、D的，顿时感觉被出题人坑了。 原来坑题不止中国出，俄罗斯也出(这次出题人是俄罗斯的)。 A 比赛时竟然写了个dfs…… 然后造就了 # When Who Problem Lang Verdict Time Memory 2018-02-17 13:27:26 A - Love Triangle GNU C++ Time limit exceeded on pretest 4 1000 ms 2200 KB 2018-02-17 13:23:57 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2200 KB 2018-02-17 13:22:58 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2200 KB 2018-02-17 13:19:46 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2000 KB 2018-02-17 13:15:25 A - Love Triangle GNU C++ Memory limit exceeded on pretest 6 140 ms 262100 KB 的奇观。 直到我发现只要判断a[a[a[i]]] == i是否成立就可以通过。 然后我终于…… # When Who Problem Lang Verdict Time Memory 2018-02-17 14:21:19 A - Love Triangle GNU C++ Pretests Passed 30 ms 2000 KB 然而那时我已经早就AC了B题…… 最后A我只拿了150150150分。然并卵 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[5003];int n;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[a[a[i]]] == i) &#123; puts("YES"); return 0; &#125; &#125; puts("NO");&#125; 教训 不要想多！不要想多！！不要想多！！！ 这堆数据发现了你的想多。 我是这堆数据中的一个超级水数据，我先发现你的想多是你Rating的幸运。警告你：不要想多！不要想多！！不要想多！！！ 你的的方向上有千万个参赛者，只要不想多，这堆数据就无法定位想多者。 如果想多，想多者将被定位，你的Rank将会遭到打击，你的Rating将会被降低！ 不要想多！不要想多！！不要想多！！！ B 因为我没考虑到无解时全部输出000的情况，所以我又WA了一发。还有一发是我没判断仓鼠数量。 然后我一直没调到错误。 直到我发现我在if中的判断少写了个=。 代码 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;long long n, x, ax, bx, cx;int k;int main() &#123; scanf("%I64d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123; scanf("%I64d", &amp;x); if (n - n % x &gt;= cx) &#123; ax = i; bx = n / x; cx = n - n % x; &#125; &#125; printf("%I64d %I64d", ax, bx);&#125; 教训 小心无解情况。如果允许输出多组解中的任意一个，请不要使用&lt;或者&gt;，用&lt;=和&gt;=替代它们。如果不允许，则将当前答案设置成无解。 C 令f−s=kf-s=kf−s=k。 最开始我写了个前缀和，然后在最后追加kkk个数，把每个长度为kkk的子段算出来然后取个max。 无数次Wrong answer on test 20之后还是没有发现错在哪里。 然后我比赛时就没过这题…… 比赛结束后，我改成了另外一种写法，又无数次Wrong answer on test 9后也没有发现问题。 最后我写了个尺取法或two pointers，然后还是Wrong answer on test 9。 在我砸键盘前的那一刻，我提交了一份骗数据的代码。于是…… Output 12320280: 5007229129971799717: 500722912 Answer 120280 卧槽(上这么难你是人吗)答案一样为什么是202802028020280？百思不得姐。 直到我看见了这句话： If there are many answers, output the smallest among them. mmp。 更错 上面这333个算法，虽然是正着枚举，但是时间是反的。 于是就Wrong answer on test 9了。 估计是LJ出题人不想写太长的SPJ，然后就在Output最后写了这句话。 前缀和的最后 我的前缀和还是莫名其妙的Wrong answer on test 20了，估计算法还是有问题。 代码(双指针) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#ifdef LOCAL#define lld "%lld"#else#define lld "%I64d"#endifusing namespace std;long long arr[200005];long long ax, ai, cur;int n, s, f, t;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%lld", arr+i); &#125; scanf("%d%d", &amp;s, &amp;f); s--; f -= 2; for (int i = s; i &lt;= f; i++) &#123; cur += arr[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (cur &gt;= ax) &#123; ai = t + 1; ax = cur; &#125; f = (f + 1) % n; cur += arr[f] - arr[s]; s = (s + 1) % n; t = (t + n - 1) % n; &#125; printf(lld, ai);&#125; 教训 防被坑最好的方法是多读题。 D 第一感图论，然后写了个枚举。如果a[i] == b[i]那么gph[ax][bx] = 1，然后把所有连边输出。 然后挂在了这个数据上： 1233abcbca 接下来我写了个初始化为000的并查集，然后因为有000点，与初始值矛盾，于是第二个样例挂了。 最后我写了个把所有字母替换成一个字符串中存在的字符的代码，于是Wrong answer on pretest 4。类似这样： 1232abcd 比赛完我才发现，(卧槽上这么难你是人吗)我把并查集的初始值设矛盾了，于是我把初始值设为−1-1−1，然后就Accepted了！ 代码 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char a[100005], b[100005];int par[31];int n, ans;int find(int x) &#123; return ~par[x] ? par[x] = find(par[x]) : x;&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y, ans++;&#125;int main() &#123; memset(par, -1, sizeof par); scanf("%d\n", &amp;n); gets(a + 1); gets(b + 1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i] != b[i]) &#123; int ax = a[i] - 'a'; int bx = b[i] - 'a'; merge(ax, bx); &#125; &#125; printf("%d\n", ans); for (int i = 0; i &lt; 26; i++) &#123; find(i); if (par[i] != -1) printf("%c %c\n", i + 'a', par[i] + 'a'); &#125;&#125; 教训 乱初始化的后果是很严重的。写并查集前先想想有没有0号点。 E 二分三分不会写不好写，于是来优化暴力。 令f(x,i)f(x,i)f(x,i)代表选择最大的数xxx和前iii个数时的max−meanmax-meanmax−mean。 显然添加数字之后并不会影响以前的答案。 于是可以O(n)O(n)O(n)Accepted这道题。 代码 123456789101112131415161718192021222324252627282930313233343536// mmp为什么只有C++14及以上可以通过编译?详见下一篇底层博客————坑爹的编译器。#include &lt;bits/stdc++.h&gt;#ifdef LOCAL#define lld "%lld"#else#define lld "%I64d"#endifusing namespace std;typedef long long ll;typedef long double ld;int q, l, n, op, ptr;ll arr[500005];ld ans;ld f(ll x, int i) &#123; return (x * i - arr[i]) / ld(i + 1);&#125;int main() &#123; scanf("%d", &amp;q); ll x; while (q--) &#123; scanf("%d", &amp;op); if (op &amp; 1) &#123; scanf(lld, &amp;x); while (ptr &lt; n &amp;&amp; f(x, ptr) &lt;= f(x, ptr + 1)) ptr++; ans = max(ans, f(x, ptr)); arr[n+1] = arr[n] + x; n++; &#125; else &#123; printf("%.10Lf\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【网络流】网络流]]></title>
    <url>%2F2018%2F02%2F17%2F%E3%80%90%E7%BD%91%E7%BB%9C%E6%B5%81%E3%80%91%E7%BD%91%E7%BB%9C%E6%B5%81%2F</url>
    <content type="text"><![CDATA[简介 网络流？好难啊。 没用的概念 网络：带权有向图，记作G=(V,E)G=(V,E)G=(V,E)。 容量：网络上的边权，边(u,v)(u,v)(u,v)的容量记作c(u,v)c(u,v)c(u,v)。 网络流：指为这个有向图分配流并且使得它每条边上的流量都不能超过这条边的容量。 流量：网络流上的边权，边(u,v)(u,v)(u,v)的流量记作f(u,v)f(u,v)f(u,v)。 可行流满足： 流量限制：0≤f(u,v)≤c(u,v),(u,v)∈E0\le f(u,v)\le c(u,v),(u,v)\in E0≤f(u,v)≤c(u,v),(u,v)∈E。 平衡条件：∑v′f(u,v′)−∑v′′f(v′′,u)={∣f∣u=Vs0u≠Vs,Vt−∣f∣u=Vt\sum_{v&#x27;}f(u,v&#x27;)-\sum_{v&#x27;&#x27;}f(v&#x27;&#x27;,u)=\left\{\begin{array}{lc}|f|&amp;u=V_s\\0&amp;u\ne V_s,V_t\\-|f|&amp;u=V_t\end{array}\right.∑​v​′​​​​f(u,v​′​​)−∑​v​′′​​​​f(v​′′​​,u)=​⎩​⎨​⎧​​​∣f∣​0​−∣f∣​​​u=V​s​​​u≠V​s​​,V​t​​​u=V​t​​​​ 其中∑v′f(u,v′)\sum_{v&#x27;}f(u,v&#x27;)∑​v​′​​​​f(u,v​′​​)是从顶点uuu流出的流量之和，∑v′′f(v′′,u)\sum_{v&#x27;&#x27;}f(v&#x27;&#x27;,u)∑​v​′′​​​​f(v​′′​​,u)是流入顶点uuu的流量之和，∣f∣|f|∣f∣是可行流的总流量，是源点的净流出量，也是汇点的净流入量。 链：前后两两有边项链的点的序列。(准确的说是弧而不是边，之后均使用弧代替边) 前向弧：和链的方向相同。前向弧集合记作P+P^+P​+​​。 后向弧：和链的方向相反。后向弧集合记作P−P^-P​−​​。 增广路：源点到汇点的一条链，满足前向弧非饱和弧，后向弧非零流弧。 即0≤f(u,v)&lt;c(u,v),0&lt;f(u,v)≤c(u,v)0\le f(u,v)&lt;c(u,v),0&lt;f(u,v)\le c(u,v)0≤f(u,v)&lt;c(u,v),0&lt;f(u,v)≤c(u,v)。 残留容量或剩余流量：还能通过的流量。弧的残留容量或剩余流量记作$$。 每条弧对应一个反向残余流量或反向剩余流量c′(v,u)=−f(u,v)c&#x27;(v,u)=-f(u,v)c​′​​(v,u)=−f(u,v)。 残量网络或残余网络或剩余网络：残留容量或剩余流量组成的网络。 ⚠️ 注意：接下来残留容量和剩余容量统一为残留容量，残量网络、残余网络和剩余网络统称残量网络。 无聊的概念终于结束了，进入正题 就一个概念mmp一堆名字恶心不恶心 最大流 Ford-Fulkerson和Edmonds-Karp略。 Dinic 步骤 初始化 BFS构造层次网络和残量网络。 如果汇点不在层次网络中算法结束。 在层次网络中DFS进行增广，然后回到步骤2。 优化 BFS只要搜到终点就直接返回true。 DFS如果一条边的流量流满了，就不需要再对这条边DFS了，直接返回答案。 DFS如果一个点增广不出流量，那么这次DFS就不要再搜这个点了，再层次图中标记为000。 代码 该代码用于Accepted洛谷P3376 - 【模板】网络最大流 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 16384, INF = 0x3f3f3f3f;struct Edge;struct Node &#123; vector&lt;Edge&gt; edges; int level;&#125; gph[N];struct Edge &#123; int from, to, capacity, flow; Edge *rev; Edge(int from_, int to_, int capacity_, int flow_ = 0) &#123; capacity = capacity_; from = from_; flow = flow_; to = to_; &#125;&#125;;bool levelGraph(int s, int t, int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; gph[i].level = 0; &#125; queue&lt;int&gt; bfs; bfs.push(s); gph[s].level = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = 0; i &lt; gph[pos].edges.size(); i++) &#123; const Edge&amp; e = gph[pos].edges[i]; if (e.flow &lt; e.capacity &amp;&amp; !gph[e.to].level) &#123; gph[e.to].level = gph[pos].level + 1; if (e.to == t) return true; // 优化一 else bfs.push(e.to); &#125; &#125; &#125; return false;&#125;int findPath(int s, int t, int flow) &#123; if (s == t) return flow; int ret = 0; for (int i = 0; i &lt; gph[s].edges.size(); i++) &#123; Edge &amp;e = gph[s].edges[i]; if (gph[s].level + 1 == gph[e.to].level &amp;&amp; e.flow &lt; e.capacity) &#123; int tmp = findPath(e.to, t, min(flow, e.capacity - e.flow)); flow -= tmp; e.flow += tmp; e.rev-&gt;flow -= tmp; ret += tmp; if (!flow) break; // 优化二 &#125; &#125; if (!ret) gph[s].level = -1; // 优化三 return ret;&#125;int dinic(int s, int t, int n) &#123; int ans = 0; while (levelGraph(s, t, n)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;void addEdge(int from, int to, int capacity) &#123; Edge *e1 = new Edge(from, to, capacity, 0); Edge *e2 = new Edge(to, from, capacity, capacity); e1-&gt;rev = e2; e2-&gt;rev = e1; gph[from].edges.push_back(*e1); gph[to].edges.push_back(*e2);&#125;int n, m, s, t;int a, b, c;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addEdge(a, b, c); &#125; printf("%d", dinic(s, t, n));&#125; 最小费用最大流 未完待续…]]></content>
      <categories>
        <category>网络流</category>
      </categories>
      <tags>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【莫队算法】BZOJ1878 - HH的项链]]></title>
    <url>%2F2018%2F02%2F16%2F%E3%80%90%E8%8E%AB%E9%98%9F%E7%AE%97%E6%B3%95%E3%80%91BZOJ1878-HH%E7%9A%84%E9%A1%B9%E9%93%BE%2F</url>
    <content type="text"><![CDATA[⚠️ 注意：【莫队算法】莫队算法已合并至【莫队算法】BZOJ1878 - HH的项链(这篇博客)。 题意 传送门：BZOJ1878 - HH的项链 莫队模板题。 给一个长度为nnn数列，要你查询mmm次[l,r][l,r][l,r]区间中不同的数字的个数。 n≤106,m≤105n\le 10^6,m\le 10^5n≤10​6​​,m≤10​5​​ 解法 虽然看起来这题可以卡掉莫队，但是我还是用莫队AC了。 然后直接套模板即可。 存储结构 1234567struct query &#123; int l, r, *ans; bool operator&lt;(const query&amp; x) const &#123; if (l / blockSize == x.l / blockSize) return r &lt; x.r; return l / blockSize &lt; x.l / blockSize; &#125;&#125; q[200005]; lll和rrr代表查询中的l,rl,rl,r，ansansans代表保存答案的位置的指针(这样排序之后输出的顺序就不会乱)。 blockSize是每个块的大小。 修改操作 1234int extend(int x, int offset) &#123; if (~offset) return 1 == ++cnt[x]; // +1 else return -!--cnt[x]; // -1&#125; xxx代表更新的数字，offset代表加还是减(1,−1)(1,-1)(1,−1)，返回值用来更新答案。 如果+1+1+1之后cnt[x]正好为111，那就是新增了一种数字，返回111。 如果−1-1−1之后cnt[x]正好为000，那就是减少了一种数字，返回−1-1−1。 莫队算法 12345678int l = 1, r = 0, lans = 0;for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) lans += extend(src[++r], 1); while (r &gt; q[i].r) lans += extend(src[r--], -1); while (l &gt; q[i].l) lans += extend(src[--l], 1); while (l &lt; q[i].l) lans += extend(src[l++], -1); *q[i].ans = lans;&#125; lans代表当前查询的答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, blockSize, src[50004], ans[200005], cnt[1000006];struct query &#123; int l, r, *ans; bool operator&lt;(const query&amp; x) const &#123; if (l / blockSize == x.l / blockSize) return r &lt; x.r; return l / blockSize &lt; x.l / blockSize; &#125;&#125; q[200005];int extend(int x, int offset) &#123; if (~offset) return 1 == ++cnt[x]; else return -!--cnt[x];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", src+i); &#125; blockSize = ceil(sqrt(n)); scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;q[i].l, &amp;q[i].r); q[i].ans = ans+i; &#125; sort(q + 1, q + m + 1); int l = 1, r = 0, lans = 0; for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) lans += extend(src[++r], 1); while (r &gt; q[i].r) lans += extend(src[r--], -1); while (l &gt; q[i].l) lans += extend(src[--l], 1); while (l &lt; q[i].l) lans += extend(src[l++], -1); *q[i].ans = lans; &#125; for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>莫队算法</category>
      </categories>
      <tags>
        <tag>莫队算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【分治】笔记 - day6上午]]></title>
    <url>%2F2018%2F02%2F12%2F%E3%80%90%E5%88%86%E6%B2%BB%E3%80%91%E7%AC%94%E8%AE%B0-day6%E4%B8%8A%E5%8D%88%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： 分治 归并排序 将两个已经有序的数组用O(n)O(n)O(n)合并成一个有序的数组。 时间复杂度O(nlogn)O(n\log n)O(nlogn) 树的深度O(logn)O(\log n)O(logn)层，归并整个一层O(n)O(n)O(n)，共O(nlogn)O(n\log n)O(nlogn)。 使用范围 规模小可以方便计算 可以划分成较小子问题 子问题全部解出后可以解决原问题 子问题独立 Master Theorem 设a≥1,b≥1a\ge 1,b\ge 1a≥1,b≥1，设f(n)f(n)f(n)为一函数，T(n)T(n)T(n)由递归式T(n)=aT(nb)+f(n)T(n)=aT(\frac nb)+f(n)T(n)=aT(​b​​n​​)+f(n)定义。 若f(n)&lt;nlogbaf(n)&lt;n^{\log_ba}f(n)&lt;n​log​b​​a​​，则T(n)=O(nlogba)T(n)=O(n^{\log_ba})T(n)=O(n​log​b​​a​​) 若f(n)=nlogbaf(n)=n^{log_ba}f(n)=n​log​b​​a​​，则T(n)=O(nlogbalog2n)T(n)=O(n^{log_ba}log_2n)T(n)=O(n​log​b​​a​​log​2​​n) 若f(n)&gt;nlogbaf(n)&gt;n^{log_ba}f(n)&gt;n​log​b​​a​​，且对于任意c&lt;1c&lt;1c&lt;1与所有足够大的nnn，都有af(nb)≤cf(n)af(\frac nb)\le cf(n)af(​b​​n​​)≤cf(n)，则T(n)=O(f(n))T(n)=O(f(n))T(n)=O(f(n))。 逆序对 n≤105n\le10^5n≤10​5​​ 一分为二。考虑左边自身、右边自身、跨两边。跨两边就two-pointers解决。 快速幂 分治大法好位运算大法好 即时战略(WC2018T2) 35pts 从一个点开始，枚举所有其它点，然后把它周围所有点探索出来，类似于bfs。O(n2)O(n^2)O(n​2​​)。 完全二叉树 Solution 1 O(n2)O(\frac n2)O(​2​​n​​)查出一个点在哪个子树。 然后查下面的O(n)O(n)O(n)个点，在标记中使用堆式编号。 然后就用主定理证出O(nlogn)O(n\log n)O(nlogn)了。 Solution 2 因为完全二叉树的深度是O(logn)O(\log n)O(logn)的，所以可以用O(nlogn)O(n\log n)O(nlogn)过掉。 Solution 3 在完全二叉树上BFS！ 百度地图的实时路况 分治严格不经过的点，solve(l,r)solve(l,r)solve(l,r)代表[l,r][l,r][l,r]都没有被考虑。 = = 区间的价值 枚举最小值。然后从左右两端找最大值。 BD String 超淼题。 可以证明，S(n)S(n)S(n)中B的数量是2n−12^{n-1}2​n−1​​。 然后计算solve(n)solve(n)solve(n)： n=0n=0n=0返回000。 n=1n=1n=1返回111。 mid=2⌊log2n⌋mid=2^{\lfloor\log_2n\rfloor}mid=2​⌊log​2​​n⌋​​。如果2mid−1=n2mid-1=n2mid−1=n，返回midmidmid。 否则返回f(2mid−1−n)+n+1−midf(2mid-1-n)+n+1-midf(2mid−1−n)+n+1−mid。 My solution 令f(x)f(x)f(x)为S(n)S(n)S(n)中[0,x)[0,x)[0,x)的B的数量。 那么答案就等于f(l)−f(r−1)f(l)-f(r-1)f(l)−f(r−1)。 然后考虑xxx的位置。如果在后半段就将2n−1+12^{n-1}+12​n−1​​+1加上后半段。 前半段就直接从n−1n-1n−1算。 欧几里得最近点对 先按xxx排序，然后把点分成两半。 然后初始化答案d=+∞d=+\inftyd=+∞。 然后在左右两边枚举点，对答案更新有用的点一定是在该点为圆心半径为ddd的点。这样的点最多只有不到666个。 Tricky Function g(i,j)g(i,j)g(i,j)就是算(i,j](i,j](i,j]的区间和。 令bbb为aaa的前缀和，那么g(i,j)=b[i]−b[j]g(i,j)=b[i]-b[j]g(i,j)=b[i]−b[j]。 xxx坐标为编号，yyy坐标为前缀和。 然后就差一个根号！ 然后交个板子就AC了。]]></content>
      <categories>
        <category>分治</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP】笔记 - day4]]></title>
    <url>%2F2018%2F02%2F10%2F%E3%80%90%E5%9B%BE%E8%AE%BA%E3%80%91%E7%AC%94%E8%AE%B0-day4%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： 搜索 DFS 二分图判定 dfs即可。111相邻222，222相邻111。 不是二分图则会染色矛盾。 时空阵 先不考虑距离为mmm。 考虑bfs的分层。 dpi,j,kdp_{i,j,k}dp​i,j,k​​前iii层，jjj个点，第iii层kkk个点的方案数。 枚举第i+1i+1i+1层的点数xxx。 ​ 标号 层内 跨层 转移：dpi+1,j+x,x=dpi,j,k⋅(n−jx)⋅2(x2)⋅(2k−1)xdp_{i+1,j+x,x}=dp_{i,j,k}\cdot\binom{n-j}x\cdot 2^\binom x2\cdot(2^k-1)^xdp​i+1,j+x,x​​=dp​i,j,k​​⋅(​x​n−j​​)⋅2​(​2​x​​)​​⋅(2​k​​−1)​x​​ 现在考虑距离为mmm。 dpm,j,k⋅kn−1dp_{m,j,k}\cdot \frac k{n-1}dp​m,j,k​​⋅​n−1​​k​​第mmm层，jjj个点，第mmm层kkk个点。kn−1k\over n-1​n−1​​k​​是因为概率和对称性。 每个k元组出现的概率是相等的。 再考虑剩下的n−jn-jn−j个点连边。 它们可以内部连边，并且只能和第mmm层(k个点)连边。 ​ 内部 外部 所以dpm,j,k⋅kn−1⋅2(n−j2)⋅2k(n−j)dp_{m,j,k}\cdot\frac k{n-1}\cdot 2^\binom {n-j}2\cdot 2^{k(n-j)}dp​m,j,k​​⋅​n−1​​k​​⋅2​(​2​n−j​​)​​⋅2​k(n−j)​​。 欧拉回路 正常版 图必须联通，小心孤立点 充要条件： 欧拉路：000或222个奇点。 欧拉回路：全是偶点。 证明略 “回溯算法” 算法证明略 代码： 12345678910111213void dfs(int u, int c) &#123; // O(n+m) void dfs(int u) &#123; while (!e[u].empty()) &#123; int v = e[u][e[u].size()-1].first; int id = e[u][e[u].size()-1].second; e[u].pop_back(); // O(1) 减小循环代价 if (vis[id]) continue; // 有向图删了 vis[id] = 1; // 有向图删了 dfs(v); ans.push_back(id);// auto it=--e[u].end(); &#125;&#125; 高端版 最少路径数覆盖整张图？ 先往2k2k2k个奇点之间加kkk条边让奇点消失。然后跑欧拉回路，然后拆边，会拆成kkk条路径。 然后这题就成了结论题。 例题 1 ? 2 将区间中的lll和rrr构点建边，然后判跑一遍欧拉回路。 如果有欧拉回路，那么方向是→就将区间设为111，如果是←就设为−1-1−1。 没有欧拉回路就把点全部升序排序，然后121212、343434、565656…的连边。 然后去掉加的边按方向设置111或−1-1−1。 证明略 Dijkstra 每次将最短路最短的未确定点确定，然后再将新确定点相邻的点更新，直到跑完为止。 可以利用小根堆将复杂度优化至O((n+m)logn)O((n+m)\log n)O((n+m)logn)。 平板电视大法好 稠密图用naive算法，不要优化！不要优化！！不要优化！！！ Bellman-Ford O(nm)O(nm)O(nm) 不怕负权边。 dis[u][i]dis[u][i]dis[u][i]走不超过iii步到uuu点 方程：dis[u][i]=min(dis[u][i−1],dis[v][i−1]+w[v][u])dis[u][i]=min(dis[u][i-1], dis[v][i-1]+w[v][u])dis[u][i]=min(dis[u][i−1],dis[v][i−1]+w[v][u]) 华容道 并没有 dis(x,y,dir)dis(x,y,dir)dis(x,y,dir)表示把(x,y)(x,y)(x,y)往dirdirdir方向移动。 将空格移到(x,y)(x,y)(x,y)附近需要ccc的代价，可以预处理。 多点最短路 HDU 6166 简单版 考虑无向图。 先把所有kkk中的点的disdisdis设为000，然后松弛时记录父节点。 然后枚举所有边，如果边的两边是来自不同的源点，那么用dis[u]+dis[v]+w[u][v]dis[u]+dis[v]+w[u][v]dis[u]+dis[v]+w[u][v]更新答案。 正常版 ????? 定义f(u,v)f(u,v)f(u,v)为uuu点集到vvv点集的最短路。 然后弄一个超级源和一个超级汇，一个连整个uuu，一个连整个vvv，然后算一下最短路即可。 然后做2log2n2log_2n2log​2​​n跑出对于u,v∈S,u≠vu,v\in S,u\ne vu,v∈S,u≠v中f(u,v)f(u,v)f(u,v)。 复杂度nlog2nnlog^2nnlog​2​​n。 强连通分量 如果一张图中所有的点对(u,v)(u,v)(u,v)中的u,vu,vu,v可以互相到达，那么张图是强连通的。 树边：从父亲跑到儿子的边。 返祖边：从晚辈跑到祖辈的边。 前向边：从祖辈跑到晚辈的边。(不包括树边) 横叉边：乱连的边。 Low Case：树边+返祖边(u,v)(u,v)(u,v) 那么uuu到vvv的路径全部在同一个强连通分量里。 首先弄一个时间戳，也就是dfn。 定义low[i]代表iii子树能通过返祖边和横叉边能够到的的最浅的点(跳出子树为止)。 如果dfn[i]=low[i]，那么iii子树再也跳不上去了，所以iii子树组成一个强连通分量。 注意！如果你通过横叉边往上跑的时候跑到的是一个完整的强连通分量，那么Congratulations，这个作废。 12345678910111213141516171819202122void dfs(int u) &#123; dfn[u] = low[u] = ++ind; // index ins[u] = 1; // instack(没形成强连通分量的栈) st[++top] = u; for (int i = 0; i &lt; e[u].size(); i++) &#123; int v = e[u][i]; if (!dfn[v]) &#123; dfs(v); low[u] = min(low[u], dfs(low[v])); &#125; else if (ins[v]) &#123; // 不是强连通分量 low[u] = min(low[u], dfn[v]); // 可以换成low[v] &#125; &#125; if (dfn[u] == low[u]) &#123; ++cnt; while (1) &#123; bel[st[top]] = cnt; // belong ins[st[top]] = 0; if (st[top--] == u) break; &#125; &#125;&#125; 缩点 缩点后一定是个DAG。 最大半联通子图 先缩点。 如果图有分叉就会发现不可达，然后求最长链即可。 于是每个点都有了权值w[i]w[i]w[i]。 最后就直接dp[u]=max(dp[v]+w[v]),(u,v)∈Edp[u]=\max(dp[v]+w[v]), (u,v)\in Edp[u]=max(dp[v]+w[v]),(u,v)∈E。]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP】笔记 - day3]]></title>
    <url>%2F2018%2F02%2F09%2F%E3%80%90DP%E3%80%91%E7%AC%94%E8%AE%B0-day3%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： day2 欠账 最长简单环 fp,s,tf_{p,s,t}f​p,s,t​​从sss到ttt经过点集ppp是否存在。 初始：f2i−1,i,i=1f_{2^{i-1},i,i}=1f​2​i−1​​,i,i​​=1 如果iii满足(t,i)∈E,(p&gt;&gt;(i+1)&amp;1)=0(t, i) \in E, (p&gt;&gt;(i+1)\&amp;1)=0(t,i)∈E,(p&gt;&gt;(i+1)&amp;1)=0，就可以转移fp∣(1&lt;&lt;(i−1)),s,if_{p|(1&lt;&lt;(i-1)),s,i}f​p∣(1&lt;&lt;(i−1)),s,i​​ fp,s,t=1f_{p,s,t}=1f​p,s,t​​=1且(t,s)∈E(t,s) \in E(t,s)∈E，则长度为__builtin_popcount(p)。 复杂度：2nn32^nn^32​n​​n​3​​ 优化 限定sss是环中最小的编号，其它条件不变。 转移时枚举s+1...ns+1...ns+1...n ∑in2nn=n∑i=1n2i=O(2nn)\sum_i^n2^nn=n\sum_{i=1}^n2^i=O(2^nn)∑​i​n​​2​n​​n=n∑​i=1​n​​2​i​​=O(2​n​​n) 例题6 fpf_pf​p​​在组里的最大收益。 fp=maxsw[s]+fp−sf_p=\max\limits_s w[s]+f_{p-s}f​p​​=​s​max​​w[s]+f​p−s​​ (p&amp;s)=s(p\&amp;s)=s(p&amp;s)=s O(4n)O(4^n)O(4​n​​)并不能跑过n=16n=16n=16。 优化 ppp有2k−12^{k-1}2​k−1​​个非空子集，可以用000~2k−12^{k-1}2​k−1​​表示所有的子集。只需2k−12^{k-1}2​k−1​​枚举子集。 对于每一个集合PPP，那么子集数为2∣P∣2^{|P|}2​∣P∣​​。 复杂度O(3n)O(3^n)O(3​n​​) 123for (s=p; s; s=(s-1)&amp;p) &#123; // 不重复枚举所有p的子集 // do something...&#125; 生成树计数 令111为根。 fi,pf_{i,p}f​i,p​​代表iii的子树中，有ppp个点的子树个数。 1init : f[i][1&lt;&lt;(i-1)] = 1; fi,p=∑fj,sfi,p−s,s⊆P−{i},j∈sf_{i,p}=\sum f_{j,s}f_{i,p-s}, s\subseteq P-\{i\} , j\in sf​i,p​​=∑f​j,s​​f​i,p−s​​,s⊆P−{i},j∈s 设min(P−{i})=k\min(P-\{i\})=kmin(P−{i})=k。 复杂度O(3nn2)O(3^nn^2)O(3​n​​n​2​​) 枚举顺序 i 1~n P 0~2^n-1 斯坦纳树 fi,pf_{i,p}f​i,p​​以iii为根，经过关键点集合ppp。 i,ji,ji,j是关键点fi,p=minfj,s+fi,p−s+wi,jf_{i,p}=\min f_{j,s}+f_{i,p-s}+w_{i,j}f​i,p​​=minf​j,s​​+f​i,p−s​​+w​i,j​​ 孤立点从子树接边fi,p=minfj,p+wi,jf_{i,p}=\min f_{j,p}+w_{i,j}f​i,p​​=minf​j,p​​+w​i,j​​ 带环，需要用最短路转移！ 轮廓线DP⊆\subseteq⊆状压 例题9 暴力 fi,pf_{i,p}f​i,p​​代表扫到了iii列，ppp从上一行突出来了。 Procedure： ppp碰到障碍点，直接扔掉。 枚举sss，代表在第iii行会横出下一行。 满足s&amp;(p|障碍)=0。 而且竖着的骨牌必须可以摆在~(s|障碍|p)中。 复杂度3^nn^{很多次方} 高端操作(轮廓线DP) 首先一列一列放骨牌，然后总共有n+1n+1n+1个边界。 放置的方式： 12345671 8 15 . #2 9 . . #3 10. . #4 11. #5 12. #6 13. #7 14. # 边界： 1234567. . . . # 1. . . . # 1. . . . # 1. . . # 2. . . # 1. . . # 1. . . # 1 如图，有n+1n+1n+1个边界。 可以记录状态fi,j,pf_{i,j,p}f​i,j,p​​代表放到了(i,j)(i,j)(i,j)点，边界ppp方案数。 不合法状态： iii要长出来或i+1i+1i+1要长出来并且(i,j)(i,j)(i,j)是障碍。 iii和i+1i+1i+1都要长出来。 合法状态： iii和i+1i+1i+1只有一个长出来并且(i,j)(i,j)(i,j)不是障碍， 转移到P−(1&lt;&lt;(i−1))P-(1&lt;&lt;(i-1))P−(1&lt;&lt;(i−1))或P−(1&lt;&lt;i)P-(1&lt;&lt;i)P−(1&lt;&lt;i)。 其它长出情况直接转移到P+(1&lt;&lt;(i−1))P+(1&lt;&lt;(i-1))P+(1&lt;&lt;(i−1))或P+(1&lt;&lt;i)P+(1&lt;&lt;i)P+(1&lt;&lt;i)。 最后扫完一行后需要更新轮廓线才可以继续DP。 新的轮廓线中的第一个一定是000(边界外不可能有股牌下来) 如果n+1n+1n+1为111就直接丢掉(伸到了边界外面) 然后就直接左移一位(111移到222 222移到333…nnn移到n+1n+1n+1) 复杂度O(2nn2)O(2^nn^2)O(2​n​​n​2​​) 枚举顺序jjj、iii、ppp。 k国王问题 fi,j,k,pf_{i,j,k,p}f​i,j,k,p​​ 放到(i,j)(i,j)(i,j)，放了kkk个国王，轮廓线外的ppp格会被攻击。 讨论两种情况：放还是不放。 放就把周围一圈的ppp更新，否则直接转移。 maxi=0\max\limits_i=0​i​max​​=0 day2e B f_{叶子}=+\inf,f_.=0 fi+=min(w,fj)f_i+=\min(w,f_j)f​i​​+=min(w,f​j​​) C fi,pf_{i,p}f​i,p​​ 前iii选ppp是否能到达 枚举aaa、bbb。 fi,p−&gt;fi+1,p+(1&lt;&lt;(a−1))+(1&lt;&lt;(b−1))f_{i,p}-&gt;f_{i+1,p+(1&lt;&lt;(a-1))+(1&lt;&lt;(b-1))}f​i,p​​−&gt;f​i+1,p+(1&lt;&lt;(a−1))+(1&lt;&lt;(b−1))​​ (p&gt;&gt;(a,b−1))&amp;1=0(p&gt;&gt;(a,b-1))\&amp;1=0(p&gt;&gt;(a,b−1))&amp;1=0，满足边 A fi,j=∑k=0wifi−1,j−k(jk)f_{i,j}=\sum_{k=0}^{w_i}f_{i-1,j-k}\binom jkf​i,j​​=∑​k=0​w​i​​​​f​i−1,j−k​​(​k​j​​) O((∑wi)2)O((\sum w_i)^2)O((∑w​i​​)​2​​) D 改板轮廓线DP模板 E fi,jf_{i,j}f​i,j​​深度≤j\le j≤j，有iii点。 fi−1,j−1⋅2⋅if_{i-1,j-1}\cdot 2\cdot if​i−1,j−1​​⋅2⋅i ∑k=1i−2fk,j−1⋅fi−k−1,j−1⋅i⋅(i−2i−k−2)\sum_{k=1}^{i-2}f_{k,j-1}\cdot f_{i-k-1,j-1}\cdot i\cdot \binom{i-2}{i-k-2}∑​k=1​i−2​​f​k,j−1​​⋅f​i−k−1,j−1​​⋅i⋅(​i−k−2​i−2​​) f0,i=1f_{0,i}=1f​0,i​​=1 f1,i=1f_{1,i}=1f​1,i​​=1 状态O(nd)O(nd)O(nd)，转移O(n)O(n)O(n) 复杂度O(n2d)O(n^2d)O(n​2​​d)]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP】笔记 - day2]]></title>
    <url>%2F2018%2F02%2F08%2F%E3%80%90DP%E3%80%91%E7%AC%94%E8%AE%B0-day2%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： day1欠账 简单题 fn,x,yf_{n,x,y}f​n,x,y​​长度aaa，x,yx,yx,y表示111和000的奇偶性。 fn,0,y−&gt;fn,0,y xor 1f_{n,0,y} -&gt; f_{n,0,y\ xor\ 1}f​n,0,y​​−&gt;f​n,0,y xor 1​​ fn,x,0−&gt;fn,x xor 1,0f_{n,x,0} -&gt; f_{n,x\ xor\ 1,0}f​n,x,0​​−&gt;f​n,x xor 1,0​​ 矩阵优化 fn+1,0,0,fn+1,0,1,fn+1,1,0,fn+1,1,1f_{n+1,0,0}, f_{n+1,0,1}, f_{n+1,1,0}, f_{n+1,1,1}f​n+1,0,0​​,f​n+1,0,1​​,f​n+1,1,0​​,f​n+1,1,1​​ 000 0/10/10/1 不放 111 转移矩阵 [0100100100000100]\left[ \begin{array}{c} 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right] ​⎣​⎢​⎢​⎡​​​0​1​0​0​​​1​0​0​1​​​0​0​0​0​​​0​1​0​0​​​⎦​⎥​⎥​⎤​​ 树形DP 重点！如果合并两个子树时间是两个子树的乘积，那么这个树形DP是平方的 模板 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;void merge(int x, int p) &#123; // 合并子树 f[p][0] = f[p][1] + /* max(f[k][0], f[k][1]) */; f[p][1] = f[p][0] + f[x][1];&#125;void init(int x) &#123; // 初始化 // f[k][0] = 0;// f[k][1] = 1;&#125;void treedp(int x) &#123; // 树形dp 不需要改 for (int i = 0; i &lt; c[x].size(); i++) &#123; treedp(c[x][i]); &#125; init(x); for (int i = 0; i &lt; c[x].size(); i++) &#123; merge(c[x][i], x); &#125;&#125;int main() &#123; // 状态 -&gt; init -&gt; merge &#125; 最大独立集 同模板 例题2 123456state: f[i][0], f[i][1]init : f[i][1] = f[i][0] = 0;merge: f[x][1] = max(f[p][1] + max(f[x][1], f[x][0]), f[p][0] + f[x][0] + 1); : f[x][0] = f[p][0] + max(f[x][1], f[x][0]); // 缺失部分 例题3 12345state: f[i][0] 我不是，孩子也不是[不合法] : f[i][1] 我不是，孩子是[合法] : f[i][2] 我是[满足]init : f[i][0] = 0, f[i][2] = 1, f[i][1] = 0x3f3f3f3fmerge: x\p 0 1 2 0 2 1 0 1 2 2 1 1 2 HOMEWORK：距离为222 例题4 简化版(只考虑子树) 12345f[i][x][y] 当前子树关键点 当前子树的子树f[i][0][0] = 0f[i][1][0] = 1f[i][0][1] = f[i][1][1] = 0x3f3f3f3f x\p 0,0 0,1 1,0 1,1 0 0,1 1,1 1 1,0 1,1 1,0 1,1 普通版 存在度数大于333的点 贪心地选一个度大于333的点为根，然后同简化版 不存在(链)，输出111。 例题5 1234567f[i]表示只删以i为根的子树的ans(minimal maximum)f[叶子]=0x3f3f3f3ff[其它]=0merge:f[i]=max(f[i], x); 练习1 1234 0 1 ---0|0 11|0 x ans = 5471492 [暂缺] 例题6 简化版(只考虑子树) ff=max(ff,fj−wj)f_f=\max(f_f, f_j-w_j)f​f​​=max(f​f​​,f​j​​−w​j​​) 普通版 令子树外最长路为uiu_iu​i​​。 维护次大值gfg_fg​f​​和fff_ff​f​​的来源wherefwhere_fwhere​f​​。 gfg_fg​f​​初始000。 1234if (f[k] + w &gt; f[f]) &#123; g[f] = f[k]; &#125; 123456User -&gt; Web: SubmitWeb -&gt; Judger: SubmitNote right of Judger: Waiting &amp; JudgingJudger -&gt; Web: WAWeb -&gt; User: WANote left of User: MMP 123456789101112131415161718start=&gt;start: 做题needIOOptimize=&gt;condition: 需要快速IO?kengDie=&gt;operation: 坑爹,命题人SBimplementation=&gt;condition: 大模拟题?codeLong=&gt;operation: 难写,命题人SBconstant=&gt;condition: 题目还卡常?boring=&gt;operation: 无聊,命题人SBisEasy=&gt;condition: 题目太简单?water=&gt;operation: 太水,命题人SBend=&gt;end: 婊死出题人start-&gt;needIOOptimizeneedIOOptimize(yes)-&gt;kengDie-&gt;endneedIOOptimize(no)-&gt;implementationimplementation(yes)-&gt;codeLong-&gt;endimplementation(no)-&gt;constantconstant(yes)-&gt;boring-&gt;endconstant(no)-&gt;water-&gt;end 例题7 令每条边经过fif_if​i​​次，那么ans=∑difians = \sum d_if_ians=∑d​i​​f​i​​，did_id​i​​是权值。 dfs求出fif_if​i​​即可。 监测站 乱搞 树形背包 fi,jf_{i,j}f​i,j​​表示iii子树jjj容量 gi,jg_{i,j}g​i,j​​表示不选iii的子树jjj容量 初始gi,j=0g_{i,j}=0g​i,j​​=0 如果选iii就一定选整个子树 ：max(gi,j,∑vi)(j≥∑vi)max(g_{i,j},\sum v_i)(j \ge \sum v_i)max(g​i,j​​,∑v​i​​)(j≥∑v​i​​) gi,a+b′=gi,a+fc,bg&#x27;_{i,a+b}=g_{i,a}+f_{c,b}g​i,a+b​′​​=g​i,a​​+f​c,b​​ fi,j={gi,jj&gt;∑vi,max(gi,j,∑vi)j≥∑vi. f_{i,j}=\left\{\begin{array}l g_{i,j} &amp; j&gt;\sum v_i,\\ max(g_{i,j}, \sum v_i) &amp; j\ge \sum v_i. \end{array}\right. f​i,j​​={​g​i,j​​​max(g​i,j​​,∑v​i​​)​​​j&gt;∑v​i​​,​j≥∑v​i​​.​​ 时间复杂度O(n3)O(n^3)O(n​3​​) 状压DP 例题1 fi,p[n]f_{i,p[n]}f​i,p[n]​​前iii衣服，pip_ip​i​​裤子是否配对。 for j=1...n (i+1, j)可配对，pj=0p_j=0p​j​​=0 f[i+1][j|(1&lt;&lt;(j-1))] += f[i][j]; 12343 91 1 1 2 1 32 1 2 2 2 33 1 3 2 3 3 例题2 拓扑排序计数(NP-Hard) fpf_pf​p​​选的点数。 对于所有满足要求的(k, j)，jjj没被选，kkk放了，fp∣(1&lt;&lt;(j−1))+=fpf_{p|(1&lt;&lt;(j-1))} += f_pf​p∣(1&lt;&lt;(j−1))​​+=f​p​​。 20:2n20: 2^n20:2​n​​ 18:2nn18: 2^nn18:2​n​​n 16:2nn2/3n16: 2^nn^2 / 3^n16:2​n​​n​2​​/3​n​​ 例题3 tit_it​i​​代表第iii条直线覆盖点的。 fp=min(fp∣ti,...,fp+1)f_p=\min(f_{p|t_i},...,f_p+1)f​p​​=min(f​p∣t​i​​​​,...,f​p​​+1) 固定一个端点，可以将枚举直线改为O(n)O(n)O(n)。 2n个点最短路乱搞？ 例题4 Who knows？ for i=1..m fp∣ti=max(...,fp+1)(p&amp;ti=0)f_{p|t_i}=\max(..., f_p+1)(p\&amp;t_i=0)f​p∣t​i​​​​=max(...,f​p​​+1)(p&amp;t​i​​=0) 例题5 最长简单环(NP-Hard NPC) 实现例题2 (选做例题5)]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP】笔记 - day1]]></title>
    <url>%2F2018%2F02%2F07%2F%E3%80%90DP%E3%80%91%E7%AC%94%E8%AE%B0-day1%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： fi,j+1=fa,b(Aa=Ab,Ai=Aj,Aa&gt;Ai,i&lt;a,j&lt;b)f_{i,j}+1=f_{a,b}(A_a=A_b, A_i=A_j, A_a &gt; A_i, i&lt;a, j&lt;b)f​i,j​​+1=f​a,b​​(A​a​​=A​b​​,A​i​​=A​j​​,A​a​​&gt;A​i​​,i&lt;a,j&lt;b) 二叉树枚举aaa，求出jjj之后第一个Aa=AbA_a = A_bA​a​​=A​b​​ 预处理？ ni,x≠i+1,ni,x=ni+1,xn_{i,x} \ne i+1, n_{i,x}=n_{i+1,x}n​i,x​​≠i+1,n​i,x​​=n​i+1,x​​ ni,x=i+1,ni,x=i+1n_{i,x} = i+1, n_{i,x} = i+1n​i,x​​=i+1,n​i,x​​=i+1 1| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | fn,m=(s−1n−1)∑s=1nfn−s,m−1f_{n,m} = \binom {s-1} {n-1}\sum_{s=1}^nf_{n-s,m-1}f​n,m​​=(​n−1​s−1​​)∑​s=1​n​​f​n−s,m−1​​ fn,m=mfn−1,m+fn−1,m−1f_{n,m}=mf_{n-1,m}+f_{n-1,m-1}f​n,m​​=mf​n−1,m​​+f​n−1,m−1​​ 优化状态？转移？ 错排问题 fnf_nf​n​​ 当a≠na \ne na≠n时，(n−1)fn−2(n-1)f_{n-2}(n−1)f​n−2​​ 当a=na=na=n时，(n−1)fn−1(n-1)f_{n-1}(n−1)f​n−1​​ fn=(n−1)(fn−1+fn−2)f_n=(n-1)(f_{n-1}+f_{n-2})f​n​​=(n−1)(f​n−1​​+f​n−2​​) 逆序对 fn,mf_{n,m}f​n,m​​代表nnn个数产生mmm个逆序对的数量。 fn,m=∑k=1nfn−1,m−k+1f_{n,m}=\sum_{k=1}^nf_{n-1,m-k+1}f​n,m​​=∑​k=1​n​​f​n−1,m−k+1​​ 前缀和优化 (m−n,m](m-n,m](m−n,m] fn,m=gi,m−gi,m−nf_{n,m}=g_{i,m}-g_{i,m-n}f​n,m​​=g​i,m​​−g​i,m−n​​ 例题2 【IMPOSSIBLE】 f_{i,j}前iii物品，取jjj的长度，方案数。 f_{i,j}=\sum_{k=0}^{w_i}g_{j-k,k}f_{i-1,j-k} 例题3 二叉树：fn=∑i=0n−1fifn−i−1(n−1i)f_n=\sum_{i=0}^{n-1}f_if_{n-i-1}\binom {n-1} if​n​​=∑​i=0​n−1​​f​i​​f​n−i−1​​(​i​n−1​​) 二叉树的子结构性质 有根树：fn=∑i=1n−1fifn−i(n−2i−1)f_n = \sum_{i=1}^{n-1}f_if_{n-i}\binom{n-2}{i-1}f​n​​=∑​i=1​n−1​​f​i​​f​n−i​​(​i−1​n−2​​) 去掉一棵子树还是一棵树 kkk叉树：f_{n,k}=\sum_{i=1}^{n-1}f_{i,1}f_{n-i,k-1}\binom{n-2}{i-1} gn,m=∑i=1n−1gn−i,m−1fig_{n,m}=\sum_{i=1}^{n-1}g_{n-i,m-1}f_ig​n,m​​=∑​i=1​n−1​​g​n−i,m−1​​f​i​​ fi=∑j=0kgi,jf_i=\sum_{j=0}^kg_{i,j}f​i​​=∑​j=0​k​​g​i,j​​ gn,mg_{n,m}g​n,m​​ 根mmm其它nnn 拆分数 fi,j=fi,j−i+fi−1,j−if_{i, j} = f_{i, j-i} + f_{i-1, j} - if​i,j​​=f​i,j−i​​+f​i−1,j​​−i n≤105n \le 10^5n≤10​5​​情况 gi,jg_{i,j}g​i,j​​ iii个数，和为jjj。 i≤ni \le \sqrt ni≤√​n​​​时：fi,j=fi−1,j+fi,j−if_{i,j}=f_{i-1,j}+f_{i,j}-if​i,j​​=f​i−1,j​​+f​i,j​​−i i≥ni \ge \sqrt ni≥√​n​​​时：gi,j=gi−1,j−1+gi,j−ig_{i,j}=g_{i-1,j-1}+g_{i,j-i}g​i,j​​=g​i−1,j−1​​+g​i,j−i​​ h_j = \sum_{i=0}^\sqrt ng_{i,j-i\sqrt n} Ans=∑A=0nfn,Ahn−AAns = \sum_{A=0}^nf_{\sqrt n, A}h_{n-A}Ans=∑​A=0​n​​f​√​n​​​,A​​h​n−A​​ Alt+F4 F(U)⊂KF(U)\subset KF(U)⊂KING HOMEWORK Y∅∪RY\emptyset\cup RY∅∪R logn\log nlogn 202020 n\sqrt n√​n​​​ 300300300 求长度为500050005000恰好有100000100000100000个逆序对的排列个数 nnn个点带标号的无向图个数 nnn个点带标号的无向连通图个数 n≤5000n \le 5000n≤5000 = = 2(n2)2^\binom n22​(​2​n​​)​​ fn=2(n2)−∑i=1nfi×2(n−22)×(n−1i−1)f_n=2^\binom n2-\sum_{i=1}^nf_i\times2^\binom{n-2}2\times\binom{n-1}{i-1}f​n​​=2​(​2​n​​)​​−∑​i=1​n​​f​i​​×2​(​2​n−2​​)​​×(​i−1​n−1​​) 选标号(n−1i−1)\binom{n-1}{i-1}(​i−1​n−1​​)]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【膜法】代码片段]]></title>
    <url>%2F2018%2F02%2F06%2F%E3%80%90%E8%86%9C%E6%B3%95%E3%80%91%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>膜法</category>
      </categories>
      <tags>
        <tag>膜法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【贪心】Codeforces 886C - Petya and Catacombs]]></title>
    <url>%2F2018%2F02%2F06%2F%E3%80%90%E8%B4%AA%E5%BF%83%E3%80%91Codeforces-886C-Petya-and-Catacombs%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 886C Petya在图上探险。每一分钟随机走动一次(可以原地)。 如果走到的是一个新点，随机写一个数字。 如果以前来过，写最近一次到这里的时间。 第000分钟Petya在原地并且没有写数字。 给你Petya写的一串数字，问你最少有几个点。 解法 题目绕了半天&gt;_&lt;。 TLE做法 记录每个点最后一次到的时间，每输入一个数字，O(n)O(n)O(n)地查询有没有踩过的点，如果没有就开新点，否则用久点。时间复杂度O(n2)O(n^2)O(n​2​​)，完美TLE。 AC做法1 考虑每一个数字。每出现一个数字，可能是以前踩过的点，也可能是随机数(新点)。 并且不可能同时踩到两个不同的点，那么同一个数字出现nnn次，至少n−1n-1n−1次是随机数。 时间复杂度O(n)O(n)O(n)。 AC做法2 考虑优化TLE做法。根据AC做法1中得出的结论，每一个点最后一次到达的时间是不同的。 开一个长度为nnn的数组记录每一个时间是否是某个点的最后一次到达的时间。 然后for i=1...n scanf(&quot;%d&quot;, &amp;x)。 如果xxx是某个点最后一次到达的时间，那么就让它不是(因为那个点已经被更新了)。 否则(这是个随机数)就ans++。 并且无论是以上哪种情况，某个点最后一次到达的时间都一定会被置为iii，所以vis[i]=1。 代码 思路1 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, ans = 1;int vis[200005];int main() &#123; for(scanf("%d", &amp;n); n--; ) &#123; scanf("%d", &amp;x); if (!vis[x]) vis[x] = 1; else ans++; &#125; printf("%d", ans);&#125; 思路2 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, ans = 1;int vis[200005];int main() &#123; scanf("%d", &amp;n); vis[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); if (vis[x]) vis[x] = 0; else ans++; vis[i] = 1; &#125; printf("%d", ans);&#125; 拓展 话说两段代码长得好像啊~]]></content>
      <categories>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【数学】Codeforces 872C - Maximum splitting]]></title>
    <url>%2F2018%2F02%2F06%2F%E3%80%90%E6%95%B0%E5%AD%A6%E3%80%91Codeforces-872C-Maximumsplitting%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 872C 给你nnn个数，问你这些数最多可以写成多少个合数的和。n≤105,1≤x≤109n \le 10^5, 1 \le x \le 10^9n≤10​5​​,1≤x≤10​9​​ 解法 考虑分解的策略。 首先，最小的444个合数分别是4,6,8,94, 6, 8, 94,6,8,9。 很明显，分解得到的合数越小越好。分类讨论： 当xxx是1,2,3,5,7,111, 2, 3, 5, 7, 111,2,3,5,7,11时无解，输出−1-1−1。 当xxx是偶数时，因为x&gt;2x&gt;2x&gt;2，而且444和666可以组成所有大于222的偶数。所以只需要用444和666即可。 当xxx是奇数时，因为大于111111的奇数和999自身都有解，并且大于111111的奇数都可以写成999和大于444的偶数的和。所以只需要用x−9x-9x−9再按情况2计算即可。 综上所述，需要用到的数字只有4,6,94, 6, 94,6,9。 现在考虑分解出的数的个数。 当xxx是1,2,3,5,7,111, 2, 3, 5, 7, 111,2,3,5,7,11时，输出−1-1−1。 当xxx能被444整除时，输出x4\frac x4​4​​x​​。 当xxx是偶数且不能被444整除时，输出x−64+1\frac{x-6}4+1​4​​x−6​​+1。 当xxx是奇数时，输出x−94+1\frac{x-9}4+1​4​​x−9​​+1。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n, x;int f(int x) &#123; if (!x) return 0; if (x &lt; 4 || x == 5 || x == 7 || x == 11) return -1; if (x &amp; 1) return f(x-9) + 1; if (x &amp; 2) return f(x-6) + 1; return x&gt;&gt;2;&#125;int main() &#123; for (scanf("%d", &amp;n); n--; ) &#123; scanf("%d", &amp;x); printf("%d\n", f(x)); &#125;&#125; 拓展 对于分解性的问题，如果需要最大化某个量，则极端地考虑可能的取值。 如最大化数量，可以考虑让数字尽可能小。 如最大化乘积，可以考虑让2,32, 32,3尽可能多。 然后再证明自己的猜想，如本题的&quot;4,6,94, 6, 94,6,9&quot;。]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DFS】伪背包1007-C]]></title>
    <url>%2F2018%2F01%2F08%2F%E3%80%90DFS%E3%80%91%E4%BC%AA%E8%83%8C%E5%8C%851007-C%2F</url>
    <content type="text"><![CDATA[题意 传送门：1007-C 给定一个容量为TTT的背包，nnn个物品，第iii个物品重量c[i]c[i]c[i]价值v[i]v[i]v[i]，最少要装mmm个物品，最少要留ttt的剩余空间，最大化价值与剩余空间×g\times g×g的值。n≤10n \le 10n≤10。 解法 这是一道披着背包外衣的入门难度DFS。 直接dfs带444个参数dep,cnt,val,remdep, cnt, val, remdep,cnt,val,rem分别代表深度(1~n) 已选物品数 已选物品价值 剩余容量，搜到dep&gt;ndep&gt;ndep&gt;n判断rem&lt;t∣∣cnt&lt;mrem&lt;t||cnt&lt;mrem&lt;t∣∣cnt&lt;m是否满足即可更新答案。 否则搜索下面两个即可，不用剪枝。 dfs(dep+1,cnt+1,val+v[dep],rem-c[dep]); dfs(dep+1,cnt,val,rem); 时间复杂度O(2n)O(2^n)O(2​n​​)。 代码 不要在意这些细节，本人卡常癌晚期请谅解 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define spc putchar(' ')#define nln putchar('\n')using namespace std;template &lt;typename T&gt;inline void get(register T&amp; val) &#123; /* 一千万个数400ms超高速读入黑科技略 */&#125;template &lt;typename T&gt;inline bool put(register const T&amp; val) &#123; /* 普通高速输出黑科技略 */&#125;// Solution Begins Hereint n, m, d, t, g, c[32], v[32], ans;// 不要在意这些细节inline void dfs(register int dep, register int cnt, register int val, register int rem) &#123; if (dep &gt; n) &#123; if (rem &lt; t || cnt &lt; m) return; ans = max(ans, val + rem * g); &#125; else &#123; dfs(dep + 1, cnt + 1, val + v[dep], rem - c[dep]); dfs(dep + 1, cnt, val, rem); &#125;&#125;int main() &#123; get(n); get(m); for (register int i = 1; i &lt;= n; i++) &#123; get(c[i]); get(v[i]); &#125; get(d); get(t); get(g); dfs(1, 0, 0, d); put(ans);&#125; 拓展 对于数据较小的题目，有时DP难写，可以考虑使用暴搜，有时甚至不需要剪枝。]]></content>
      <categories>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【位运算】Codeforces 897C - Short Program]]></title>
    <url>%2F2018%2F01%2F01%2F%E3%80%90%E4%BD%8D%E8%BF%90%E7%AE%97%E3%80%91Codeforces-897C-Short-Program%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 897C 给一串位运算操作(包含| &amp; ^，每个操作数均落在。中)，将其简化到5次运算以内并输出。 解法 过程 考虑交换律和结合律。显然1|11$\ne$11|1。所以要换一种思路。 我们可以将102310231023和000同时进行运算。 再考虑将&amp; | ^三种运算转化为| ^两种。 如将102310231023和000带入以下运算： 123456789101110 1111111111 0000000000^ 218 0011011010 1100100101&amp; 150 0010010010 0000000100| 935 1110110111 1110100111&amp; 61 0000110101 0000100101| 588 1001111101 1001101101&amp; 897 1000000001 1000000001| 411 1110011011 1110011011| 584 1111011011 1111011011^ 800 0011111011 0011111011| 704 1011111011 1011111011 使用| ^代替&amp; | ^的方法： 置零，使用|1^1 置一，使用|1^0 不变，使用|0^0 反转，使用|0^1 令1023 or x xor y=a=7631023\ or\ x\ xor\ y=a=7631023 or x xor y=a=763，0 or x xor y=b=7630\ or\ x\ xor\ y=b=7630 or x xor y=b=763 即如果aaa和bbb某一位一样，xxx的那一位就是1，yyy的那一位就是bbb那一位的反码。 如果不一样，xxx的那一位就是000，yyy的那一位也是bbb那一位的反码。 两数每一位相同得111，不同得000，就是a xor b xor 1023a\ xor\ b\ xor\ 1023a xor b xor 1023的值。 bbb的反码即b xor 1023b\ xor\ 1023b xor 1023。 结论 x=a xor b xor 1023x = a\ xor\ b\ xor\ 1023x=a xor b xor 1023 y=b xor 1023y = b\ xor\ 1023y=b xor 1023 O(n)O(n)O(n)边读边算aaa和bbb，最后O(1)O(1)O(1)算xxx和yyy即可。 代码 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define p(q) ((q) &amp;&amp; (q) != X)#define X 0x3f3f3f3fusing namespace std;int a = 0, b = 1023;char op[1];int n, t;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s%d", op, &amp;t); switch (*op) &#123; case '&amp;': a &amp;= t; b &amp;= t; break; case '|': a |= t; b |= t; break; case '^': a ^= t; b ^= t; break; &#125; &#125; printf("2\n| %d\n^ %d", a ^ b ^ 1023, b ^ 1023);&#125; 拓展 位运算+构造算法(bitmasks+constructive algorithms)的题目的几种思考方式： 对每一位考虑(位运算都是隔离每位的，不存在借位进位这种影响其它位的运算) 对逆运算考虑(如1216-D，前缀和转为差分) 对结果考虑(结果反向构造过程)]]></content>
      <categories>
        <category>位运算</category>
      </categories>
      <tags>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【差分】1216-D]]></title>
    <url>%2F2017%2F12%2F20%2F%E3%80%90%E5%B7%AE%E5%88%86%E3%80%911216-D%2F</url>
    <content type="text"><![CDATA[题意 传送门：1216-D 有一个nnn个数的序列，一开始所有的数都是000，每次可以将一个区间[l,r][l,r][l,r] (l≤r)内的数+1+1+1，求到达最终状态的最少操作次数。 n \le 10^5，m \le 10^5​，m​为操作次数。 解法 正难则反：考虑已知每次操作，求序列。可使用前缀和。 如样例输出： 123431 61 62 6 将闭区间转为左闭右开，即[1,7),[1,7),[2,7)[1, 7), [1, 7), [2, 7)[1,7),[1,7),[2,7)，则可得到： 1234下标: 1 2 3 4 5 6 7数组: 2 1 0 0 0 0 -3前缀和后得到原序列:原序列: 2 3 3 3 3 3 0 根据前缀和的逆运算是差分，得到O(n+m)O(n+m)O(n+m)解法。 优化 既然差分之后就可以求出所有区间，为什么不直接往队列里面丢呢？ 如差分序列2 1 0 0 0 0 -3，进行以下处理： 遇到正数222，直接丢222个下标111在存lll的队列中。 123l队列 r队列11 遇到正数111，直接丢111个下标222在存lll的队列中。 1234l队列 r队列112 遇到负数-3，直接丢∣−3∣=3|-3|=3∣−3∣=3个下标7−1=67-1=67−1=6在存rrr的队列中。 1234l队列 r队列1 61 62 6 输出即可。 123431 61 62 6 时间复杂度O(n+m)O(n+m)O(n+m)。 代码 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int out[100005][2]; //模拟队列int n, x, m1, m2, r;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); if (r &lt; x) for (int j = x-r; j--;) out[m1++][0] = i; if (r &gt; x) for (int j = r-x ; j--;) out[m2++][1] = i-1; r = x; &#125; for (int j = r ; j--;) out[m2++][1] = n; printf("%d\n", m1); for (int i = 0; i &lt; m1; i++) &#123; printf("%d %d\n", out[i][0], out[i][1]); &#125;&#125; 拓展 正难则反：很多题目需要逆向思考。如将差分题逆向思考得到前缀和。多考虑互逆运算之间的转化关系。]]></content>
      <categories>
        <category>差分</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【差分】差分]]></title>
    <url>%2F2017%2F12%2F20%2F%E3%80%90%E5%B7%AE%E5%88%86%E3%80%91%E5%B7%AE%E5%88%86%2F</url>
    <content type="text"><![CDATA[大家都知道大名鼎鼎的前缀和，差分就是前缀和的逆运算。 前缀和 问题：给定一串数，查询区间和。 算法 预处理 查询 朴素算法 O(1)O(1)O(1) O(n)O(n)O(n) 前缀和 O(n)O(n)O(n) O(1)O(1)O(1) 线段树(树状数组) O(n)O(n)O(n) O(logn)O(\log n)O(logn) 显然，多次查询时，前缀和效率最高。 差分？ 标好重点：差分是前缀和的逆运算。 如果给一个前缀和数组，如何将它处理成原数组？ 123456789前缀和:1 2 3 4 5 61 2 3 4 5 1(6-5)1 2 3 4 1(5-4) 11 2 3 1(4-3) 1 11 2 1(3-2) 1 1 11 1(2-1) 1 1 1 1得到原数组:1 1 1 1 1 1 在某些正面解看起来很复杂的题时，可以考虑逆推出前缀和，然后利用差分解题。 相关 高维前缀和(差分) 【差分】1216-D]]></content>
      <categories>
        <category>差分</category>
      </categories>
      <tags>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【杂题】1210-B]]></title>
    <url>%2F2017%2F12%2F14%2F%E3%80%90%E6%9D%82%E9%A2%98%E3%80%911210-B%2F</url>
    <content type="text"><![CDATA[题意 传送门：B题 给一个01矩阵，允许若干次操作，每次一次翻转一行或一列，问最多可以翻出多少个0？ 数据范围：r≤10,c≤10000r \le 10, c \le 10000r≤10,c≤10000。 解法 考虑行固定，只翻列的情况。 因为rrr只有10，所以可以直接二进制枚举，时间复杂度O(2r)O(2^r)O(2​r​​)。 再考虑列。如果一行中0多于1则反转，否则不翻转。可以用两个变量c1c1c1和c2c2c2分别对翻转和不翻转计数(或者c2=r−c1c2=r-c1c2=r−c1)，然后ret += max(c1, c2);或ret += max(c1, r-c1);。时间复杂度O(rc)O(rc)O(rc)。 使用bitset优化编程复杂度和常数除以32。 时间复杂度：O(rc2r32)O(\frac{rc2^r}{32})O(​32​​rc2​r​​​​) 代码 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;using namespace std;typedef bitset&lt;10005&gt; record_type[15];record_type rec;int r, c, a, x;int proc(int mask) &#123; record_type rt; // rec的拷贝 int ret = 0; // 返回值 copy(rec, rec+r, rt); // 非POD类型(bitset&lt;10005&gt;)用std::copy for (int i = 0; i &lt; r; i++) &#123; if ((mask&gt;&gt;i)&amp;1) rt[i].flip(); // 对二进制中每个1反转对应的行 &#125; for (int i = 0; i &lt; c; i++) &#123; int a = 0, b = 0; // int c1 = 0, c2 = 0; for (int j = 0; j &lt; r; j++) &#123; a += rt[j][i]; // c1 b += ~rt[j][i]; // c2 &#125; ret += max(a, b); &#125; return ret; &#125;int main() &#123; scanf("%d%d", &amp;r, &amp;c); for (int i = 0; i &lt; r; i++) &#123; for (int j = 0; j &lt; c; j++) &#123; scanf("%d", &amp;x); rec[i][j] = x; &#125; &#125; for (int i = 0; i &lt; (1 &lt;&lt; r); i++) &#123; // 二进制枚举 a = max(a, proc(i)); &#125; printf("%d", a);&#125;]]></content>
      <categories>
        <category>杂题</category>
      </categories>
      <tags>
        <tag>杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【未完工】【LIS】LIS]]></title>
    <url>%2F2017%2F12%2F14%2F%E3%80%90%E6%9C%AA%E5%AE%8C%E5%B7%A5%E3%80%91%E3%80%90LIS%E3%80%91LIS%2F</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. U2FsdGVkX1/GqRru0j7F9GX6Uc8aP49zT37OHHCvzKiLu5y+8Nts2WX/qVXUZ3mouk3KY15seO1uNzL8qoOy8OCpaCelujOYaP+fYCpIZnQczNIV7gx+xRD3UcUEbgxq9y/iqGklwQKIwR3SKHXyCf0u8ARV6LaNq1c2NNhBgrIUkZQdj4NyMBqQRhDgYWUew5a1ZNI8zMWCqdayaDUl6jaTT0QTWqO0/io3Q/SsjPfHeGlHlJoEcKr9sF0/ujHC43+kHPZiTRxIg89Y7U2WEldnWGnjFRXbe7g4tGeYCPtsY/S2aS/akwsV8wNpxPL0tz1VbBvjxRk1Hm3wZ5rbivrsEFdLUS0Gs8P2nYEX47dwnjSaFbugo2hG6Z0bJWg/UPtnYl1Rkqm9GBc14zf4n5qksrlxgDfYFLCBlmu8LEok16n21Gh1JxT4RqEFvf4hRmord18ccua8X2R1aIXzAIFMUIa+7osudKrrcn6rrMWbr/WN1TZr2fckKVkjlcC1z8HADjnwk5YJ7ubmyMilB2l7yQA9bGoBl9whevMUFpG+DjTWTW+BAu+V+LW+suxfGgQdfmH1rZRCLO9VCIXNDSaiqrlqls8yDVyZXvdBzsBnagTC+e8y6cRbHhg0/U/pjBX+3RzTjjXRWSx5ufLVR1BRAzc3T3LgTMczcMSpEoFgrHtqpvVhOt6E/F+exBczO5LK7Km/nxAgf31JSggMx/fPEyvhwrC18Ajd61GG0uOsWlGuuc3xUJxkQA270oA/0uudx1RWppg+0IIZ2G35F2ezW1wTTuxagr3psyYZngc7x/6Mum24oubWQtUDyJBzyJb9VX3GiTO44H+oxEsSRidlq43fFw3e+jqilZZNBzY+AFuZrZLx0bqmzGJSLJZZARMIf039MRI0WAB/zdi/QbgPxgbk0OshZtAAKF6L9LyAUMz8uxBz7LKPadI65orWnKAd/7pO65j3O5Ic/1wem5z4jwCwBttPpquNAYGnX3IM0TEdwC7ZR2Lnmd4PpyQbOE7A4qS/5usERv2/j15yHGahtQdjQHJTylAa6KY5UoyI4Q2X+a482BLuPMChBwS0iGwAqFFtv1Xv7oWjXlI5q6Ni0aqeQA2LfK3wWuVP48mtQIbQbUv0ODecKYSM0mRWZNPcBQpPJg+1XEe5IpBDRjstjMdEJHHNvu1e2niS9JFG9/m8QIyB/fg7bJoNjwDGZ/8IYYZaUHdDZaJr/47LLbdSplLKfxZKLrPujp1zT/qJVHk+d/aPjsuo00XfjuuZXltbMHez8YOPwyidR9kwkDxpBvjEuc9QK2R3C623dyitLauKLNzahdOQTZ+S0JY9m8fpl15dGsA36zZ+uxgHPf8FJE9EXCAl6yI/JKJ76D5SNifdv2AuiYOo4I41DQIr0PSEM4SGMX/6vTE0z0A+A9re9KnwSHSL8YuoHeNluRz/O64WxG8R4Kbz2SUqvQHcFVInDpz5tlTs1DsfC5uoIyU22WJxdZRB6tkl6Z28NEVYwrD9kWk09KjRejOSS4dGEJHe5Ek+QwMcQjjN1c2ZM8npimuUgCciUH7xv/BnVHjCqAhbL6A5hnqxdktLZwP7xv5vaIzFXGzRanOCM44ZzymsiIVJrWUW1kCowwBHmT7i7KyVKTcwtAcDVQ2q3ALCRGrCq1UZgs+Uluvxa9+sHNaj3CB0m+RW53sggDQG9yOTYhti2r/wAHl1j9KG/ahOQyWPT2QuPlp9rGzIHx8ba46n0L/HUdReDlnPxBgoz6U2BW5G1iKYh8SxtzJs0/cA7UVHoY9c1Fl+8lxZP9tANiHhahf2aa/mvWqWzpStetDaqkD7vlOkutzWY2Yb2w0N/H8JmGSdxns4gK+bFAa3drNXYHrD9bICJXZ8dSXPyoyk/hlR2RJR6Y7Yqvg75yroV/jISx6wwFkWiiLO7F5njuaezjz+4k3WU4mLYrOaZ/6YTOtji6cBBXrlEmpmyEZRxj+/W/t4nrrp35lQOZdyKEWQlFRuZCKqJUVwyfj6dFwSfLAVA359UofulhE0nMzBAtUyKt/WjrO+piGxn6QCjY2ZqAY+DnMe+rjoAq4TXESo66x2TKFq8sTM/17gh9qKEAVPfthrnnNn7Hay2HF4pX/syxdHwDG8MyEcPF6c0bW90H4WjXme52IysYd5DPIUNBGI44LBZdT7rASICUX6W8WzfOK+yml+aJAhuRPWjd+oolrBK7nwufuxLrjL92djaBO/Sv774k5TZL4S1o3NW5+Ui7GI3zkwV8ii2hZsOLvhWKctHxzhctpmoj2y+ZsP90TQs9Dc17Y+7EJ0khV4HxaWt3Am5MLqlWf/bigfMECttE4TjW+WP67pwqR0oAPoQUL/OUZMFeFPAuXloSWTaSG50RYScA00SYbd3Fr58SXKRp5wTscCD6/4EuzApm/wC52VkPZKAtBp32/y7l9W5Oae7gVVucOtLoAwIFucwdFef8ITj1Qgdc5ZegMyWbs3CwzhFEvOIFffJD+plIsNP28zS4NUAjWFiotobqh8PeD/msxcIROktlRhDxLlxDfUN0pJBFKA6klZUsTYgwmVosKcc+KCdY2/Q6k1qyBjHHhINl1pYFDECY8RqrGnBF41nYsbVXirnStX3d8rpnbOmfifqWLdol7XiPZbnEIi7EcjF4rDBrnaFqAMmNzpZW+/WvQnwTNl4+3DaAVk4NO+5848PTZkXXQSRPXxfCRaAZGu2XiWbTyD4i+ha37OLjiM8ibtZ1nZL5kyGdJYNPtM+n49ROCbdLwXYZgTtnF5oOQrvD4Mug0dE7eP3C4nwmDICUE3f52VRiHfqX2xbxbhc/7X+xf/+a5lEx1he2IiF9nkCcjFFn1BzO1QsxzR4Eu0ANpiUQWBSCpT2QfjpG6Loy/BP8nB8A0y+SdDZH5OVROr63p4vU9qqyM/VRB+lgrPD+nzz77n4hfPHf3XvHsqD68HoYm7vcIDW4/Au0z1mZVu2PQYmnhaauDKO4BPc9UCx/99TQwJdiKu2KixQaKNDrVafz75dJpZ4ZG4M1jTxl1QPGVN2bP7cKnQWwUQyRrnuNQ8/Cb1xHOLmNABdyuClXoIWfEpy5r9qrOCw0t3S17DhOEQ7yENsqVcLVECsGqTAAYWqNZl/h9uZzsRhZdOVxV7HU8DxSebnxrQLaUFki+uZcA/Zwi/roii5TElCj3Yx5flU6YEcn3w2jou3eZ9LBswL3wRU5czTaOoSpU9v20atSjI83LPsSW+o63zkdyeUG1PGiMt8nAbnAOEvUFAQiecv1hlwG7ziB95LxfNMhvrqNLNhzdi3or+2fuzkjMBBZWPBquY38U6Sj21YgjR+F/fS2bR0vhjDUDJtqvMDOJpPIAvHjSUAHCJ9fXT8i8OvFf6LYWvBR7OwMdtE+G6b3jRLWBX5+zGsZvN+sru6CkAvNLXhFoB30GZY0SKminR/Gs6/cIiCGL9PSWGMO/2iFZnyLnlYQxqcwrCOzDXaMqjpIbiWu4rJFOwf3HHCQ2nm2KT1ec/BVwjIsJ+WK8K0or3UHadTFC1RHFteOM9jvLcLYAJnpcJV6tXJt/g7OBvYGPhtX3ELoEucK3oeWx+iVbL5tP17mvedFnc6l6rXCIezqKTSh7P/Tm4wtJbbmTinodRiWtvsGL+rzcCFLVvWf/eVZgep1e3IW2/f8w2a8v0tmPHIe8c8s+QZSobblXHn1F12VjATBXMpU/D/B+duZA6Uu6RauL5dz/T+awfWpMTf79jUza7Bwd/U2Mg9Z4uK/ZBQvpdzUPF/t7D3KFTYYhNlnjmvzjf7sZuy9ROPBgrDyzcueBSqenuCU548sRTTs8q/JWd0k2TsmhAOWYKVkQfwLZs0axFhtEAFnAtwx9da3FlR4m0uN1tkWsKXpsXm3XGycKfsA0iZPkewMjkM9g0WfSY6A2xhe3Hnq1wsUOqUYAINw4hTOK2he3OJoJdCYO4CJ9ua20OU0FPJ2+c5bxiyx1GfK0P1pxUQU42NrECbTS+l30T5M38Qjcko6IvBsPgWIGk05vEqzcxwQQ8Oh2B7aoxVR8ok1csRbTDGTvw989R6XysFWEfmp/JMsEYJwXFUIvFioYmWUEbaTXve2QBq6fGuwSIH3Z2KO8lhTNngRuIP4hexlZlSSoj0L60Rfp1JutLDAUTQX9nS9AJpNc0QrYT19Bh9uPupjngfzTdIYre7aCA+EmYfHkxtAjKmwtY69neaaec0vjB4ZWaK9ZmJDgHLL8xBoz6UV7Gpve/IuA0miU/eRR1IW46ZcYzKjbmmTbuCUGZ3CPGd0qtpzx0vzlgxSiNvv/Bh5qOQQauVR8qYt1g1Himf5jqx47YrPyTl622DKya/5cprXv1hp2DkEuydrg8sW7843sac62wNTEC2mM8mUi5cR23g4jkoe9ctPABXODS+8qLy3zIsnO8+zovfNuTs8cESEAW3JFha6pL9oUKRbHtmm5Rc4REnu/nUZHBkGX0oX2i4mZ3QczDSUmgvm5EH1MDFRuV6XmKWsdiOa1yWmUjHGwoeNv/HHQ75EWW70sMBBFvPnvdIt6ya3dyxpoE1l3S3gPmIp4BaTjtEnCKcNY7IvWar14GK258wtAkW/mTEEXuw5nEQTUatUGDKSptgt+GkPPIznK0ioAcsU9lhGmXY4pnGku8zkDwfsu0hWzvWSAfN1/Jl+9N28mtlqqcApwJ3xEitBvklZxzUPqZpJq5xUez6+MIljvQSiy1ag97ohuzGW9fz36rt+i46Xrl+MqNqM7+ENa8XK8Sl66surZqasAwyU89S5UL0OwPQmxIxOjtmCXiPrQFFvHiGqh7rI/RiRh4KgLlTKeYzzHlAhAX86VCm+DT2xkJqJqQV40yK6nHUobt7S+lo4pTpLccw7p4nEjB2UQORWdqX7PeGy1ckaIHNlnzIg2sq9yIy4VY/INAD9RPrgs37QWAFyZfNFy+hJt6GBvN5E5+swe65abSjLzN2yav3HWyrzwqwQEP966A+w8shKeRn5qTAT7i5uMpqJQIiyuJ3r0aU5M0hJbXmMySTQ0+dVYjzznSdUuC9Hwc78udGaBsyJ+0k6lXW3FvTRr1N/3F5s8PocJeeeKAhj4vWWmYwqDXM7QjlmPRlwgssMKrdwdsy/BneH5Cqn6EPtuWZGuB56YGgKaxoaV50Z1fQ3B3Mdl9JbSaljj9GCKvVb7tWl4Mmu9cFPgqF6VMO0w+DvkuRsf5z2X/sTd5rqGccSBW+26cXGvu33Z8gfIIik0/LGnV4MFd6L2m478CL3JKF83mBUEZiZlBkDlq4cgffih3O/tkCWluAu/8wyH2IqCRgvhEi89Uz3S5LmFWv+5dY8Sca0OzlCK1QoITXitJBffKVj4k9GoAr1bKFzPor8tuhmtQo7daJflbgvl8XzpaAleEdbQr7uuitYo4rcLYlJFNguj7/p8K2opiKZ0JfJHQ/5U4UJF4Bn6eKrVuwubY0NPyi2pR3q0LEL6ScyAWZe4m0vf0P+cPAxAokHAhFVIijyX3O4Nv0g++QUqYtn1DrZFFYtpgJwiNU9fWw4j1qcDoAZHqLEHRbl0tJoCs03BnNS7hdqM90aVUOVD7CovWnueLSY12jmB685AQZSSWD4hDX/wijqqNlZHmEtOMJ4E/rj3NtL7b2BaIw7K0btC/ZS96KHJEEwCm539697TjQ1IUh+Q1GiAFJt6lNcfbVuSRUnTi2M+xzhYbkRbL4s+V9A9cjjjrHh1zab8b0d/OTybGrQ5G4NY7xKoX58toiNaElz/ijzHExI/q3vwOtSKKMyweYmwsKCg+dA/ENs++713w19RsWCeLhwUM3WCEyCYy84Xm744RVVXkwIQHhvISKwPhm+bSA4Llz7dn3aHtOQMceAnPtFxpHvCxDeG0ih6aJ3Kaqg+XWFx6x3pWy+38jyKzvdWCEuas4Je/5O+rql1lvF9UOGsJhkl85R12AcqSxGoe4OYQtg6TTd9GlSwIwxkkL6gwLC6toOMEc3lKE8s7Qr/BvqKUtCe6CHz2pwqynZKMI6u9MafcKDFtUpGIkjJA1pO1BLKr0IPrTTk++Yic0OoiWq++7vpqvCq8U6Gj5vZ8iHA0+rl/2RQlB0twrjR/uRYZmzT5zm2IprQpzjlBMOTwxeV6hdDHNK9MbKrpS00xXnOSXH3i/tDmaGFx739Fv4giG5Aa812fiV6MJXHMoaWyqIEkUWzeL7jQ+bTAQSCu3GqEey+RNdqFxPypRYCVkoz1a5LCKeVRg80pSoI61HrXig6GXhQTYPCxn76nlC6hjAC/nyuCv4Zm1Kv2uv9RFTVJHUjaL+2AFwD4lKzNqvsjOlhbesdTnRhzO5w5A6yLn6/0WzyDzQ7KL+uH2iMPGwKF0PLP2Ftrw29eIDKEk+ZyF1LaavaOevAWQPKLDivPCVEt6C73ngvqcr67FOMzgOZO+12yekXXfNiTUERfjtByyH50gwE8vbwXELbEFlsQ9PB0NVD1hFcDFl3R1J9kxDIP7OP23wS+TDNdXX5siitiOYNE+8JTdX5T53dCPbiH7uv00k7siZEhfX8NFjvPxOAifUJg09QtwMlg2IvAHgs3qWmcEkSxwE6FosMIA4qu8K70oHT5yGpuLpFLbDF2oXRNFoqNxlwofJkEb3NlBvxm3cWkjzcLQJgUsTcS4lMdxbTY1etWIEIeyPFRyF8LaujXgRl52gyQ0b1NyyFeaN0ok3MTTCcq68FwNPQM15pFC5T9TabTYlJufgG9rThkxNkDVRkYKzl3F/jbgnDmur6+xAzr2bFzO/CdpeJ2EJoj6ObHnUhsTCcR9FSiTMAYIRraSIgHVqitB4vGCx61dTOwtJRnPDrKSjvR/m6UU+z+s/iGDiTxH3znj+oLk1S7q54VGOz9oCdeF1clfYyZk8Ytw+9qM651yXvl97t8FELvay6O09hRErLymoqz6Ak6ZY2l9oZRo/4CnS1JrEGsUBPudZVTRGDIdiTaHqEA20QbRFm0iLbz239xbWQWFVO4xVajGxwKQjUrBmFFiHir8qiG8j3hyS9vvTWd5HlG6UGKBdozgLQqfDZ6zr8h5kgkYYSVcKfYFrzF95fq02sb+nMUqitW5ii+WirtmcUeyTU1ieYFjuiu8oqu1x2YCWJg9e8kozhvie08VrSAC9q6m4xqkz22d24RfEtdOKZLkDHwo+4MVFcH7KCvW64E6+ZG1yfBlogUbQWWtnUw45cLQrisxUC1/igum1c85gamNX2yNr5LhGoOP5XzGSUHjpV5TTMyeXlvQ0PtnVr/B9a+M9UYzOECztu3qXVkcKGi98GpsYe2k9Q25KePccrlzSqe9861ociDLyrdspzgK9caqoQ7qyTwcc1PvFiOHACA2XmlvGePuFWFRfxlFAq0ITGlRZcuaUSpyTXIjfJrDgwa]]></content>
      <categories>
        <category>未完工</category>
      </categories>
      <tags>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【模拟】1210-A]]></title>
    <url>%2F2017%2F12%2F14%2F%E3%80%90%E6%A8%A1%E6%8B%9F%E3%80%911210-A%2F</url>
    <content type="text"><![CDATA[题意 传送门：A题 两个人打跑得快，现在规定扑克牌点数为区间[1,2n][1, 2n][1,2n]之间的整数，每种牌只有一张。 且打牌要符合以下特殊规定: 首先1出，在没有特殊情况时，12轮流出 如果桌面上没牌，则必须出手上最小的 如果桌面上有牌，则必须出手上比桌面上牌大的最小的牌，也就是lower_bound 如果在第三条的情况下且没有牌出，则停一手，桌面清空 一方打完后游戏结束 规定每个人的分数是对方剩余牌的数量，求最后的得分。 代码 12]]></content>
      <categories>
        <category>模拟</category>
      </categories>
      <tags>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP-LIS】洛谷P1704 - 寻找最优美做题曲线]]></title>
    <url>%2F2017%2F12%2F09%2F%E3%80%90DP-LIS%E3%80%91%E6%B4%9B%E8%B0%B7P1704-%E5%AF%BB%E6%89%BE%E6%9C%80%E4%BC%98%E7%BE%8E%E5%81%9A%E9%A2%98%E6%9B%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1704 现在给出每一天刷题的题数，并且有几天必须刷题，问最多可以刷多少天的题并且满足严格递增。 说白了就是，给一个序列，告诉你有一些下标上的数必须包含在LIS中，求满足条件的LIS，就是被禁锢的LIS。 解法 变量定义 12345int p[500005], t[500005]; // p代表必须刷题的时间, t代表每天刷题的题数int lis[500005]; // LIS数组int c[500005]; //处理过的刷题题数int n, m, x; // n天, m天必须刷题int ans; // 答案 读入 贴代码不解释： 12345678scanf("%d%d", &amp;n, &amp;m);for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", p+i);&#125;sort(p+1, p+m+1);for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", t+i);&#125; 处理 首先，如果必须刷题的那几天不严格递增，咳咳。 1234567for (int i = 2; i &lt;= m; i++) &#123; if (t[p[i]] &lt;= t[p[i-1]]) &#123; puts("impossible"); return 0; &#125;&#125;proc(); 接下来是对LIS做一些处理。 首先，如果一个序列中的数比前面的数都大，比后面的数都小，那这个数一定包含在LIS中。 那么我们可以使需要刷题的每一天都满足这个要求。 如数据：12 6 10 11 8 12 10 11 16 14 17 13 14 18，我们可以进行以下骚操作： 12 6 10 11 8 12 10 11 16 14 17 13 14 18 得到6 10 11 16 17 18。 代码如下： 123456789101112131415161718192021void proc() &#123; // int new_n = 0; c[0] = t[0] // t中的内容处理后被存入c中 int nx = 0; *c = *t; for (int i = 1; i &lt;= m; i++) &#123; if (i &gt; 1) c[++nx] = t[p[i-1]]; for (int j = p[i-1]+1; j &lt; p[i]; j++) &#123; // 两个必须刷题的日子的中间 if (t[p[i-1]] &lt; t[j] &amp;&amp; t[j] &lt; t[p[i]]) &#123; c[++nx] = t[j]; &#125; &#125; &#125; c[++nx] = t[p[m]]; for (int i = p[m]+1; i &lt;= n; i++) &#123; // 最后一个必须刷题的日子之后 if (t[p[m]] &lt; t[i]) &#123; c[++nx] = t[i]; &#125; &#125; c[++nx] = t[p[m]]; n = nx;&#125; LIS O(nlogn)O(n \log n)O(nlogn)的LIS算法参见这里，代码如下： 123456for (int i = 1; i &lt;= n; i++) &#123; int pos = lower_bound(lis+1, lis+ans+1, c[i]) - lis; lis[pos] = c[i]; ans = max(ans, pos);&#125;printf("%d", ans); 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int p[500005], t[500005];int lis[500005];int c[500005];int n, m, x; int ans;void proc() &#123; int nx = 0; *c = *t; for (int i = 1; i &lt;= m; i++) &#123; if (i &gt; 1) c[++nx] = t[p[i-1]]; for (int j = p[i-1]+1; j &lt; p[i]; j++) &#123; if (t[p[i-1]] &lt; t[j] &amp;&amp; t[j] &lt; t[p[i]]) &#123; c[++nx] = t[j]; &#125; &#125; &#125; c[++nx] = t[p[m]]; for (int i = p[m]+1; i &lt;= n; i++) &#123; if (t[p[m]] &lt; t[i]) &#123; c[++nx] = t[i]; &#125; &#125; c[++nx] = t[p[m]]; n = nx;&#125; int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", p+i); &#125; sort(p+1, p+m+1); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", t+i); &#125; for (int i = 2; i &lt;= m; i++) &#123; if (t[p[i]] &lt;= t[p[i-1]]) &#123; puts("impossible"); return 0; &#125; &#125; proc(); for (int i = 1; i &lt;= n; i++) &#123; int pos = lower_bound(lis+1, lis+ans+1, c[i]) - lis; lis[pos] = c[i]; ans = max(ans, pos); &#125; printf("%d", ans);&#125; 拓展 对于限制或改版LIS问题，可以做一定的处理，使其变为正常LIS，然后再使用裸LIS算法解决。或者设计针对题目的算法。 这里列出一些相关的题目： LICS 最长上升公共子序列 二元组LIS 最长震荡子序列]]></content>
      <categories>
        <category>DP</category>
        <category>LIS</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【底层】【Internal】深拷贝之殇]]></title>
    <url>%2F2017%2F12%2F08%2F%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91%E3%80%90Internal%E3%80%91%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B9%8B%E6%AE%87%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【底层】【Internal】一个UB引发的血案]]></title>
    <url>%2F2017%2F12%2F08%2F%E3%80%90%E5%BA%95%E5%B1%82%E3%80%91%E3%80%90Internal%E3%80%91%E4%B8%80%E4%B8%AAUB%E5%BC%95%E5%8F%91%E7%9A%84%E8%A1%80%E6%A1%88%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>底层</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【BFS】八数码问题]]></title>
    <url>%2F2017%2F11%2F24%2F%E3%80%90BFS%E3%80%91%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题意 这么经典的题目还要题意… 传送门：洛谷 P1379(让我想到了1379号监听员😆) 思路 不会写康托展开，遂用数字存储，然后使用bitset存储visited数组。 输入后对输入的局面BFS。 交换整数中的数字 首先，数字中的下标对应以下表格： 0 1 2 3 4 5 6 7 8 那么， 上下交换就是xxx和x+3x+3x+3交换(x&lt;5)(x&lt;5)(x&lt;5)， 左右交换就是xxx和x+1x+1x+1交换(x&lt;7)(x&lt;7)(x&lt;7)。 但有个问题，如果2和3交换或者5和6交换那就不行了。 所以有一个神奇的方法：判断两数相乘是否为6或30😆。 123456789，若要将3和7交换， 首先记忆3，接下来减7×1027 \times 10^27×10​2​​，然后加3×1023 \times 10^23×10​2​​， 再减3×1063 \times 10^63×10​6​​，最后加7×1067 \times 10^67×10​6​​。 输出路径？ 集训的题目要输出路径，那就加个map存前驱，然后递归打出来。 Talk is cheap! Give me the code! 代码在这里： 可以AC洛谷P1379 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define t(x) ((((x)&lt;&lt;2)+(x))&lt;&lt;1)#define l(x, i) ((x)/p10[i]%10)#define w(x, i) (*(x+i))using namespace std;// 预处理10^nconst int p10[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000&#125;;const int dir[4] = &#123;3, -3, 1, -1&#125;; // 方向矢量map&lt;int, int&gt; dep; // 深度queue&lt;int&gt; bfs; // 广搜队列int n; // 数字int main() &#123;// #ifndef __TIGER0132__// freopen("9gong.in", "r", stdin);// freopen("9gong.out", "w", stdout);// #endif scanf("%d", &amp;n); bfs.push(n); dep[n] = 0; // 初始深度 while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); int cdep = dep[pos] + 1; // 现在搜到的数字的深度 int _0; // 数字中0的位置// printf("%d\n", pos); if (pos == 123804765) &#123; printf("%d", dep[pos]); return 0; &#125; for (_0 = 0; _0 &lt; 9; _0++) &#123; // 搜索0的位置 if (!l(pos, _0)) break; &#125; for (int i = 0; i &lt; 4; i++) &#123; int p0 = _0; // 第一个要交换的数的下标 int p1 = _0+w(dir, i); // 第二个要交换的数的下标 int p2 = pos, p3; // p2是pos的拷贝, p3临时变量 // 判断交换是否合法 if (p0 &lt; 0 || p1 &lt; 0 || p0 &gt; 8 || p1 &gt; 8 || p0*p1 == 6 || p0*p1 == 30) continue; p3 = l(p2, p0); // t = a; p2 += (l(p2,p1) - l(p2,p0))*p10[p0]; // a = b; p2 += (p3 - l(p2,p0))*p10[p1]; // b = t; if (dep.count(p2)) continue; // 判断是否搜过 bfs.push(p2); // 入队 dep[p2] = cdep; // 更新深度 &#125; &#125; puts("Oh no! Where's my solution?");&#125; 教训 ⚠️不要无脑register，不然TLE自己负责！]]></content>
      <categories>
        <category>BFS</category>
      </categories>
      <tags>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【线段树】线段树]]></title>
    <url>%2F2017%2F10%2F29%2F%E3%80%90%E7%BA%BF%E6%AE%B5%E6%A0%91%E3%80%91%E7%BA%BF%E6%AE%B5%E6%A0%91%2F</url>
    <content type="text"><![CDATA[简介 线段树是一种存储区间的二叉树，用于快速解决满足区间加法的区间问题。 普通线段树 结构 左孩子和右孩子平分父节点的区间，代码如下： 123456struct node &#123; int sum, l, r; // sum可替换成max, min等等 // lchild = 2i, rchild = 2i + 1&#125; segTree[n &gt;&gt; 1]; 建树 自顶向下搜到叶子，再逐级更新到根。就像这样： 1234567891011121314void build(int id, int l, int r) &#123; // id代表现在访问到的节点编号, l, r代表查找区间 // 调用时则build(1, 1, n) tree[id].l = l; tree[id].r = r; if (l == r) &#123; tree[id].sum = arr[l]; &#125; else &#123; int mid = (l + r) &gt;&gt; 1; build((id &lt;&lt; 1), l, mid); build((id &lt;&lt; 1) | 1, mid + 1, r); tree[id].sum = tree[id &lt;&lt; 1].sum + tree[(id &lt;&lt; 1) | 1].sum; &#125;&#125; 单点修改 从根节点自顶向下查询，查到叶子节点更新然后返回并更新所有遇到的节点。Like this： 12345678910111213void modify(int id, int target, int value) &#123; // id代表现在访问到的节点编号, target代表目标的下标, value代表新值 int mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (tree[id].l == tree[id].r) &#123; tree[id].sum = arr[tree[id].l] = f(arr[tree[id].l]); return; &#125; else if (target &gt; mid) &#123; modify((id &lt;&lt; 1) | 1, target, f); &#125; else &#123; modify((id &lt;&lt; 1), target, f); &#125; tree[id].sum = tree[id &lt;&lt; 1].sum + tree[(id &lt;&lt; 1) | 1].sum;&#125; 单点查询 从根节点自顶向下，查到叶子节点返回。 区间修改 施工中，未完待续… 区间查询 12345678910111213int sum(int id, int l, int r) &#123; if (tree[id].l &gt;= l &amp;&amp; tree[id].r &lt;= r) &#123; return tree[id].sum; &#125; int sum = 0, mid = (tree[id].l + tree[id].r) &gt;&gt; 1; if (l &lt;= mid) &#123; sum += this -&gt; sum((id &lt;&lt; 1), l, min(mid, r)); &#125; if (r &gt; mid) &#123; sum += this -&gt; sum((id &lt;&lt; 1) | 1, max(mid + 1, l), r); &#125; return sum;&#125; 空间复杂度 空间复杂度为O(4n)=O(n)O(4n) = O(n)O(4n)=O(n) 时间复杂度 建树O(n)O(n)O(n) 单点修改O(logn)O(\log n)O(logn) 单点查询O(logn)O(log n)O(logn) 区间修改O(berO(berO(ber) 区间查询O(n)O(n)O(n) zkw线段树 ⚠️⚠️！！Attention！！(i&lt;&lt;1)|1不要写成i&lt;&lt;1|1！！！ 结构 堆式存储，lchild=2i,rchild=2i+1lchild = 2i, rchild = 2i+1lchild=2i,rchild=2i+1： 12345// 在这里, M必须是2^n// segTree用来存最大值最小值之内的东西// 如果有需要可以开个node或者多用几个数组int segTree[M &gt;&gt; 1];// 没了? 没了. 特性：因为叶子节点是原数组所以直接下标加M就可以找到原数组。 建树 施工中，未完待续… 12345678void build(int n) &#123; for (i = M; i &lt; M + n; i++) &#123; scanf("%d", segTree + i); &#125; for (i = M - 1; i; i--) &#123; segTree[i] = min(segTree[i &lt;&lt; 1], segTree[(i &lt;&lt; 1) | 1]); &#125;&#125; 单点修改 施工中，未完待续… 区间修改 施工中，未完待续… 区间查询 施工中，未完待续… 空间复杂度 施工中，未完待续… 时间复杂度 施工中，未完待续… 建树O(n)O(n)O(n) 单点修改O(1)O(1)O(1) 区间查询O(logn)O(log n)O(logn)]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP】【Internal】二元组dp]]></title>
    <url>%2F2017%2F10%2F15%2F%E3%80%90DP%E3%80%91%E3%80%90Internal%E3%80%91%E4%BA%8C%E5%85%83%E7%BB%84dp%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见错误]]></title>
    <url>%2F2017%2F10%2F12%2F%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[本文收集常见以及不常见的各种错误！ 错误 技术问题 溢出 运算溢出(爆int/long long) 中间结果溢出(如组合数) 循环结束条件溢出(少见，会导致TLE) 其它原因导致溢出(如越界) 错误答案 参见&quot;溢出&quot; 超时 参见&quot;溢出&quot; 循环结束条件有误 崩溃 数组开大(开小) 递归(dfs)结束条件有误 scanf没写取值符 优先级 线段树(i&lt;&lt;1)|1写成i&lt;&lt;1|1 底层问题 内存和UB 深浅拷贝 非技术问题 没写文件 编译错误 没建子文件夹 随时更新…]]></content>
      <categories>
        <category>常见错误</category>
      </categories>
      <tags>
        <tag>常见错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】RP导论]]></title>
    <url>%2F2017%2F10%2F11%2F%E3%80%90%E8%BD%AC%E3%80%91RP%E5%AF%BC%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[1 序——为什么要写RP导论 RP，是人品的缩写，在民间广为流传，被不少人视作真理，也有很多人将之视作迷信。 真的很早就了解到RP在信息学竞赛中举足轻重的作用了，加上前两天由于爆RP考试爆零，星际被虐，交OJ莫名其妙unac……一切的一起，让我不得不把RP的理论系统篆写于书，以供参考，防止大家重蹈我的覆辙。 众所周知，在信息学竞赛中，除去算法数据结构使用，程序编写调试能力之外，排在第三的对比赛有至关重要作用的便是RP了，RP高的人即使不知道算法也能用随机，贪心，搜索等RP算法得到无比多的RP分数；相反，没RP的人，有时知道正确算法也写出了正确程序，也往往会因为缺少 RP而无法得分。这样看来，系统研究RP的积累于损失，以及量化地分析它对比赛的结果的影响就显得十分重要了。 但是，目前国内外系统研究RP的论文和书籍都还很缺乏，也有很多优秀的OIer认识到了RP的重要性，但又因种种原因没能从事RP方面的研究，导致很多OIer因为对RP不了解而出现发挥失常，与奖牌失之交臂，为了让这种悲剧不再发生，我们有必要仔细研究RP了。 注 《RP导论》原始版本由洪骥发布，后由西南OI剑派CDQZ分部弟子联合编辑至今，欢迎天下同道前来编辑。 RP的定义与形成 RP的概念与意义 RP是大家耳熟能详的一个词汇和概念，改革开放以来，随着市场经济的深入，竞争日益激烈，大家都在寻找在各自领域取胜的有效方法，人们考虑各种因素来提高自己成功的概率。 江湖难测，谁是强者，谁争一统武林的资格！ 在这样的大背景下，便自然而然地产生了RP的概念，起初这个概念还是依附在其他因素上的一个附属品，但是当人们真正认识到它的影响时，才发现它是一个独立的体系。由于各地各文献内容对RP的定义都很模糊，也不够统一，因此笔者在此以学术的角度，客观的方式给出RP的严格定义： Definition 1 RP：在一定时间和空间范围内独立于可见因素之外以不确定方式左右客观事物变化方式甚至规律的无形物质。 一直以来，大家觉得RP过于飘渺，不愿意研究它，这其实是由于没有真正意识到RP在客观世界物质变化规律中的重要意义，由于客观世界矛盾的普遍性存在，导致RP因素在事物发展变化的各个角落都发挥着不可忽略的决策性作用，一般来说，RP的意义主要有以下几点： 对客观世界的平衡作用 物质世界总是趋于平衡的，无论是能量|物质守衡定律，还是热力学第一，第二定律，都从侧面支持这一结论。但是在事物的各个方面个体之间不可能完全平衡，而又不一定能在不多的可见主观因素中使个体之间实现平衡（这正如背包—–双塔问题不一定有解一样），但是只要有了RP，就能很方便地对客观世界进行微调，使世界不失和谐。 对主观行为的威慑作用 所谓善有善报，恶有恶报，但是很难说服一个即将做不厚道事情的人让他停止，因为我们不能具体说出他的不厚道行为到底为什么会对他自己也有害，但是现在有了最强有力的威慑武器：RP！当他做不厚道事情的时候，最需要考虑的不是别的，正是自己的RP银行。 对主观行为的激励作用 与第二条相类似，RP的存在可以很大程度上激励人做积累RP的厚道事情，这里不再赘述。 RP的形成 总的来说，RP的形成是多方面因素综合形象后的结果。对于RP形成的决定性因素，学术界一直没有公认的理论，目前比较被人接受的说法是： RP的形成与平时做事的厚道程度的二次方根成正比，但是也有人质疑这种说法，原因是有时一个很厚道的人也会莫名其妙没RP，典型的案例是发生在中国四川一个学校的一个叫hj的人，平时很厚道，但是也遇到了没RP的情况，虽然这很罕见，但是不得不让人思考，因此，有学者认为：在一定时间和客观条件下，RP值与该人做事厚道程度之和的正弦函数有关，因此呈现出很让人费解的波动性图象，但是这种理论因为缺乏实验支持，目前还没有在学术界占领主导地位，但是笔者认为，这种理论应该更贴近RP形成机理的真实情况。（最新研究表明，波动正是RP趋于平衡的必然结果，由于一个人的RP太高的情况下，失去RP相对容易，所以会从波峰逐渐跌入波谷，反之亦然）(补充:因为RP和现实中由于概率问题而得到 (或损失)的利益相关，从而导致RP会趋于平衡，例如:《塞翁失马》，其中的“塞翁”就是因为利益和RP之间相关连，导致出现一福一祸的现象，简单说就是碰到好事情RP会下降，碰坏事情RP会上升) 另外，RP的形成是有阶段性的，也就是说，有时候RP的变化并不是立竿见影的，但是RP升降因素的积累是不会停止的，在某个时期可能表现地不明显，但是宏观上的RP积累是一定的，这也就形成了RP的波动性改变，所以大家在某个RP低迷的时期也不应该停止对RP的积累。（就像力改变的 3 RP的影响与利弊 是加速度，而不会对当前的速度有立竿见影的影响，不过长期的影响是深远而持久的） 另外客观世界满足一个基本定律——RP守衡定律，即RP不会凭空创生，也不会凭空湮灭，只会从一个生物转移到另一个生物，或者由RP转换为现实中通过不确定因素获得的利益，RP转移包含以下几种方式： 虐与被虐。 泡MM与MM被泡。 捡到钱(但是没有还)和丢钱(但是没找回来) 这几条都很好理解，比如，某人玩星际被别人虐了，或者不小心把钱丢了，那么他的RP会有上升的倾向，另外，抢别人MM的人的RP会异常迅速地下降，或者捡到别人的钱不还也会导致RP下降，所以大家一定要厚道。 RP的影响与利弊 RP的不利影响 对于RP不足带来的不利影响，想必读者已经有了不少体会了，为了系统介绍，这里将不利影响列举一些例子如下： 考试爆0（考挂，发挥失常等） 泡MM失败（被无视，被抢夺等） 自行车胎被扎（汽车，电瓶车） 物品频繁损坏（如T43等） 星际被虐（连续被虐很多局根据叠加原则将会出现更深远的影响） 误机（堵车，迷路等） 以上每一条虽然是RP不足带来的不利影响，但是客观上又可以积累 RP，这也正体现了客观世界与RP的辨证关系。 从宏观上讲，上述事情也许并非全是坏事，像（3），（4）两条在扩大内需，刺激经济增长方面也是有积极作用的，但是本文讨论的主观色彩较重，对一些过于YY的东西不做讨论。 关于RP带来的麻烦的解决方法，学术界一直争论不休，企图认为改变 RP变化趋势的想法，已经被实践证明是NPC，想预测RP的发展方向，也被论证是不可解问题。 3 RP的影响与利弊 那么，面对RP带来的不利影响，我们真的就束手无策了吗？非也！我们有解决NP类问题的有力武器：星际！！！！ 在RP不好的时候，开High—AI调两家神族，遭电脑虐几盘，RP指数相信会有很大概率要++的，虽然这仍然是个部分算法，但是事实证明是很有效的，已经不亚于cqf的（sei）机贪心了……(补充:根据RP守恒定律中“只会从一个人身上转移到另一个人身上”，此方法可能没有效果)。 此外，另有极端人士为了平衡自己的RP，在关键时刻向别人赠送人民币，虽然被证明实际效果甚微，但是由于接受方会损失大量RP，所以这种行为也被认为是极度危险和边缘的。对于此损人不利己的行为，将会在以后对自己的RP走向产生不利影响。从自己和别人那里流失出来的RP，就会流入社会，等待下一次再分配（根据标量场理论，RP高者将在再分配中较低RP者得到更多的RP)。 古时另有各种迷信活动来祈求获得RP，经证明一些行为是十分有效的，但是尚没有任何科学理论可以他们的成功，其中最著名的历史事件为诸葛亮借东风，这是以神秘的法事活动来获得RP成功的典型例子，不但说明了我国的RP研究在很早的时候就有开展，并且代表了当时的RP学说已经发展到相当先进的阶段，后来由于战乱和历史原因，RP学逐渐没落和淡出国人的视野，在近代才又被重新提出和加以研究，但想恢复当年的水平还任重而道远。 RP的有利影响 对于希望利用RP以追求更高品质生活的读者来说，RP的有利影响也是应该了解的重要问题之一。关于RP的有利影响，对于大部分本人读者来说，不外乎下面两个方面： 考试获得理想的分数 泡MM获得阶段性成果 总结起来便是工作方面和生活方面，从中可以看出，RP对于生产生活的各个方面如果合理加以利用都可以达到相当大的有利效果。所以，“天下之大，人品独尊”，若存在一种方式，可以让一个人长期保有相当量的 RP，那么此人便可以独步天下，无人能当，足以可见RP的威力。（也有学者认为本情况是不可能成为现实的，不过并没有合理的证明）不过关于高 RP独步天下的例子，笔者实在难以获得，这也从侧面反映了RP易失难获的性质，从而说明了大自然趋于平衡的典型特征。 小结RP的利弊 （未完待续） 4 RP的估测与评价 RP的估测与评价 我们生活的环境是存在着RP场(本人认为，不同时间束分支所含主观RP 不同，所以穿越会获得大量RP)，就象我们生活在磁场中一样。每个人都存在着一定的RP势能，记作Erp。它所遵循的定律见“RP的变化与操纵”。RP 的本质是一种人为设想的能量形式，用来描述一个人的LUCKY值。 RP的单位系统 （未完待续） RP的估测方法 Erp的变化量大小ΔErp = |w−Pf|+1（w表示期待事件发生的次数，如果不想它发生一次那么w=−1，f是事件的频率，P是事件的概率） 此公式可用来计算瞬间转移的RP值，例如：一个人中了500W，中奖的概率是1/1000000，想这一次中奖，那么，ΔErp = 1000000，也就是说，他瞬间损失了这么多RP势能。如果你不去想，即w = 0，那么将会损失更多RP（可以这么理解，你无所谓的事情都发生了，那你肯定要多损失点 RP啦）。再例如：帮老奶奶过街，因为碰到这样的情况概率不大（也就是说机会难得啊，如果是一般的让座估计就没这么多RP赚了），所以得到 的Erp也就大咯。 一个人的RP势能很低，并不代表RP能量就会向他流动，因为这些能量还受到周边人、物的RP引力制约。只能说，RP低的人在同等条件下更容易接受RP能量，从而升高RP势能；RP势能高容易失去RP（多数以无用的形式流向大自然，因为这是必然事件，那么），为了维持较高的RP势，我们就要不断的补充。但是RP势能高，并不代表就会有你说期待的好事发生，有可能这些RP以其他你所不期待的形式释放了，我们称作为RP亏损，这就取决于你的RP利用率了。所以，我们在汲取RP的同时，还要锻炼我们的RP利用率。 这里要说一个自然损失，因为这是必然事件，所以P =1，那么RP的损失量就直接和你的w值有关了，也就是，如果你正确认识了这种必然性，你的RP只会损失1，如果你非常不想让它损失那么你将损失更多的RP能量，所以，调整心态是很重要的啊～！ RP的变化与操控 RP的几大定律 RP第一定律 Law 1 RP是守恒的，它既不会凭空产生，也不会凭空消失 即人品守恒定律，在任何过程中，宇宙中人品总量保持为常数。（也就是说，做好事增加人品做坏事损人品，遇到好事是以前积攒的人品起了作用，而要使你连自己系开的必修课都没选上，那你真的要多扶扶老奶奶过马路了） 宇宙创生之初，与各大基本粒子同时由爆炸基点生成的一大暗物质种类就是RP。经过笔者的多年探究和无数实验，配合与史蒂芬·霍金的理论研究合作，已经基本从理论高度证明了RP第一定律，也称为“RP守恒定律”。 这一定理的理解往往不像物理学中的“热力学第一定律”那样好理解，因为在实际生产生活实践中，往往会发现某人的RP大量减少，但是并没有发现某人的RP有明显的提升，所以也导致在很长一段时间内大量研究人员质疑RP守恒定律的正确性。进一步研究发现，RP的存在和守恒是确定的只是由于绝大多数RP往往存在于生物体之外而以“自由RP”的形式游离于宇宙空间，所以，以上那种情况仅仅表明某人的RP由于自身原因散佚于宇宙空间，却没有人从空间中汲取RP，从而导致有效RP减少，也就是发挥作用的RP减少了，但并没有影响RP本身的守恒。 (补充：按照该说法，可以得知，当一个人出生时，其RP是从他所在的空间周围的“自由RP”中汲取的，而从母体中获得的RP较少，但是如果周围的“自由RP”极度缺乏，那么只有可能从母体中获取，于是就出现了难产的情况) RP第二定律 Law 2 RP不可能从低RP物体传向高RP物体而不引起其他变化 但由于RP的不确定性，RP可以从RP的数学期望低的物体传向高RP数学期望物体，这与第二定律不矛盾。 (例如:通过RP到现实利益的转化再由现实利益转化为RP的过程) 从该定律可以推导出： Inference 1 (人品转移定律) 人品是可以相互转移的，但这种转移必须通过必要的手段，譬如烧香，祈祷，诅咒等，以及相应的媒介，譬如遭遇高僧或者超级霉人。 RP第三定律 Law 3 当一个人的RP无限减小时其生命力趋近于零，亦即任何一个活体生物的RP均不为零。 （或：对大量的事实的分析表明，绝对不可能没有RP。）此定律还有如下表述： 不能用有限的步骤使一个人的人品完全消耗。（也就是说，你再怎么霉，也还是会有点人品存量的，所以永远不要灰心丧气。）请大家看一个范例：「塞翁的马丢了，他说“没事，攒人品”，当他丢失的马带回来一群马，别人羡慕不已，他则暗叹“不妙，人品消耗的太多”，果然他的儿子因为骑马而摔断了腿后，他摇摇头说 “继续攒人品”，等到战争时别人家的孩子被征兵战死沙场，只有他的儿子因为腿断了而幸免，这时他激动地说“人品爆发了啊”……」 RP第四定律 Law 4 如果两个人中每一个人的RP值均与第三个人相同，那么她或他或它们彼此也必有RP值相等[脚注]。 RP惯性定律 Law 5 RP存在惯性，即提升或消耗RP的事件有连续发生的趋势。 RP惯性学也自古就有。“祸不单行”和“双喜临门”就是典型代表。不过它却一直以来饱受批判，“福无双至”直接把这个理论推到了悬崖边上。但如今随着人类交流的日渐增多，惯性RP粒子经常被报道：诸如某X撞狗屎运中了500w之后又在股市大有斩获；或者某大衰刚碰上车祸马上被女友甩掉。人们不得不正视RP存在惯性这一事实。 RP统计定律 Law 6 对于个体事件，人品是极不确定的，或不可量度的；然而对于大量的事件而言，人品会体现一定的统计规律。 而现在的人品学家们在人品学理论的微观研究上已取得了革命性突破，在量子力学、大一统论、超弦理论大旗号召下的今天，让我们一起走进量子人品学（Quantum Characterics）的新纪元！ 基数人品论 导论：人品作为一般等价物，为满足日常需要，需投入一定的人品，以投入人品与获得的效用的数据构建图像，可以得到基数人品论(cardinal characterics)的边际人品-效用图。后来，有学者提出人品不可测量，只可比较，由此发展了序数人品论(ordinal characterics)，目前比较成熟完善的是基数人品论。 基数人品论的一些观点： 为提高享受，需不断追加人品消耗，而享受的提高因随追加人品的增加而递减，享受提高为零时，投入人品就应停止，如再增加，则成为负数。即“人品效率递减定律”。表达式：dRPdU &lt;0 人品等分配定律：当面临多种消耗人品的活动时，应使得花费在所有活动的最后一单位人品边际效用相等。这样能将给定的人品转化出最 大效用。表达式： dUk = dRPdU((kk+1)+1)，k∈N。 dRPk 在原有人品消费已满足的前提下，要想用人品换取更多的好处，只有发展新人品消费项目和扩充原有人品消费项目。 规模人品 消费人品的活动，必须根据它的特点，确立一个起始人品投入规模/最小人品投入规模或称“最小有效规模”，投入低于这一规模，就会导致回报为零。超过这一规模，即进入一个“合理规模”区间，在这一区间内，追加人品投入都会得到回报。 人品爆发 一定条件下，存在以单位最小人品投入量获得最大单位的收益的点，称为“人品爆发点”。但这种事件的发生时间、场所等往往难以确定。 由人品等分配定律可得，单位最小人品投入量获得最大单位的收益的点就是起始点。“人品爆发点”与之矛盾，如何解释呢？后经科学家赵明毅 (?-2007)研究，人品爆发原因是他的故土–锑星星球有重要关系。锑星特有物质磷化卤(R?P)，理化特性由于赵明毅的离奇失踪（？）而流失。其独特的的反重力性(探佚专家自《大锑赵明毅》相关章节推出)使得部分游离态磷化卤会脱离锑星，被喷射出去，从而对人品分布产生干扰，导致部分时间与场人品运行机理扭曲。由于历史原因，人品爆发常被归结于行善，现在这个概念已由国际人品研究协会(International Characteric Research Association，GCRA[脚注])规范化，形成了目前的通用表述与解释。 RP的变化因素 总的来说，RP的变化因素不可控因素比可控因素占的因素还多，发生在身边的任何事都可能改变你的RP，正是因为这样，RP才经常变化于无形中，但是这不是我们放弃研究RP的理由，要在复杂的情况中提炼出简单的规律，化繁为简。笔者经过多年实践观察总结，列出了如下表格描述各种因素与RP的变化关系： 事件 对RP影响（单位：fs） 考试爆0 +6 星际，羽毛球等被虐 +5 扶老奶奶过街 +3 星际，羽毛球等虐人 -10 八卦zmy -20 在jf不幸滴看见某人 -100 （注：单位“fs”的定义为：vijos上AC一道题所需要的RP的量） 由上述表格可以看出，积累RP是不容易的，但是积累的RP却很容易在不经意之间丢失，（所谓“大自然厌恶高RP”，也就是说，RP越高的人，丢失RP也就会显得越容易）。这就是为什么很多人抱怨自己的RP从来就没好过，那是因为他们好不容易有点RP了，却由于自己不小心又做的损RP的事情而把宝贵的RP丢失了。（RP易转化为现实利益，且RP易挥发） 人为调节RP的技巧与方法 说实话，对这一节的内容笔者没有十分的把握，因为笔者本人对这部分内容一直都很困惑，我希望能通过一些认为手段调节可怜的RP，但是理论跟实践的差距往往相当大，我理论分析总结的规律在实践中有时并不能行通，就像我有时候可以地遵守交通规则，不闯红灯，听妈妈的话等等等等，原本以为这样可以积累RP，无奈考试还是要爆0，说白了就是RP对人似乎有天生的抵触情节，最经典的例子是与笔者同校的一个叫LKQ(化名)的同学在NOI之前不幸将自己的手机搞丢，本以为自己RP会增长到一定的程度，以帮助自己在NOI上获得较好的成绩，结果事与愿违，NOI还是不幸考挂，所以我们分析一个现实生活中的RP问题，一定不能拘泥于某一些事情对于 RP的影响，而应该纵览全局，客观考虑各种因素的影响，才能最后得出准确的结论，事实证明那位同学在NOI上被室友塞了满满一抽屉的硬币，硬币虽小，但对RP的影响却是巨大的，正如刚才论述的，RP失去容易获得难，虽然手机的价值远大于硬币，但是对于失去手机RP有所增长的这位仁兄来说，获得硬币所损失的RP更是一个恐怖的数字。所以要客观和全面地分析问题，才能获得准确和有效的结论。 但是我们不能因此就放弃对RP的调节，我们需要持之以恒的调节RP。因为根据SW的经验来看，追MM、谈恋爱等事情需耗费巨大的RP。例如：SW 6 RP的奇律 和其女同学一起吃完KFC出去的时候，其女同学说也许我们出去就会被汽车一起撞死，为了避免这种悲剧发生，SW不得不支付大量RP……所以各位需要不断的累积RP，来应付各种突发状况…… RP之变诈几何哉？止增笑耳。 RP的奇律 任何理论都有其局限性，当然经典RP理论也是一样，某些时候RP会从某个人身上大量的涌现（俗称:RP爆发)，而此人之前的RP值表现平常甚至很低或者显示为负。这种现象称为RP的奇律。RP爆发相当罕见，因此研究甚少，成果有待完善。 ——出自西南OI剑派CDQZ分部弟子]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>其它</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DP】1007-B]]></title>
    <url>%2F2017%2F10%2F07%2F%E3%80%90DP%E3%80%911007-B%2F</url>
    <content type="text"><![CDATA[题意 这是一个伪·三倍经验题。 传送门：1007-B Alternative Question: P1004 NOIp2000TG-4方格取数。 P1006 NOIp2008TG-3传纸条 给定一个n×mn \times mn×m矩阵，从(1,1)(1,1)(1,1)走到(n,m)(n,m)(n,m)走两次，只能向右或向下，希望除始末两点以外其他点不相交，问路径最大权值和。 解法 四维dp，dp[x][y][z][w]为当第一个人在(x,y)(x,y)(x,y)第二个人在(z,w)(z,w)(z,w)时最大权值和。可推出方程： dp[i][j][k][l]=max(dp[i−1][j][k−1][l],dp[i−1][j][k][l−1],dp[i][j−1][k−1][l],dp[i][j−1][k][l−1])dp[i][j][k][l] = \max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1], dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])dp[i][j][k][l]=max(dp[i−1][j][k−1][l],dp[i−1][j][k][l−1],dp[i][j−1][k−1][l],dp[i][j−1][k][l−1]) ​ +a[i][j]+a[k][l]×[i≠k∣∣j≠l]+a[i][j] + a[k][l] \times [i \ne k || j \ne l]+a[i][j]+a[k][l]×[i≠k∣∣j≠l] 注意当i=k,j=li = k, j = li=k,j=l时，a[i][j]=a[k][l]a[i][j]=a[k][l]a[i][j]=a[k][l]。所以必须减去一个a[k][l]a[k][l]a[k][l]。 代码 12345678910111213141516171819202122232425262728293031// 代码为 P1004方格取数#include &lt;bits/stdc++.h&gt;using namespace std;int dp[15][15][15][15];int a[15][15];int x, y, z;int n;int main() &#123; scanf("%d", &amp;n); scanf("%d%d%d", &amp;x, &amp;y, &amp;z); while (x || y || z) &#123; a[x][y] = z; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); &#125; dp[1][1][1][1] = a[1][1]; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; for (int k = 1; k &lt;= n; k++) &#123; for (int l = 1; l &lt;= n; l++) &#123; if (i == 1 &amp;&amp; j == 1 &amp;&amp; k == 1 &amp;&amp; l == 1) continue; dp[i][j][k][l] = max(max(dp[i-1][j][k-1][l], dp[i-1][j][k][l-1]), max(dp[i][j-1][k-1][l], dp[i][j-1][k][l-1])) + a[i][j] + a[k][l] * (i != k || j != l); &#125; &#125; &#125; &#125; printf("%d", dp[n][n][n][n]);&#125; 拓展 这是一个&quot;双线程DP&quot;。几个人同时走的问题可以考虑增加维度来解决。]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F1949%2F10%2F01%2F.well-known%2Facme-challange%2FSN8OvFrfM3nWr4-lhbtxyemY-9Te8VX_s1Ho5wz3XAk%2F%2F</url>
    <content type="text"><![CDATA[SN8OvFrfM3nWr4-lhbtxyemY-9Te8VX_s1Ho5wz3XAk.WLkG6GU4dDfNVnhiQ3tDj-llxertpm4na0H9pQBq62M]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F1949%2F10%2F01%2F.well-known%2Facme-challange%2F-yzfgYhMsZoBE3HHQ2mwQc7HtoJk1_AfS5t-DAcSmjI%2F%2F</url>
    <content type="text"><![CDATA[-yzfgYhMsZoBE3HHQ2mwQc7HtoJk1_AfS5t-DAcSmjI.WLkG6GU4dDfNVnhiQ3tDj-llxertpm4na0H9pQBq62M]]></content>
  </entry>
</search>
