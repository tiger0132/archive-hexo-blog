<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】DISCLAIMER]]></title>
    <url>%2F9999%2F12%2F31%2FDISCLAIMER%2F</url>
    <content type="text"><![CDATA[本帖为置顶内容，最新内容请向下翻! 本博客仅供本蒟蒻复习用，建议初学者不要看本蒟蒻的博客。 而且本蒟蒻懒癌晚期，博客写的一点都不好。 NOTICE 博客正在维护 HALL OF SHAME TODO LIST CF R468 Div.1订正 Tarjan求LCA 缩点、点/边双、桥 二维树状数组：区间修改+区间查询 TYVJ1391 走廊泼水节 BZOJ1912 巡逻 本站地址: oi.tiger0132.tk 欢迎互链。]]></content>
  </entry>
  <entry>
    <title><![CDATA[「题目汇总」网络流题目汇总]]></title>
    <url>%2F2018%2F05%2F06%2Fnetwork-flow-problems%2F</url>
    <content type="text"><![CDATA[这里是一些网络流题目的汇总。 进度：ABCDEF。 A, Coding Contest, 费用流 传送门：HDU5988，YaliOJ。 B, Flow Problem, 最大流 传送门：HDU3549，YaliOJ。 题意 求最大流。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 16384, INF = 0x3f3f3f3f;struct Edge;struct Node &#123; vector&lt;Edge *&gt; edges; int level;&#125; gph[N];struct Edge &#123; int from, to, capacity, flow; Edge *rev; Edge(int from_, int to_, int capacity_, int flow_ = 0) &#123; capacity = capacity_; from = from_; flow = flow_; to = to_; &#125; Edge() &#123; from = to = capacity = flow = 0; rev = 0; &#125;&#125;;bool levelGraph(int s, int t, int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; gph[i].level = 0; &#125; queue&lt;int&gt; bfs; bfs.push(s); gph[s].level = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = 0; i &lt; gph[pos].edges.size(); i++) &#123; const Edge&amp; e = *gph[pos].edges[i]; if (e.flow &lt; e.capacity &amp;&amp; !gph[e.to].level) &#123; gph[e.to].level = gph[pos].level + 1; if (e.to == t) return true; // 优化一 else bfs.push(e.to); &#125; &#125; &#125; return false;&#125;int findPath(int s, int t, int flow) &#123; if (s == t) return flow; int ret = 0; for (int i = 0; i &lt; gph[s].edges.size(); i++) &#123; Edge &amp;e = *gph[s].edges[i]; if (gph[s].level + 1 == gph[e.to].level &amp;&amp; e.flow &lt; e.capacity) &#123; int tmp = findPath(e.to, t, min(flow, e.capacity - e.flow)); flow -= tmp; e.flow += tmp; e.rev-&gt;flow -= tmp; ret += tmp; if (!flow) break; // 优化二 &#125; &#125; if (!ret) gph[s].level = -1; // 优化三 return ret;&#125;int dinic(int s, int t, int n) &#123; int ans = 0; while (levelGraph(s, t, n)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;int cnt = -1;void addEdge(int from, int to, int capacity) &#123; Edge *e1 = new Edge(from, to, capacity, 0); Edge *e2 = new Edge(to, from, capacity, capacity); e1-&gt;rev = e2; e2-&gt;rev = e1; gph[from].edges.push_back(e1); gph[to].edges.push_back(e2);&#125;int t, n, m, a, b, c;int main() &#123; scanf("%d", &amp;t); for (int cn = 1; cn &lt;= t; cn++) &#123; for (int i = 1; i &lt;= n; i++) &#123; gph[i].edges.clear(); &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addEdge(a, b, c); &#125; printf("Case %d: %d\n", cn, dinic(1, n, n)); &#125;&#125; C, Game, 最小割 传送门：HDU3657，YaliOJ。 D, Harry …, 最小割 传送门：HDU3987，YaliOJ。 题意 求最小割边数。 解法 定理：最大流中满流的边属于最小割边集。 于是可以求一遍最大流，把所有满流的边流量设为111，其它的边设为+∞+\infty+∞，然后再跑一遍网络流就好了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int to, next, capacity, flow;&#125; e[400005];int level[1003], head[1003], cnt = 1;bool bfs_(int s, int t) &#123; memset(level, 0, sizeof level); queue&lt;int&gt; bfs; bfs.push(s); level[s] = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = head[pos]; i; i = e[i].next) &#123; if (e[i].flow &lt; e[i].capacity &amp;&amp; !level[e[i].to]) &#123; level[e[i].to] = level[pos] + 1; bfs.push(e[i].to); &#125; &#125; &#125; return level[t];&#125;int dfs(int s, int t, int flow) &#123; if (s == t) return flow; int ret = 0; for (int i = head[s]; i; i = e[i].next) &#123; if (level[s] + 1 == level[e[i].to] &amp;&amp; e[i].flow &lt; e[i].capacity) &#123; int tmp = dfs(e[i].to, t, min(flow, e[i].capacity - e[i].flow)); ret += tmp; e[i].flow += tmp; e[i^1].flow -= tmp; flow -= tmp; &#125; &#125; if (!ret) level[s] = -1; return ret;&#125;int dinic(int s, int t) &#123; int ret = 0; while (bfs_(s, t)) &#123; ret += dfs(s, t, 0x3f3f3f3f); &#125; return ret;&#125;void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z, 0&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y], z, z&#125;; head[y] = cnt;&#125;int n, m, t, u, v, w, x, _;int main() &#123; scanf("%d", &amp;t); while (t--) &#123; memset(e, 0, sizeof e); cnt = 1; memset(head, 0, sizeof head); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;w, &amp;x); u++; v++; addedge(u, v, w); if (x) addedge(v, u, w); &#125; dinic(1, n); for (int i = 2; i &lt;= cnt; i += 2) &#123; if (e[i].flow == e[i].capacity) &#123; // 满流 e[i].capacity = 1; e[i].flow = 0; e[i^1].capacity = 1; e[i^1].flow = 1; &#125; else &#123; e[i].capacity = 0x3f3f3f3f; e[i].flow = 0; e[i^1].capacity = 0x3f3f3f3f; e[i^1].flow = 0x3f3f3f3f; &#125; &#125; printf("Case %d: %d\n", ++_, dinic(1, n)); &#125; return 0;&#125; 这个题目貌似是个什么「最小割树」，然后好像有一种只用求一次最大流就能出解的算法。 E, Destroy …, 上下界可行流(据说乱搞可过？) 传送门：HDU4940，YaliOJ。 F, Jump, 费用流 传送门：HDU4862，YaliOJ。]]></content>
      <categories>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>Y</tag>
        <tag>图论</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」网络流]]></title>
    <url>%2F2018%2F05%2F05%2Fnetwork-flow-notes%2F</url>
    <content type="text"><![CDATA[简介 网络流？好难啊。 由于有各种千奇百怪的网络流题的存在，网络流变得异常复杂啊。 UPD： 2018-02-17 21:09:35：Initial Commit 2018-03-03 22:34:54：Change最小费用最大流 to 费用流，Change代码，Add最小割 2018-03-04 13:07:48：Change代码 2018-05-05 23:31:36：Add费用流 没用的概念 网络：带权有向图，记作G=(V,E)G=(V,E)G=(V,E)。 容量：网络上的边权，边(u,v)(u,v)(u,v)的容量记作c(u,v)c(u,v)c(u,v)。 网络流：指为这个有向图分配流并且使得它每条边上的流量都不能超过这条边的容量。 流量：网络流上的边权，边(u,v)(u,v)(u,v)的流量记作f(u,v)f(u,v)f(u,v)。 可行流满足： 流量限制：0≤f(u,v)≤c(u,v),(u,v)∈E0\le f(u,v)\le c(u,v),(u,v)\in E0≤f(u,v)≤c(u,v),(u,v)∈E。 平衡条件：∑v′f(u,v′)−∑v′′f(v′′,u)={∣f∣u=Vs0u≠Vs,Vt−∣f∣u=Vt\sum_{v&#x27;}f(u,v&#x27;)-\sum_{v&#x27;&#x27;}f(v&#x27;&#x27;,u)=\left\{\begin{array}{lc}|f|&amp;u=V_s\\0&amp;u\ne V_s,V_t\\-|f|&amp;u=V_t\end{array}\right.∑v′​f(u,v′)−∑v′′​f(v′′,u)=⎩⎨⎧​∣f∣0−∣f∣​u=Vs​u≠Vs​,Vt​u=Vt​​ 其中∑v′f(u,v′)\sum_{v&#x27;}f(u,v&#x27;)∑v′​f(u,v′)是从顶点uuu流出的流量之和，∑v′′f(v′′,u)\sum_{v&#x27;&#x27;}f(v&#x27;&#x27;,u)∑v′′​f(v′′,u)是流入顶点uuu的流量之和，∣f∣|f|∣f∣是可行流的总流量，是源点的净流出量，也是汇点的净流入量。 链：前后两两有边项链的点的序列。(准确的说是弧而不是边，之后均使用弧代替边) 前向弧：和链的方向相同。前向弧集合记作P+P^+P+。 后向弧：和链的方向相反。后向弧集合记作P−P^-P−。 增广路：源点到汇点的一条链，满足前向弧非饱和弧，后向弧非零流弧。 即0≤f(u,v)&lt;c(u,v),0&lt;f(u,v)≤c(u,v)0\le f(u,v)&lt;c(u,v),0&lt;f(u,v)\le c(u,v)0≤f(u,v)&lt;c(u,v),0&lt;f(u,v)≤c(u,v)。 残留容量或剩余流量：还能通过的流量。弧的残留容量或剩余流量记作$$。 每条弧对应一个反向残余流量或反向剩余流量c′(v,u)=−f(u,v)c&#x27;(v,u)=-f(u,v)c′(v,u)=−f(u,v)。 残量网络或残余网络或剩余网络：残留容量或剩余流量组成的网络。 ⚠️ 注意：接下来残留容量和剩余容量统一为残留容量，残量网络、残余网络和剩余网络统称残量网络。 无聊的概念终于结束了，进入正题 就一个概念mmp一堆名字恶心不恶心 最大流 Ford-Fulkerson和Edmonds-Karp略。 Dinic 步骤 初始化 BFS构造层次网络和残量网络。 如果汇点不在层次网络中算法结束。 在层次网络中DFS进行增广，然后回到步骤2。 优化 BFS只要搜到终点就直接返回true。 DFS如果一条边的流量流满了，就不需要再对这条边DFS了，直接返回答案。 DFS如果一个点增广不出流量，那么这次DFS就不要再搜这个点了，再层次图中标记为000。 代码 2018-03-03 22:34:54 Update： 因为STL的指针失效问题，代码被改了。(难怪我不能过BZOJ1711) 只能AC洛谷的模板题可能和洛谷的数据生成器CYaRon有关，说不定生成算法或者输出没有打乱然后不加反向弧/加错反向弧也可以AC？interesting 代码为了兼容long long或高精，typedef了Flow_Type，自行更改以适应long long或其它数据。 2018-03-04 13:07:48 Update： 由于原来的代码空间复杂度常数高，于是压了压空间。 该代码用于AcceptedYali 网络流B - Flow Problem或原题HDU3549 - Flow Problem。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Flow_Type;const Flow_Type INF = 0x3f3f3f3f;const int N = 31, M = 1003;struct Edge;int level[N];int head[N];struct Edge &#123; Flow_Type capacity, flow; int to, next;&#125; e[M &lt;&lt; 1];bool levelGraph(int s, int t) &#123; memset(level, 0, sizeof level); queue&lt;int&gt; bfs; bfs.push(s); level[s] = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = head[pos]; i; i = e[i].next) &#123; if (e[i].flow &lt; e[i].capacity &amp;&amp; !level[e[i].to]) &#123; level[e[i].to] = level[pos] + 1; if (e[i].to == t) return true; // 优化一 else bfs.push(e[i].to); &#125; &#125; &#125; return false;&#125;Flow_Type findPath(int s, int t, Flow_Type flow) &#123; if (s == t) &#123; return flow; &#125; Flow_Type ret = 0; for (int i = head[s]; ret &lt; flow &amp;&amp; i; i = e[i].next) &#123; if (level[s] + 1 == level[e[i].to] &amp;&amp; e[i].flow &lt; e[i].capacity) &#123; Flow_Type tmp = findPath(e[i].to, t, min(e[i].capacity - e[i].flow, flow)); ret += tmp; flow -= tmp; e[i].flow += tmp; e[i ^ 1].flow -= tmp; // if (!flow) break; // 优化二 &#125; &#125; if (!ret) level[s] = -1; // 优化三 return ret;&#125;Flow_Type dinic(int s, int t) &#123; Flow_Type ans = 0; while (levelGraph(s, t)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;int cnt = 1;void addUndirectedEdge(int from, int to, int capacity) &#123; // printf("(%d, %d, %d)\n", from, to, capacity); e[++cnt].to = to; e[cnt].next = head[from]; e[cnt].capacity = capacity; head[from] = cnt; e[++cnt].to = from; e[cnt].next = head[to]; e[cnt].capacity = capacity; head[to] = cnt;&#125;void addDirectedEdge(int from, int to, int capacity) &#123; // printf("(%d, %d, %d)\n", from, to, capacity); e[++cnt].to = to; e[cnt].next = head[from]; e[cnt].capacity = capacity; head[from] = cnt; e[++cnt].to = from; e[cnt].next = head[to]; e[cnt].capacity = capacity; e[cnt].flow = capacity; head[to] = cnt;&#125;int t, n, m, a, b, c;int main() &#123; scanf("%d", &amp;t); for (int cn = 1; cn &lt;= t; cn++) &#123; cnt = 1; memset(e, 0, sizeof e); memset(head, 0, sizeof head); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addDirectedEdge(a, b, c); &#125; printf("Case %d: %d\n", cn, dinic(1, n)); &#125;&#125; 最小割 根据最大流最小割定理，得出最大流===最小割。 内容：最大流就是最小割。 定理证明略 费用流 Edmonds-Karp 求最大流的Edmonds-Karp算法的流程是首先bfs找出任意一条增广路，然后增广，直到无法增广。费用流中的Edmonds-Karp算法则是用spfa(别的也行)找出费用最少的一条 步骤 用SPFA求出费用最少的一条增广路(同时记录路径以便增广)。 对该路径进行增广，流量 += 终点流量, 费用 += 终点流量 * 源点到汇点的距离(费用)。 如果还能增广，就回到步骤1。 代码 该代码用于AcceptedP3381 - 【模板】最小费用最大流。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int from, to, next, capacity, flow, cost;&#125; e[100005];int head[5003], cnt = 1;int prev[5003];int flow[5003];void ek(int s, int t, int&amp; rflow, int&amp; cost) &#123; int dis[5003]; int vis[5003]; queue&lt;int&gt; bfs; while (dis[t] != 0x3f3f3f3f) &#123; memset(prev, 0, sizeof prev); memset(flow, 0, sizeof flow); memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); bfs.push(s); flow[s] = 0x3f3f3f3f; dis[s] = 0; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); vis[pos] = 0; for (int i = head[pos]; i; i = e[i].next) &#123; int nx = e[i].to; if (e[i].flow &lt; e[i].capacity &amp;&amp; dis[nx] &gt; dis[pos] + e[i].cost) &#123; dis[nx] = dis[pos] + e[i].cost; flow[nx] = min(flow[pos], e[i].capacity - e[i].flow); prev[nx] = i; if (!vis[nx]) &#123; bfs.push(nx); vis[nx] = 1; &#125; &#125; &#125; &#125; for (int i = prev[t]; i; i = prev[e[i].from]) &#123; e[i].flow += flow[t]; e[i^1].flow -= flow[t]; &#125; rflow += flow[t]; cost += dis[t] * flow[t]; &#125;&#125;void addedge(int x, int y, int z, int w) &#123; e[++cnt] = (edge)&#123;x, y, head[x], z, 0, w&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;y, x, head[y], 0, 0, -w&#125;; head[y] = cnt;&#125;int n, m, s, t, x, y, z, w, rflow, cost;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); while (m--) &#123; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;z, &amp;w); addedge(x, y, z, w); &#125; ek(s, t, rflow, cost); printf("%d %d", rflow, cost); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>网络流</tag>
        <tag>最大流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 3613」Cow Relays - Floyd + 矩阵快速幂]]></title>
    <url>%2F2018%2F05%2F02%2Fpoj-3613%2F</url>
    <content type="text"><![CDATA[题意 传送门：POJ 3613 - Cow Relays 求给定ttt条边的无向图中sss到ttt长度恰好为nnn的最短路的长度。 t≤100,n≤106,点的编号≤103t\le100,n\le10^6,\text{点的编号}\le10^3t≤100,n≤106,点的编号≤103 解法 首先离散化点的编号(显然图中最多只有200200200个点)。 然后考虑Floyd最短路的转移过程： 1234for k = 1 .. n for i = 1 ... n for j = 1 ... n g[i][j] = min(g[i][j], g[i][k] + g[k][j]) 再看看矩乘的过程： 1234for k = 1 .. n for i = 1 ... n for j = 1 ... n g[i][j] = add(g[i][j], g[i][k] * g[k][j]) 容易看出，Floyd只是将矩乘中的add换成了min，乘换成了加而已。 接着考虑一般的情况。 一般地，若GxG^xGx代表经过xxx条边的最短路，那么它满足关系式Ga+b=GaG^{a+b}=G^aGa+b=Ga乘GbG^bGb。 于是得出&quot;Floyd运算&quot;也满足结合律。于是可以用矩阵快速幂O(t^3\log n)​求出。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef int gph[502][502];int dcnt;void mul(gph x, gph y) &#123; // mul_equ: *= gph ret; memset(ret, 0x3f, 502 * 502 &lt;&lt; 2); for (int k = 1; k &lt;= dcnt; k++) &#123; for (int i = 1; i &lt;= dcnt; i++) &#123; for (int j = 1; j &lt;= dcnt; j++) &#123; ret[i][j] = min(ret[i][j], x[i][k] + y[k][j]); &#125; &#125; &#125; memcpy(x, ret, 502 * 502 &lt;&lt; 2);&#125;void pow(gph base, int exp, gph res) &#123; memcpy(res, base, 502 * 502 &lt;&lt; 2); exp--; // 弃单位矩阵的新科技 while (exp) &#123; if (exp&amp;1) mul(res, base); mul(base, base); exp &gt;&gt;= 1; &#125;&#125;int n, t, s, e, x, y, z;int disc[1000006];gph rec, ans;int main() &#123; memset(rec, 0x3f, sizeof rec); for (scanf("%d%d%d%d", &amp;n, &amp;t, &amp;s, &amp;e); t--; ) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); if (!disc[y]) disc[y] = ++dcnt; if (!disc[z]) disc[z] = ++dcnt; rec[disc[y]][disc[z]] = rec[disc[z]][disc[y]] = x; &#125; pow(rec, n, ans); printf("%d", ans[disc[s]][disc[e]]); return 0;&#125; 拓展 矩阵快速幂的基础是Ga+b=Ga×GbG^{a+b}=G^a\times G^bGa+b=Ga×Gb。然后在该式基础上进行倍增优化。 其实上式中的乘法可以换成其他运算(倍增加法求矩阵数乘)。如本题的&quot;Floyd运算&quot;。 在邻接矩阵上做运算，多有意思！ EASY版本： 「HDU 5318改」求无权无向图中长度为KKK的路径条数。其中n≤50,K≤109n\le50,K\le10^9n≤50,K≤109 做法是把邻接矩阵(01矩阵)快速幂一下求和除以二输出就好了。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Floyd</tag>
        <tag>POJ</tag>
        <tag>矩阵快速幂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 1734」Sightseeing trip - Floyd求最小环]]></title>
    <url>%2F2018%2F05%2F02%2Fpoj-1734%2F</url>
    <content type="text"><![CDATA[题意 传送门：POJ 1734 - Sightseeing trip 求无向图长度最小的点数≥3\ge3≥3的环之一的路径。 解法 令lnki,jlnk_{i,j}lnki,j​为iii到jjj暂时的最短路的某一个中转点。没有中转点则为000。 那么iii到jjj暂时的最短路就是iii到lnki,jlnk_{i,j}lnki,j​和lnki,jlnk_{i,j}lnki,j​到jjj的最短路……以此类推。 那么在Floyd更新最短路时同时更新lnklnklnk数据就可以记录路径了。 然后在每次Floyd更新之前算出最小环和路径更新答案即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int oo = 0x3f3f3f3f;int floyd[102][102];int gph[102][102];int lnk[102][102];int n, m, x, y, z;vector&lt;int&gt; loop;int ans = oo;void dfs(int x, int y) &#123; // [x, lnk[x][y]) -- lnk[x][y] -- (lnk[x][y], y] if (!lnk[x][y]) return; // 无中转点 dfs(x, lnk[x][y]); // 搜索中转点前半段 loop.push_back(lnk[x][y]); // 路径中加入中转点 dfs(lnk[x][y], y); // 搜索中转点后半段&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); memset(gph, 0x3f, sizeof gph); while (m--) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); gph[x][y] = gph[y][x] = min(gph[x][y], z); &#125; memcpy(floyd, gph, sizeof floyd); for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt; k; i++) &#123; for (int j = i + 1; j &lt; k; j++) &#123; // 对称性, 只需搜索右上三角形部分 if (ans &gt; (long long)floyd[i][j] + gph[j][k] + gph[k][i]) &#123; ans = floyd[i][j] + gph[j][k] + gph[k][i]; // 注意右上三角 loop.clear(); // i -- [中转点] -- j -- k -- i... loop.push_back(i); dfs(i, j); loop.push_back(j); loop.push_back(k); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (floyd[i][j] &gt; floyd[i][k] + floyd[k][j]) &#123; floyd[i][j] = floyd[i][k] + floyd[k][j]; lnk[i][j] = k; &#125; &#125; &#125; &#125; if (ans == oo) &#123; puts("No solution."); return 0; &#125; for (int i = 0; i &lt; loop.size(); i++) &#123; printf("%d ", loop[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Floyd</tag>
        <tag>最小环</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2442」修剪草坪 - DP + 单调队列]]></title>
    <url>%2F2018%2F04%2F22%2Fbzoj-2442%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P2627 - 修剪草坪，BZOJ2442 - 修剪草坪。 给一个长度为nnn的数组。现在让你选一些数，并且选的数中不能有在数组中长度超过kkk的连续段。求选出的数的和的最大值。 解法 令dpidp_idpi​为在[1,i][1,i][1,i]中选数的最大值。那么显然dpi=max⁡i−k≤j≤i{dpj−1+∑w=j+1iaw}dp_i=\max\limits_{i-k\le j\le i}\{dp_{j-1}+\sum\limits_{w=j+1}^ia_w\}dpi​=i−k≤j≤imax​{dpj−1​+w=j+1∑i​aw​}。 然后发现可以用前缀和优化。那么令sumi=∑j=1iajsum_i=\sum\limits_{j=1}^ia_jsumi​=j=1∑i​aj​，则dpi=max⁡i−k≤j≤i{dpj+sumi−sumj−1}dp_i=\max\limits_{i-k\le j\le i}\{dp_{j}+sum_i-sum_{j-1}\}dpi​=i−k≤j≤imax​{dpj​+sumi​−sumj−1​}，变形得dpi=max⁡i−k≤j≤i{dpj−1−sumj}+sumidp_i=\max\limits_{i-k\le j\le i}\{dp_{j-1}-sum_{j}\}+sum_idpi​=i−k≤j≤imax​{dpj−1​−sumj​}+sumi​。 于是发现这里的方程满足模型dpi=max⁡L(i)≤j≤R(i){dpj+val(i,j)}dp_i=\max\limits_{L(i)\le j\le R(i)}\{dp_j+val(i,j)\}dpi​=L(i)≤j≤R(i)max​{dpj​+val(i,j)}且val(i,j)val(i,j)val(i,j)中每一项只与iii或jjj有关，满足决策的单调性，所以开一个单调队列维护dpj−1−sumjdp_{j-1}-sum_jdpj−1​−sumj​在i−k≤j≤ii-k\le j\le ii−k≤j≤i时的最大值即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int head, tail = 1;int que[100015];ll pre[100015];ll dp_[100015];ll dp[100015];int n, k;const int N = 1 &lt;&lt; 20;char buf[N], *ptr = buf;inline int read() &#123; // Powered by LK int k = 0; while (!isdigit(*ptr)) ptr++; while (isdigit(*ptr))&#123; k = k * 10 + (*ptr++ ^ 48); &#125; return k;&#125;inline void add(int x) &#123; dp_[x] = dp[x-1] - pre[x]; while (head &lt;= tail &amp;&amp; dp_[que[tail]] &lt; dp_[x]) tail--; que[++tail] = x;&#125;inline ll query(int x) &#123; while (head &lt;= tail &amp;&amp; que[head] &lt; x-k) head++; return dp_[que[head]];&#125;int main() &#123; fread(buf, 1, N, stdin); n = read(); k = read(); for (int i = 1; i &lt;= n; i++) &#123; pre[i] = read(); pre[i] += pre[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; add(i); dp[i] = pre[i] + query(i); &#125; printf("%lld", dp[n]);&#125; 拓展 满足模型dpi=max⁡L(i)≤j≤R(i){dpj+val(i,j)}dp_i=\max\limits_{L(i)\le j\le R(i)}\{dp_j+val(i,j)\}dpi​=L(i)≤j≤R(i)max​{dpj​+val(i,j)}且val(i,j)val(i,j)val(i,j)中每一项只与iii或jjj有关时，可以在用单调队列维护jjj，对于每一个[L(i),R(i)][L(i),R(i)][L(i),R(i)]维护最大(小)值。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>BZOJ</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题目汇总」Tarjan题目汇总]]></title>
    <url>%2F2018%2F04%2F16%2Ftarjan-problems%2F</url>
    <content type="text"><![CDATA[这里是一些Tarjan题目的汇总。 进度：ABCDEF。 A, Caocao’s Bridges, 桥 传送门：HDU4738，YaliOJ。 题意 曹操在长江上弄了一些点，点之间有桥。每座桥上有若干人守卫。现在刘备有一枚炸弹，问最少带多少人去炸桥可以使点之间不连通。如果不可能输出−1-1−1。 解法 边(u,v)(u,v)(u,v)(uuu在dfs树下为vvv的子节点)为桥的充要条件是lowv&gt;dfnulow_v&gt;dfn_ulowv​&gt;dfnu​，也就是uuu的子节点vvv无法到达uuu及其之上的点，那么如果切断(u,v)(u,v)(u,v)那么图将不会联通。 这道题的坑点如下： 如果已经不连通了输出0。 处理方式：记录dfs拓展出的节点数，如果发现不到nnn那么显然不连通，输出000即可。 (expand+1 == n) * ans 如果没人守卫还是要输出1。 处理方式：如果ansansans为000那么取ansansans和111的max就好了。 (expand+1 == n) * max(1, ans) 最后加上对ans=+∞ans=+\inftyans=+∞的特判：ans == 0x3f3f3f3f ? -1 : (expand+1 == n) * max(1, ans) 重边需要特殊处理。(因为dfs树的特殊性，只需考虑父节点——子节点的重边即可) 处理方式：如果父节点到子节点只连了一次边，那么不需要用父节点更新。否则把父节点当成子节点更新。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int to, next, weight;&#125; e[2000006];int dfn[1003], low[1003], head[1003], idx, cnt, ans, expand;void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y], z&#125;; head[y] = cnt;&#125;void dfs(int x, int par) &#123; dfn[x] = low[x] = ++idx; int f = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (!dfn[nx]) &#123; dfs(nx, x); expand++; low[x] = min(low[x], low[nx]); if (low[nx] &gt; dfn[x]) &#123; ans = min(ans, e[i].weight); &#125; &#125; else if (nx == par) &#123; if (f) low[x] = min(low[x], dfn[nx]); f = 1; &#125; else low[x] = min(low[x], dfn[nx]); &#125;&#125;int n, m, x, y, z;int main() &#123; while (~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; (n || m)) &#123; memset(head, 0, sizeof head); memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(e, 0, sizeof e); idx = cnt = expand = 0; ans = 0x3f3f3f3f; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); addedge(x, y, z); &#125; dfs(1, -1); printf("%d\n", ans == 0x3f3f3f3f ? -1 : (expand+1 == n) * max(1, ans)); &#125;&#125; Y三集 B, Railway, 点双+桥 传送门：HDU4738，YaliOJ。 C, Network, 边双 传送门：HDU2460，YaliOJ。 D, TWO NODES, 割点 传送门：HDU4587，YaliOJ。 题意 给你一张图，问你删掉两个点最多能有多少个连通块。n,m≤5000n,m\le5000n,m≤5000。 解法 枚举其中一个删除的点，然后Tarjan求一遍割点。答案取max。 未完待续…… 代码 E, Warm up, 边双缩点 F, Important Sisters, 支配树]]></content>
      <categories>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>Y</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1997」Planar - 并查集]]></title>
    <url>%2F2018%2F04%2F15%2Fbzoj-1997%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1997 - Planar和洛谷 P3209 - PLANAR 给一张图，判断是不是平面图。3≤n≤200,m≤1043\le n\le200,m\le10^43≤n≤200,m≤104。 WTF？HNOI考平面图？还是平面图判定？ 当然不是。数据保证图中有汉密尔顿回路。 LYH：一眼看过去就是个假的平面图2333。 解法 首先平面图满足m≤3n−6(n≥3)m\le3n-6(n\ge3)m≤3n−6(n≥3)，不满足的直接NO。 既然都有汉密尔顿回路了，那么其它的边要么连在环里面要么连在环外面。 然后平面图要边不相交，那么就可以像团伙那题一样，用i+mi+mi+m代表与iii相交的边的集合。 然后如果不相交就判断有没有矛盾，相交就直接continue掉(玄学)。 如果不相交没有矛盾就把jjj和i+mi+mi+m以及iii和j+mj+mj+m连边。 就这么简单，谁说要用什么2-sat？(反正都比一般平面图判定简单) 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int u[10004], v[10004], id[10004];bool vis[10004];int par[10004];int t, _, n, m;bool cross(int x1, int x2, int y1, int y2) &#123; if (x1 == x2 || y1 == y2 || x1 == y2 || x2 == y1) &#123; return 0; &#125; return (x1 &lt; x2 &amp;&amp; y1 &lt; y2 &amp;&amp; x2 &lt; y1) || (x2 &lt; x1 &amp;&amp; y2 &lt; y1 &amp;&amp; x1 &lt; y2);&#125;int find(int x) &#123; return par[x] ? par[x] = find(par[x]) : x;&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y;&#125;int main() &#123; for (scanf("%d", &amp;t); t--; ) &#123; memset(par, 0, sizeof par); memset(u, 0, sizeof u); memset(v, 0, sizeof v); memset(id, 0, sizeof id); memset(vis, 0, sizeof vis); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", u+i, v+i); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;_); id[_] = i; &#125; if (m &gt; 3 * n - 6) &#123; puts("NO"); continue; &#125; for (int i = 1; i &lt;= m; i++) &#123; int x = id[u[i]]; int y = id[v[i]]; u[i] = min(x, y); v[i] = max(x, y); &#125; for (int i = 1; i &lt;= m; i++) &#123; vis[i] = (u[i]%n+1 == v[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; if (vis[i]) continue; for (int j = 1; j &lt;= m; j++) &#123; if (vis[j]) continue; if (!cross(u[i], u[j], v[i], v[j])) continue; if (find(i) == find(j)) &#123; puts("NO"); goto end; &#125; merge(i, j + m); merge(j, i + m); &#125; &#125; puts("YES"); end:; &#125;&#125; 拓展 下面的玄学我一样都不会： Tarjan的论文Efficient Planarity Testing(一般的平面图判定) BM算法Boyer Myrvold算法(目前最先进的平面图判定算法)]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>BZOJ</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 961E」Tufurama - 树状数组]]></title>
    <url>%2F2018%2F04%2F06%2Fcodeforces-961e%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 961E - Tufurama 有部电视剧有n(n≤2⋅105)n(n\le2\cdot10^5)n(n≤2⋅105)季，第iii季有aia_iai​集。问有多少个数对(x,y)(x&lt;y)(x,y)(x&lt;y)(x,y)(x&lt;y)，满足xxx季yyy集和yyy季xxx集都在电视剧中存在。 解法 为了简化问题，将数对的限制改为x≤yx\le yx≤y。 显然如果有一季集数超过了nnn，那么多余部分可以直接cut掉。 根据nnn的范围分析，时间复杂度肯定是O(n)O(n)O(n)枚举乘上O(1)/O(log⁡n)O(1)/O(\log n)O(1)/O(logn)处理。 而且第iii行处理完后所有集数少于iii的都可以删掉了(第iii行之后i&lt;x≤yi&lt;x\le yi&lt;x≤y)。 既然树状数组是沟通原数组和前缀和的桥梁，那么就可以打一个树状数组，代表是否被删除了。统计第iii行的答案只需将答案加上未被删除的季数即可食用。 哦，别忘了÷2\div2÷2并且处理掉所有x=yx=yx=y的情况！ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int n, rec[200005], tree[200005];vector&lt;int&gt; lst[200005];long long ans;inline lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x) &#123; while (i &lt;= n) &#123; tree[i] += x; i += lowbit(i); &#125;&#125;int query(int x) &#123; int ret = 0; while (x) &#123; ret += tree[x]; x -= lowbit(x); &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec+i); if (rec[i] &lt;= n) lst[rec[i]].push_back(i); add(i, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; ans += query(min(rec[i], n)) - (i &lt;= rec[i]); for (int j = 0; j &lt; lst[i].size(); j++) &#123; add(lst[i][j], -1); &#125; &#125; printf("%I64d", ans &gt;&gt; 1); return 0;&#125; 拓展 0/10/10/1树状数组可以很好的维护元素是否被删除的状态数组。 一些不便于维护和处理的限制条件，可以转化成便于维护的限制，再把多余的情况去除。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」树状数组 (+4)]]></title>
    <url>%2F2018%2F04%2F05%2Fbit-notes%2F</url>
    <content type="text"><![CDATA[树状数组，顾名思义望文生义，就是树状的数组。 树状数组，就是压了一半空间的zkw线段树，就是没有右子树的线段树&quot;堆式存储&quot;后的数组。 (这里所有的操作全都是区间加，区间和) UPD： 2018-03-29 20:55:23：Initial Commit 2018-04-01 22:44:36：Add 支持区间查询 代码3 2018-04-05 18:39:15：Add 二维树状数组,Change[Everything](更改排版、格式) 概念 树状数组长这样： 观察数组下标的二进制和树，得 1234567891 12 103 114 1005 1016 1107 1118 1000... 注意到每一层最左边的点都是2n2^n2n数列上的数。如果按照树形结构排列这些下标，得 其中同一个父节点的子节点，越靠左的在上上面的图中越浅。 然后我们发现，每个点和它的父节点都有些微妙的联系。具体地，就是每一个点的下标加上该下标的lowbit等于它的父节点的下标。 什么是lowbit呢？如(100101001100)2(100101001100)_2(100101001100)2​的lowbit就是(100)2(100)_2(100)2​。它可以通过x&amp;-x求出来。 一维树状数组 单点修改+区间查询 区间查询 因为树状数组只有右子树，所以树状数组只能进行前缀查询。方法是把一个点所在的子树和它左边的所有子树全部加起来。 注意到树状数组还有一个性质：一个点加上自身的lowbit，得到的点正好是高于该点的左边第一个节点。 听起来很绕，代个例子就知道了： 如查询111~777时需要访问的点(显然是log⁡n\log nlogn量级的)： 这些点的下标分别是777，7−lowbit(7)=67-lowbit(7)=67−lowbit(7)=6，6−lowbit(6)=46-lowbit(6)=46−lowbit(6)=4…… 单点修改 修改一个点的值，只需要修改它到根沿路上所有的点即可。 那么这些点满足上面的性质，所以只需要一直减去当前下标的lowbit，然后进行相应的修改即可。 下面提供树状数组最基本实现的代码。 代码 这里提供Accepted洛谷 P3374 【模板】树状数组 1的代码。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;int n, m, op, u, v;int rec[500005];int inp[500005];inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x) &#123; for (; i &lt;= n; i += lowbit(i)) rec[i] += x;&#125;int query(int i) &#123; int ret = 0; for (; i; i -= lowbit(i)) ret += rec[i]; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", inp + i); add(i, inp[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;op, &amp;u, &amp;v); if (op == 1) &#123; add(u, v); &#125; else &#123; printf("%d\n", query(v) - query(u - 1)); &#125; &#125;&#125; 区间修改+单点查询 树状数组是可以支持区间修改的。 方法是把原数组的差分数组存在树状数组里。这样区间修改就变成了两个单点修改。如将区间[u,v)[u,v)[u,v)的所有数加上www，那么相当于在它的差分数组的第uuu个数加www，第vvv个数减www。 这样可以比较简单的实现区间修改和单点查询。 代码 这里提供Accepted洛谷 P3368 【模板】树状数组 2的代码。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;int n, m, op, u, v, w, l;int rec[500005];int inp[500005];inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x) &#123; for (; i &lt;= n; i += lowbit(i)) rec[i] += x;&#125;int query(int i) &#123; int ret = 0; for (; i; i -= lowbit(i)) ret += rec[i]; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", inp + i); add(i, inp[i] - l); l = inp[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;op, &amp;u); if (op == 1) &#123; scanf("%d%d", &amp;v, &amp;w); add(u, w); add(v + 1, -w); &#125; else &#123; printf("%d\n", query(u)); &#125; &#125;&#125; 区间修改+区间查询 都支持区间修改了怎么能不支持区间查询？ 还是用差分。 \begin{align} a_1+a_2+\cdots+a_i&=(tree_1)+(tree_1+tree_2)+\cdots+(tree_1+tree_2+\cdots+tree_i)\\ &=i\cdot(tree_1+tree_2+\cdots+tree_i)-(i-1)\cdot tree_2-(i-2)tree_3-\cdots-tree_{i-1} \end{align} 于是可以开两个树状数组，一个存treeitree_itreei​，一个存i⋅treeii\cdot tree_ii⋅treei​。 结束了？结束了。 代码 支持区间修改+区间查询，也就是洛谷线段树1要支持的操作了。 这里提供Accepted洛谷 P3372 【模板】线段树 1的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;long long rec2[500005];long long rec[500005];long long inp[500005];long long l, u, v, w;int n, m, op;inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x, long long *arr) &#123; for (; i &lt;= n; i += lowbit(i)) arr[i] += x;&#125;long long query(int i, long long *arr) &#123; long long ret = 0; for (; i; i -= lowbit(i)) ret += arr[i]; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", inp + i); add(i, inp[i] - l, rec); add(i, (i - 1) * (inp[i] - l), rec2); l = inp[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%lld%lld", &amp;op, &amp;u, &amp;v); if (op == 1) &#123; scanf("%lld", &amp;w); add(u, w, rec); add(v + 1, -w, rec); add(u, w * (u - 1), rec2); add(v + 1, -w * v, rec2); &#125; else &#123; printf("%lld\n", query(v, rec) * v - query(v, rec2) - query(u - 1, rec) * (u - 1) + query(u - 1, rec2)); &#125; &#125;&#125; 总结 ❗️❗️❗️重点：树状数组中的第个元素表示右端点为，长度为的闭区间。或者说。这也是为什么查询的时候要一直减去lowbit。这样可以&quot;倍增&quot;的覆盖整个区间。 二维树状数组 类比总结1中的线性树状数组，二维树状数组中的treei,jtree_{i,j}treei,j​表示右下角为(i,j)(i,j)(i,j)，长为lowbit(i)lowbit(i)lowbit(i)，宽为lowbit(j)lowbit(j)lowbit(j)的矩阵。 单点修改+区间查询 首先我们把二维树状数组想象成树状&quot;树状数组&quot;数组(树状数组套树状数组)。 然后再次类比总结1中的树状数组结构。现在假设我们要将(x,y)(x,y)(x,y)加zzz。 单点修改 可以考虑把[1,x][1,x][1,x]中的所有[1,y][1,y][1,y]都加上zzz。然后可以用树状数组的lowbit优化复杂度，于是就变成O(log⁡2n)O(\log^2n)O(log2n)的复杂度了。 区间查询 区间查询就是容斥。求[(x1,y1),(x2,y2)][(x_1,y_1),(x_2,y_2)][(x1​,y1​),(x2​,y2​)]的子矩阵和就是query(x2,y2)−query(x1−1,y2)−query(x2,y1−1)+query(x1−1,y1−1)query(x_2,y_2)-query(x_1-1,y_2)-query(x_2,y_1-1)+query(x_1-1,y_1-1)query(x2​,y2​)−query(x1​−1,y2​)−query(x2​,y1​−1)+query(x1​−1,y1​−1)。 模板题1 (HDU2642 - Stars) 题意 你要维护一片1001×1001(0≤x,y≤1000)1001\times1001(0\le x,y\le1000)1001×1001(0≤x,y≤1000)的天空。有333种操作。B x y代表让(x,y)(x,y)(x,y)的星星亮，D x y代表让(x,y)(x,y)(x,y)的星星暗，Q x1 x2 y1 y2代表查询[(x1,y1),(x2,y2)][(x_1,y_1),(x_2,y_2)][(x1​,y1​),(x2​,y2​)]亮的星星数。最开始星星都是暗的。 解法 开两个数组(一个其实就够)。一个存树状数组，一个存原数组。如果星星已经亮了那么忽略B操作，否则就让它亮。D操作同理。然后Q操作就直接套一个裸的区间查询即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int n, rec[1003][1003], src[1003][1003];const int N = 1001;inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int j, int x) &#123; while (i &lt;= N) &#123; int j_ = j; while (j_ &lt;= N) &#123; rec[i][j_] += x; j_ += lowbit(j_); &#125; i += lowbit(i); &#125;&#125;int query(int x, int y) &#123; int ret = 0; while (x) &#123; int y_ = y; while (y_) &#123; ret += rec[x][y_]; y_ -= lowbit(y_); &#125; x -= lowbit(x); &#125; return ret;&#125;int t, X1, Y1, X2, Y2;char op[2];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s%d%d", &amp;op, &amp;X1, &amp;X2); X1++, X2++; if (*op == 'B') &#123; if (!src[X1][X2]) add(X1, X2, 1); src[X1][X2] = 1; &#125; else if (*op == 'D') &#123; if (src[X1][X2]) add(X1, X2, -1); src[X1][X2] = 0; &#125; else &#123; scanf("%d%d", &amp;Y1, &amp;Y2); Y1++; Y2++; int n1 = min(X1, X2), m1 = min(Y1, Y2), n2 = max(X1, X2), m2 = max(Y1, Y2); printf("%d\n", query(n2, m2) - query(n1 - 1, m2) - query(n2, m1 - 1) + query(n1 - 1, m1 - 1)); &#125; &#125; return 0;&#125; 模板题2 (JSOI2009 - 计数问题) 详见这篇博客。 区间修改+单点查询 根据二维前缀和公式，sumi,j=srci,j+sumi−1,j+sumi,j−1−sumi−1,j−1sum_{i,j}=src_{i,j}+sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}sumi,j​=srci,j​+sumi−1,j​+sumi,j−1​−sumi−1,j−1​。 那么可以令差分数组di,jd_{i,j}di,j​为srci,jsrc_{i,j}srci,j​与srci−1,j+srci,j−1−srci−1,j−1src_{i-1,j}+src_{i,j-1}-src_{i-1,j-1}srci−1,j​+srci,j−1​−srci−1,j−1​的差。 比如 (174963582)\begin{pmatrix} 1&amp;7&amp;4\\ 9&amp;6&amp;3\\ 5&amp;8&amp;2\\ \end{pmatrix} ⎝⎛​195​768​432​⎠⎞​ 的差分矩阵就是 (16−38−90−46−3)\begin{pmatrix} 1&amp;6&amp;-3\\ 8&amp;-9&amp;0\\ -4&amp;6&amp;-3\\ \end{pmatrix} ⎝⎛​18−4​6−96​−30−3​⎠⎞​ 如果要把111、777、999、666都加上xxx，那么在差分数组里这样更新： (1+x6−3−x8−90−4−x6−3+x)\begin{pmatrix} 1\color{red}+x&amp;6&amp;-3\color{red}-x\\ 8&amp;-9&amp;0\\ -4\color{red}-x&amp;6&amp;-3\color{red}+x\\ \end{pmatrix} ⎝⎛​1+x8−4−x​6−96​−3−x0−3+x​⎠⎞​ 然后区间修改就被转化成了444次单点修改。 区间修改+区间查询 高维树状数组？ 可以通过高维差分和高维前缀和类比低维情况实现。(显然我不会)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2009」计数问题 - 树状数组]]></title>
    <url>%2F2018%2F04%2F05%2Fjsoi2009-count%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1452 - Count和洛谷 P4054 - 计数问题 一个N×MN\times MN×M的方格，初始时每个格子有一个整数权值，接下来每次有222个操作: 改变一个格子的权值 求一个子矩阵中某个特定权值出现的个数 解法 开一个_树状数组数组数组_，即_&quot;二维树状数组&quot;数组_，第kkk个树状数组存权值kkk的出现次数。然后treei,j,ktree_{i,j,k}treei,j,k​就是权值在kkk右下角为(i,j)(i,j)(i,j)长lowbit(i)lowbit(i)lowbit(i)宽lowbit(j)lowbit(j)lowbit(j)子矩阵中的出现次数。 然后只需要写一个支持单点修改、区间查询的线段树即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std; int rec[302][302][102], src[302][302];int n, m; inline int lowbit(int x) &#123; return x&amp;-x;&#125; void add(int x, int y, int z, int w) &#123; while (x &lt;= n) &#123; int y_ = y; while (y_ &lt;= m) &#123; rec[x][y_][z] += w; y_ += lowbit(y_); &#125; x += lowbit(x); &#125;&#125; int query(int x, int y, int z) &#123; int ret = 0; while (x) &#123; int y_ = y; while (y_) &#123; ret += rec[x][y_][z]; y_ -= lowbit(y_); &#125; x -= lowbit(x); &#125; return ret;&#125; int op, c, q, X1, Y1, X2, Y2; int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", src[i] + j); add(i, j, src[i][j], 1); &#125; &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%d%d%d", &amp;X1, &amp;Y1, &amp;c); add(X1, Y1, src[X1][Y1], -1); add(X1, Y1, src[X1][Y1] = c, 1); &#125; else &#123; scanf("%d%d%d%d%d", &amp;X1, &amp;X2, &amp;Y1, &amp;Y2, &amp;c); printf("%d\n", query(X2, Y2, c) - query(X1 - 1, Y2, c) - query(X2, Y1 - 1, c) + query(X1 - 1, Y1 - 1, c)); &#125; &#125; return 0;&#125; 拓展 在权值的取值范围较小时可以开_树状数组数组数组_解决。 对于单点set操作，可以处理为不同树状数组中的单点修改操作，也可以处理成相同树状数组一次单点加和一次单点减。 区间set就交给lazy tag吧。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>树状数组</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「赛后总结」Codeforces Round #472 (Div. 2) (+2)]]></title>
    <url>%2F2018%2F04%2F01%2Fcodeforces-round-472%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #472 (Div. 2) 这次本来可以做D，可惜只做出A和B。 可惜C我想到了思路但没去做😢。 UPD： 2018-03-26 19:25:24：Initial Commit 2018-04-01 00:09:39：Add C A 题意 现在有ABM三种颜色，?是空白。现在问你是否有多余一种方式填满所有的?，并且相邻两个颜色不相同。 解法 很明显，如果?两边的颜色不同，那么这个肯定只有一种填法。 如果?在开头结尾，或者有几个连在一起，那么肯定有至少一种填法。 于是这就很简单了。只是细节很多。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;char last, bcount;string s;int n, f;int main() &#123; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (s[i] == last &amp;&amp; s[i] != '?') &#123; puts("No"); return 0; &#125; bcount += (s[i] == '?'); last = s[i]; &#125; if (!bcount) &#123; puts("No"); return 0; &#125; for (int i = 0; i &lt; n; i++) &#123; if (s[i] == '?') &#123; if (i == 0 || i == n - 1) f = 1; else if (s[i - 1] == '?' || s[i + 1] == '?') f = 1; else if (s[i - 1] == s[i + 1]) f = 1; &#125; if (f == 1) &#123; puts("Yes"); return 0; &#125; &#125; puts("No");&#125; B 题意 有nnn次操作，每一次可以选择一些行和列，然后把它们的交点全部染成黑色。 现在问你，给你一个黑白局面，问你能不能从白棋盘用nnn次得到它，并且满足所有操作中的行和列全部不重复。 解法 如图， 显然如果紫色点有任意三个被选了，那么另外一个肯定会也是黑的。 对于所有两两的行和列，如果这样的紫色点有111个、222个或者444个，那么一定是Yes，否则是NoNoNo。 代码 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char rec[233][233];int n, m;int main() &#123; scanf("%d%d\n", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; gets(rec[i] + 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i != j) for (int p = 1; p &lt;= m; p++) &#123; for (int q = 1; q &lt;= m; q++) &#123; if (p == q) continue; int count = 0; if (rec[i][p] == '#') count++; if (rec[i][q] == '#') count++; if (rec[j][p] == '#') count++; if (rec[j][q] == '#') count++; if (count == 3) &#123; puts("No"); return 0; &#125; &#125; &#125; &#125; &#125; puts("Yes"); return 0;&#125; C 题意 一串单调递增序列EEE，要你选333个不相同的下标(i,j,k),(i≤j≤k)(i,j,k),(i\le j\le k)(i,j,k),(i≤j≤k)，满足Ek−Ei≤UE_k-E_i \le UEk​−Ei​≤U，并且满足Ek−EjEk−Ei\frac{E_k-E_j}{E_k-E_i}Ek​−Ei​Ek​−Ej​​是所有满足条件的三元组中最小的。求出这个Ek−EjEk−Ei\frac{E_k-E_j}{E_k-E_i}Ek​−Ei​Ek​−Ej​​。 解法 固定iii。那么jjj很明显应该等于i+1i+1i+1。那么kkk肯定是满足单调性的。那么只需要找出Ek≤Ei+UE_k\le E_i+UEk​≤Ei​+U的最大的kkk。所以可以二分。时间复杂度O(nlog⁡n)O(n\log n)O(nlogn)。 其实还有个更好的办法——two-pointer。枚举iii，然后将i−1i-1i−1时的kkk用一次循环递增到当前iii时最大的kkk，然后再更新最终的答案。最终kkk移动的次数是O(n)O(n)O(n)量级的，所以复杂度降到了O(n)O(n)O(n)。 代码 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n, u, k, rec[100005];int ai, aj, ak;double loss;int main() &#123; scanf("%d%d", &amp;n, &amp;u); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i); &#125; loss = -1; for (int i = 1; i &lt; n - 1; i++) &#123; int j = i + 1; k = max(k, i); while (k + 1 &lt;= n &amp;&amp; rec[k + 1] - rec[i] &lt;= u) k++; if (k &lt;= i + 1) continue; double tl = 1. * (rec[k] - rec[j]) / (rec[k] - rec[i]); loss = max(loss, tl); &#125; if (loss == -1) puts("-1"); else printf("%.12lf", loss); return 0;&#125; D 题意 有条河，第i(1≤i≤n)i(1\le i\le n)i(1≤i≤n)天水的高度是undefinediundefined_iundefinedi​。如果某个undefinediundefined_iundefinedi​在以前没有出现过，那么就在那里打上标记。水不会冲掉标记。现在已知每一天河水以上(不包括当前标记)的标记数，求河水下(也不包括当前标记)最少有多少个标记。 解法 首先考虑这个思路： 弄一个变量mmm，如果每出现一个数字大于mmm，那么就m++(因为每多一个标记那么这时河水的位置一定在那时所有标记之前，并且还会增加一个标记)。 如果小于等于mmm，那么直接ans += m - 高度。 这个思路的问题是这样的数据就可以hack掉这个思路： 1240 0 0 2 解决方案是把这种数据处理成这样： 1240 0 1 2 再比如这个数据： 12110 0 0 0 0 0 0 2 4 6 8 和这个就是等价的： 12110 0 0 1 2 3 4 5 6 7 8 做法是先前缀最大值一遍，然后在再数据变得&quot;平滑&quot;。也就是把所有前缀最大值中相邻两项差不小于222的全部&quot;整平&quot;。 &quot;整平&quot;代码如下： 123456789101112131415// 输入for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i);&#125;// "整平"for (int i = 1; i &lt;= n; i++) &#123; smax[i] = max(smax[i - 1], rec[i]);&#125;for (int i = n; i &gt;= 1; i--) &#123; mrec[i] = t = max(smax[i], t - 1);&#125;for (int i = 1; i &lt; n; i++) &#123; mrec[i] = mrec[i + 1] - mrec[i];&#125; 其中mrec代表修改过的数组，smax代表前缀最大值。 代码 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, rec[100005];int mrec[100005];int smax[100005];long long ans;int t;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i); &#125; for (int i = 1; i &lt;= n; i++) &#123; smax[i] = max(smax[i - 1], rec[i]); &#125; for (int i = n; i &gt;= 1; i--) &#123; mrec[i] = t = max(smax[i], t - 1); &#125; for (int i = 1; i &lt; n; i++) &#123; mrec[i] = mrec[i + 1] - mrec[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans += m - rec[i]; m += mrec[i]; &#125; printf("%lld", ans);&#125;]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>枚举/暴力</tag>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
        <tag>two-pointer</tag>
        <tag>前缀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Manacher]]></title>
    <url>%2F2018%2F03%2F24%2Fmanacher-notes%2F</url>
    <content type="text"><![CDATA[简介 Manacher是一种可以用来在O(n)O(n)O(n)时间求出字符串的最长回文子串(和附赠的一个数组)的算法。 比较 暴力一：枚举所有字串，判断最长回文。复杂度O(n3)O(n^3)O(n3)，预处理回文O(n2)O(n^2)O(n2)。 暴力二：枚举所有中心(奇偶特判)，找出最长回文。复杂度还是O(n2)O(n^2)O(n2)。 哈希：貌似可以做到O(nlog⁡n)O(n\log n)O(nlogn) Manacher：可以把复杂度降到O(n)O(n)O(n)。 流程 为了防止奇偶特判，这里有一个小trick：在每一个间隙插入|字符，然后在字符串开头加一个$字符(可以换成任何字符串没有的字符，并且|和$可以相等)。 如lrzzqa就变成了$|l|r|z|z|q|a|了。 弄一个数组int p[N]，代表以某个数为中心时的最长回文的??长度。 现在假设我们已经计算到了下面这里，那么?要填什么值呢？ 12 $|a|b|c|b|c|d|c|d|a|p .1312151? 根据回文的对称性，回文中心左边的和右边的正好是镜像关系。于是?直接填左边的b对应的222就好了。 那么这种情况呢？ 12 $|x|a|b|a|b|p .1111131? 显然应该填333，但是根据对称性，?处应该填111。出现这种情况是因为回文已经突破|a|b|a|的边界了。所以这种情况就需要重新计算回文，然后记录下当前回文的中心和右端点，继续通过对称性填p数组了。 综上所述，可以写出以下流程： 首先对字符串进行处理。 iii从111循环到n−1n-1n−1(不考虑$字符) 如果iii在回文右端点之前，那么p[i]就等于他对称点的p值和从iii到对称点距离的最小值，及 pi=min⁡(p2mid−i,pmid+mid−i)p_i=\min(p_{2mid-i},p_{mid}+mid-i)pi​=min(p2mid−i​,pmid​+mid−i)。重中之重！ 否则pi=1p_i=1pi​=1。 接下来拓展回文。同朴素算法。 如果拓展之后回文超出边界，那么更新回文中心mid和右端点。 如果要求最长回文子串的长度，那么ans=min⁡(ans,pi)ans=\min(ans,p_i)ans=min(ans,pi​)。 证明略 代码 该代码用于AcceptedP3805 - 【模板】manacher算法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;char tmp[11000007], str[22000007];int p[22000007];int n;int manacher() &#123; int rb = 0, mid, ans = 0; for (int i = 1; i &lt; n; i++) &#123; if (i &lt; rb) p[i] = min(p[2 * mid - i], p[mid] + mid - i); else p[i] = 1; while (str[i + p[i]] == str[i - p[i]]) p[i]++; if (p[i] + i &gt; rb) &#123; rb = p[i] + i; mid = i; &#125; ans = max(ans, p[i]); &#125; return ans;&#125;void init() &#123; gets(tmp); n = strlen(tmp); str[0] = '$'; str[1] = '|'; for (int i = 0; i &lt; n; i++) &#123; str[2 * i + 2] = tmp[i]; str[2 * i + 3] = '|'; &#125; n = strlen(str);&#125;int main() &#123; init(); printf("%d", manacher() - 1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Tarjan强连通分量]]></title>
    <url>%2F2018%2F03%2F19%2Ftarjan-scc-notes%2F</url>
    <content type="text"><![CDATA[简介 其实杜教在ZROI的时候就讲过了，然后因为某些原因现在才来弄…… 强连通分量，指一张有向图的某个极大子图，满足两两点互相连通。 UPD： 2018-03-04 21:59:42：Initial Commit 2018-03-19 13:11:33：Add缩点 概念 如下面这张图： 从111点对它进行DFS，可以得到以下的DFS树： 实线边是树边 红边是横叉边 短虚线是返祖边 长虚线是前向边 当然，这些都只是为了交流方便。 现在定义dfn[i]和low[i]。 dfn[i]代表第iii个点的DFS序，low[i]代表第iii个点及其子树上的某个点通过一条横叉边或返祖边能到达的DFS序最小的点的DFS序。 流程 DFS过程中所有经过的点按照DFS序入栈。栈中所有点都没有形成强连通分量。 如果发现一个点dfn[u]=low[u]dfn[u]=low[u]dfn[u]=low[u]，也就是说这个点uuu再也不能沿着任何边往上走，那么显然这时栈中从栈顶一直到u的所有元素(子树中的元素)组成一个强连通分量，且它是极大的。 现在假设DFS从一个点uuu，沿着某条边搜到了某个点vvv，那么会有以下情况： uuu沿着树边到了vvv：先dfs(v)求出low[v]再low[u]=min⁡(low[u],low[v])low[u]=\min(low[u],low[v])low[u]=min(low[u],low[v])。 uuu沿着返祖边或横叉边到了vvv：如果边在栈中，那么low[u]=min⁡(low[u],dfn[v])low[u]=\min(low[u],dfn[v])low[u]=min(low[u],dfn[v])。 没有了？没有了。 学强连通分量：先背代码，再理解。 233333。 代码 该代码用于Accepted洛谷 P1726 - 上白泽慧音。 题意就是求排序后字典序最小的最大强连通分量。 显然只要比较最小的点即可。因为不可能一个点在两个不同的强连通分量中。 我是白泽慧音，我已经报警了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5003, M = 100005;struct Edge &#123; int to, next;&#125; e[M];int head[N];int dfn[N], low[N], vis[N], tmp[N], ans[N], ign[N];int dfn_index, scc_count, ans_len, edge_count;stack&lt;int&gt; st;int n, m;void tarjan(int cur) &#123; dfn[cur] = low[cur] = ++dfn_index; vis[cur] = 1; st.push(cur); for (int i = head[cur]; i; i = e[i].next) &#123; int nxt = e[i].to; if (!dfn[nxt]) &#123; tarjan(nxt); low[cur] = min(low[cur], low[nxt]); &#125; else if (vis[nxt] &amp;&amp; dfn[nxt] &lt; low[cur]) &#123; low[cur] = min(low[cur], dfn[nxt]); &#125; &#125; if (low[cur] == dfn[cur]) &#123; memset(tmp, 0, sizeof(tmp)); scc_count++; int _ = 0; while (!st.empty()) &#123; int x = st.top(); st.pop(); tmp[++_] = x; vis[x] = 0; ign[x] = 1; if (x == cur) break; &#125; sort(tmp + 1, tmp + _ + 1); if (_ &gt; ans_len || (_ == ans_len &amp;&amp; tmp[1] &lt; ans[1])) &#123; ans_len = _; memcpy(ans, tmp, sizeof ans); &#125; &#125;&#125;void addEdge(int u, int v, int _) &#123; e[++edge_count] = (Edge)&#123;v, head[u]&#125;; head[u] = edge_count; if (_ == 2) &#123; e[++edge_count] = (Edge)&#123;u, head[v]&#125;; head[v] = edge_count; &#125;&#125;int u, v, w;int main() &#123; scanf("%d%d", &amp;n, &amp;m); while (m--) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!ign[i]) &#123; tarjan(i); &#125; &#125; printf("%d\n", ans_len); for (int i = 1; i &lt;= ans_len; i++) &#123; printf("%d ", ans[i]); &#125; // while (1);&#125; 缩点 缩点，就是把每个强连通分量缩成一个点。 缩点很简单：只需要枚举原图所有的边，再把这些边变成强连通分量之间的边。 该代码用于Accepted洛谷 P3387 - 【模板】缩点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10004, M = 100005;struct edge &#123; int to, next;&#125; e[M];int head[N &lt;&lt; 1], wgt[N], vis[N], dfn[N], low[N], scc[N], dp[N], nwgt[N];int edge_cnt, dfn_index, scc_count;stack&lt;int&gt; st;void tarjan(int x) &#123; dfn[x] = low[x] = ++dfn_index; vis[x] = 1; st.push(x); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (!dfn[nx]) &#123; tarjan(nx); low[x] = min(low[x], low[nx]); &#125; else if (vis[nx] &amp;&amp; dfn[nx] &lt; low[x]) &#123; low[x] = min(low[x], dfn[nx]); &#125; &#125; if (dfn[x] == low[x]) &#123; scc_count++; while (!st.empty()) &#123; int _ = st.top(); st.pop(); scc[_] = scc_count; vis[_] = 0; nwgt[scc_count] += wgt[_]; if (_ == x) break; &#125; &#125;&#125;void addEdge(int x, int y) &#123; e[++edge_cnt] = (edge)&#123;y, head[x]&#125;; head[x] = edge_cnt;&#125;void dfs(int x) &#123; if (dp[x]) return; dp[x] = nwgt[x]; int ret = 0; for (int i = head[x]; i; i = e[i].next)&#123; if (!dp[e[i].to]) dfs(e[i].to); ret = max(ret, dp[e[i].to]); &#125; dp[x] += ret;&#125;int n, m, u[M], v[M], ans;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", wgt + i); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", u+i, v+i); addEdge(u[i], v[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; tarjan(i); &#125; &#125; memset(head, 0, sizeof head); memset(e, 0, sizeof e); edge_cnt = 0; for (int i = 1; i &lt;= m; i++) &#123; if (scc[u[i]] == scc[v[i]]) continue; addEdge(scc[u[i]], scc[v[i]]); &#125; for (int i = 1; i &lt;= scc_count; i++) &#123; if (!dp[i]) &#123; dfs(i); ans = max(ans, dp[i]); &#125; &#125; printf("%d", ans); return 0;&#125; 拓展 缩点以及一些神奇的缩点DP。 其实求强连通分量有很多别的算法，只是Tarjan知名度较高而已&gt;_&lt;，然后点双边双啥的可以和强连通归在一类，也好处理一些。 Kosaraju算法。复杂度和Tarjan一样，而且貌似好写一些，但是常数好像大一些(反正我们也能背下Tarjan的代码2333)，所以貌似没什么用。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」高斯消元]]></title>
    <url>%2F2018%2F03%2F08%2Fgaussian-elimination-notes%2F</url>
    <content type="text"><![CDATA[简介 高斯消元，是一种一般用来解线性方程组的算法。 不就是个加减消元要说的这么先进么 流程 2018-04-05 18:40:51：准确的说，这是高斯-约旦消元法，高斯消元法是转化为简化梯形矩阵后回代的那种消元法。 比如下面这个线性方程组： {−x+y−2z=34x−3y+6z=2x−6y−3z=−1\left\{ \begin{array}l -x+y-2z=3\\ 4x-3y+6z=2\\ x-6y-3z=-1 \end{array} \right. ⎩⎨⎧​−x+y−2z=34x−3y+6z=2x−6y−3z=−1​ 它可以被转化为这样一个矩阵： (−11−234−3621−6−3−1)\left( \begin{array}c -1&amp;1&amp;-2&amp;3\\ 4&amp;-3&amp;6&amp;2\\ 1&amp;-6&amp;-3&amp;-1 \end{array} \right) ⎝⎛​−141​1−3−6​−26−3​32−1​⎠⎞​ 显然，我们希望它变成这样： (100a010b001c)\left( \begin{array}c 1&amp;0&amp;0&amp;a\\ 0&amp;1&amp;0&amp;b\\ 0&amp;0&amp;1&amp;c \end{array} \right) ⎝⎛​100​010​001​abc​⎠⎞​ 也就是这样的方程组： {x=ay=bz=c\left\{ \begin{array}l x=a\\ y=b\\ z=c \end{array} \right. ⎩⎨⎧​x=ay=bz=c​ 那么可以考虑从xxx开始，一元一元地消元。 首先把第111行和xxx系数绝对值最大的行进行交换，以便减小误差： (4−362−11−231−6−3−1)\left( \begin{array}c 4&amp;-3&amp;6&amp;2\\ -1&amp;1&amp;-2&amp;3\\ 1&amp;-6&amp;-3&amp;-1 \end{array} \right) ⎝⎛​4−11​−31−6​6−2−3​23−1​⎠⎞​ 然后把第111行全部÷4\div4÷4： (1−343212−11−231−6−3−1)\left( \begin{array}c 1&amp;-\frac34&amp;\frac32&amp;\frac12\\ -1&amp;1&amp;-2&amp;3\\ 1&amp;-6&amp;-3&amp;-1 \end{array} \right) ⎝⎛​1−11​−43​1−6​23​−2−3​21​3−1​⎠⎞​ 接下来加减消元把222、333行的xxx系数变为000： (1−342312014−12720−214−92−32)\left( \begin{array}c 1&amp;-\frac34&amp;\frac23&amp;\frac12\\ 0&amp;\frac14&amp;-\frac12&amp;\frac72\\ 0&amp;-\frac{21}4&amp;-\frac92&amp;-\frac32 \end{array} \right) ⎝⎛​100​−43​41​−421​​32​−21​−29​​21​27​−23​​⎠⎞​ 然后再把yyy的系数绝对值最大的与第222行交换： (1−3423120−214−92−32014−1272)\left( \begin{array}c 1&amp;-\frac34&amp;\frac23&amp;\frac12\\ 0&amp;-\frac{21}4&amp;-\frac92&amp;-\frac32\\ 0&amp;\frac14&amp;-\frac12&amp;\frac72 \end{array} \right) ⎝⎛​100​−43​−421​41​​32​−29​−21​​21​−23​27​​⎠⎞​ 依此类推，消掉yyy： (10157570167−2700−57247)\left( \begin{array}c 1&amp;0&amp;\frac{15}7&amp;\frac57\\ 0&amp;1&amp;\frac67&amp;-\frac27\\ 0&amp;0&amp;-\frac57&amp;\frac{24}7 \end{array} \right) ⎝⎛​100​010​715​76​−75​​75​−72​724​​⎠⎞​ 最后消掉zzz，流程结束： (10011010225001−245)\left( \begin{array}c 1&amp;0&amp;0&amp;11\\ 0&amp;1&amp;0&amp;\frac{22}5\\ 0&amp;0&amp;1&amp;-\frac{24}5 \end{array} \right) ⎝⎛​100​010​001​11522​−524​​⎠⎞​ 代码 该代码用于Accepted洛谷 P3389 - 【模板】高斯消元法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const double EPS = 1e-8;const int N = 102;double mat[N][N];int n;void gauss() &#123; for (int i = 1; i &lt;= n; i++) &#123; int piv = i; for (int j = i; j &lt;= n; j++) &#123; if (fabs(mat[j][i]) &gt; fabs(mat[piv][i])) &#123; piv = j; &#125; &#125; if (piv != i) for (int j = 1; j &lt;= n + 1; j++) &#123; swap(mat[i][j], mat[piv][j]); &#125; if (fabs(mat[i][i]) &lt;= EPS) &#123; puts("No Solution"); exit(0); &#125; for (int j = i + 1; j &lt;= n + 1; j++) &#123; mat[i][j] /= mat[i][i]; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (i != j) &#123; for (int k = i + 1; k &lt;= n + 1; k++) &#123; mat[j][k] -= mat[j][i] * mat[i][k]; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; for (int v = 1; v &lt;= n+1; v++) &#123; printf("%.6lf ", mat[u][v]); &#125; puts(""); &#125; puts(""); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n + 1; j++) &#123; scanf("%lf", mat[i] + j); &#125; &#125; gauss(); for (int i = 1; i &lt;= n; i++) &#123; printf("%.2lf\n", mat[i][n + 1]); &#125; return 0;&#125; 拓展 异或方程组。好像连乘除都省了，只要异或？各种千奇百怪的开灯问题什么就应该好弄多了。 怨念的BZOJ1013……]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>高斯消元</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Tarjan割点]]></title>
    <url>%2F2018%2F03%2F06%2Ftarjan-cut-notes%2F</url>
    <content type="text"><![CDATA[简介 如果在一张无向图上删除它和它的所有边使图的连通性改变，那么这个点就这张无向图的割点。 概念 强烈建议看割点之前先右转看看强连通分量 和强连通分量不同，割点只会在无向图中出现。因为DFS树的特性，这棵树上只会有两种边：树边和反向边。 如下面这张图： 从111点对它进行DFS，可以得到以下的DFS树(这个例子貌似有点极端)： 还是一样，定义dfn[i]和low[i]。 dfn[i]代表第iii个点的DFS序，low[i]代表第iii个点及其子树上的某个点通过一条横叉边或返祖边能到达的DFS序最小的点的DFS序。 显然无向图的DFS树中不可能存在所谓的横叉边，因为如果存在的话那么这条边也会变成树边。 流程 现在假设DFS从一个点uuu，沿着某条边搜到了某个点vvv，那么会有以下情况： uuu沿着树边到了vvv：先dfs(v)求出low[v]再low[u]=min⁡(low[u],low[v])low[u]=\min(low[u],low[v])low[u]=min(low[u],low[v])。 uuu沿着反向边到了vvv：low[u]=min⁡(low[u],dfn[v])low[u]=\min(low[u],dfn[v])low[u]=min(low[u],dfn[v])。 既然每棵子树已经完全独立了，那么一个点uuu是不是割点就很好定义了： 如果uuu是根并且有至少两个儿子，那么断掉根各个子树就会分成几个不同的连通块，所以这个点是割点。 如果uuu不是根且搜到的点vvv满足low[v]≥dfn[u]low[v]\ge dfn[u]low[v]≥dfn[u]，那么断掉uuu后vvv就无法到达low[i]，所以这个点是割点。 结束了？结束了。 代码 该代码用于Accepted洛谷 P3388 - 【模板】割点（割顶）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005, M = 200005;struct Edge &#123; int to, next;&#125; e[M];int head[N];int cut_count, edge_count, dfn_index;int n, m, dfn[N], low[N], par[N];bool cut[N];void tarjan(int cur) &#123; dfn[cur] = low[cur] = ++dfn_index; int cnt = 0; for (int i = head[cur]; i; i = e[i].next) &#123; int nxt = e[i].to; if (nxt == par[cur]) continue; if (!dfn[nxt]) &#123; cnt++; par[nxt] = cur; tarjan(nxt); low[cur] = min(low[cur], low[nxt]); if (par[cur] &amp;&amp; low[nxt] &gt;= dfn[cur]) &#123; cut_count += !cut[cur]; cut[cur] = 1; &#125; &#125; else &#123; low[cur] = min(low[cur], dfn[nxt]); &#125; &#125; if (!par[cur] &amp;&amp; cnt &gt;= 2) &#123; cut_count += !cut[cur]; cut[cur] = 1; &#125; &#125;void addEdge(int u, int v) &#123; e[++edge_count] = (Edge)&#123;v, head[u]&#125;; head[u] = edge_count;&#125;int u, v;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; tarjan(i); &#125; &#125; printf("%d\n", cut_count); for (int i = 1; i &lt;= n; i++) &#123; if (cut[i]) &#123; printf("%d ", i); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>模板</tag>
        <tag>Tarjan</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1886」滑动窗口 - 单调队列]]></title>
    <url>%2F2018%2F03%2F03%2Fluogu-1686%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1886 - 滑动窗口 单调队列的入门题。 给一个序列，求所有长度为kkk的子段的最小值和最大值。 解法 数据的范围是k≤n≤106k\le n\le 10^6k≤n≤106，暴力当然过不了。 为了简化问题，只考虑最小值。 考虑滑动的过程。 在最开始的[1,k][1,k][1,k]移向[2,k+1][2,k+1][2,k+1]时，第一个元素的生命就结束了，第k+1k+1k+1个元素进入了它的生命周期。 如果有一组数据{2, 3, 1, 4, 2, 6, 3}, k = 3，那么最开头的222和333肯定&quot;没有前途&quot;作为最小值。 而且窗口每移动一次，就会让一些数字&quot;没有前途&quot;。 如果可以在O(1)O(1)O(1)的时间处理每一次移动，那么处理10610^6106的数据将没有任何问题。 现在我们考虑的算法流程是： 移动 -&gt; 删除&quot;没有前途&quot;的元素 -&gt; 添加新元素 -&gt; 删除因为移动而GG的元素 -&gt; 输出/保存当前答案 -&gt; 回到第一步。 第二步和第三步可以用单调队列维护。 一个单调队列，就是一个元素按照一定顺序排列的队列。 考虑一个双端队列，(仅)可以从头尾增删元素，(仅)可以获取头尾元素的信息，那我们可以利用双端队列实现单调队列。下面是实现方法(仍然只考虑最小值)： 插入元素xxx(同时删除一些队尾的元素以满足单调性) 先把所有大于等于xxx的数从队尾删掉 然后把xxx加入进去 删除队首元素 无脑pop_front不久好了？ 然后第二步和第三步对应一次插入，第四步对应一次删除。 然后呢？ 都这么详细了你还要我讲什么？ 代码 注释就不用加了吧，可读性应该还可以。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;deque&lt;int&gt; maxq, minq;int rec[1000006];int n, k;void min_p() &#123; for (int i = 1; i &lt;= n; i++) &#123; while (!minq.empty() &amp;&amp; minq.back() &gt;= rec[i]) &#123; minq.pop_back(); &#125; minq.push_back(rec[i]); if (i &gt; k) if (minq.front() == rec[i - k]) minq.pop_front(); if (i &gt;= k) printf("%d ", minq.front()); &#125; puts("");&#125;void max_p() &#123; for (int i = 1; i &lt;= n; i++) &#123; while (!maxq.empty() &amp;&amp; maxq.back() &lt;= rec[i]) &#123; maxq.pop_back(); &#125; maxq.push_back(rec[i]); if (i &gt; k) if (maxq.front() == rec[i - k]) maxq.pop_front(); if (i &gt;= k) printf("%d ", maxq.front()); &#125; puts("");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i); &#125; min_p(); max_p();&#125; 拓展 这个拓展包括的就不是滑动窗口了。话说滑动窗口到底有什么用 单调队列优化DP、递推等一系列东西 其实我也不知道啊……我太弱了]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>单调队列</tag>
        <tag>洛谷</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1214」团伙 - 并查集]]></title>
    <url>%2F2018%2F02%2F22%2Fbzoj-1214%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1214 - 团伙 有nnn个人，有mmm对朋友或敌人的关系。并且满足以下性质： 朋友的朋友也是朋友。 敌人的敌人也是朋友。 所有的朋友组成一个团伙。 现在问你根据这些信息，最多可能有几个团伙。 解法 首先题面中的最多省去，那么问题就转化为求团伙的数量。 求连通块数量可以很容易想到并查集。 朋友关系很好处理，只需要两两merge即可。 敌人咋处理？ 可以考虑把一个人AAA拆成两个点AAA和A′A&#x27;A′。其中A′A&#x27;A′代表A的所有敌人的集合。 那么根据敌人的敌人是朋友，可以得出，如果AAA和BBB是敌人，那么我们要merge以下两对： merge(A,B′)merge(A,B&#x27;)merge(A,B′)和merge(A′,B)merge(A&#x27;,B)merge(A′,B)。 于是只要开到两倍空间就好了。 统计连通块数只需统计111~nnn的连通块个数即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int par[10003];int src[10003];int n, m, a, b;char s[2];int ans;int find(int x) &#123; return par[x] == x ? x : par[x] = find(par[x]);&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 2 * n; i++) &#123; par[i] = i; &#125; while (m--) &#123; scanf("%1s%d%d", s, &amp;a, &amp;b); if (*s == 'F') &#123; merge(a, b); &#125; else &#123; merge(n + a, b); merge(a, n + b); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; src[find(i)] = 1; &#125; for (int i = 1; i &lt;= 2 * n; i++) &#123; ans += src[i]; &#125; printf("%d", ans);&#125; 拓展 求连通块个数当然用并查集啦！ 如果关系种类繁多，错综复杂，可以考虑把一个点&quot;拆&quot;成多个点。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「赛后总结」Codeforces Round #464 (Div. 2) (+1)]]></title>
    <url>%2F2018%2F02%2F17%2Fcodeforces-round-464%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #464 (Div. 2) 今天的状态差到一种境界&gt;_&lt;。然后估计这几次比赛会炼成High Frequency Rating。 本来可以做出C、D的，顿时感觉被出题人坑了。 原来坑题不止中国出，俄罗斯也出(这次出题人是俄罗斯的)。 A 比赛时竟然写了个dfs…… 然后造就了 # When Who Problem Lang Verdict Time Memory 2018-02-17 13:27:26 A - Love Triangle GNU C++ Time limit exceeded on pretest 4 1000 ms 2200 KB 2018-02-17 13:23:57 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2200 KB 2018-02-17 13:22:58 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2200 KB 2018-02-17 13:19:46 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2000 KB 2018-02-17 13:15:25 A - Love Triangle GNU C++ Memory limit exceeded on pretest 6 140 ms 262100 KB 的奇观。 直到我发现只要判断a[a[a[i]]] == i是否成立就可以通过。 然后我终于…… # When Who Problem Lang Verdict Time Memory 2018-02-17 14:21:19 A - Love Triangle GNU C++ Pretests Passed 30 ms 2000 KB 然而那时我已经早就AC了B题…… 最后A我只拿了150150150分。然并卵 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[5003];int n;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[a[a[i]]] == i) &#123; puts("YES"); return 0; &#125; &#125; puts("NO");&#125; 教训 不要想多！不要想多！！不要想多！！！ 这堆数据发现了你的想多。 我是这堆数据中的一个超级水数据，我先发现你的想多是你Rating的幸运。警告你：不要想多！不要想多！！不要想多！！！ 你的的方向上有千万个参赛者，只要不想多，这堆数据就无法定位想多者。 如果想多，想多者将被定位，你的Rank将会遭到打击，你的Rating将会被降低！ 不要想多！不要想多！！不要想多！！！ B 因为我没考虑到无解时全部输出000的情况，所以我又WA了一发。还有一发是我没判断仓鼠数量。 然后我一直没调到错误。 直到我发现我在if中的判断少写了个=。 代码 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;long long n, x, ax, bx, cx;int k;int main() &#123; scanf("%I64d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123; scanf("%I64d", &amp;x); if (n - n % x &gt;= cx) &#123; ax = i; bx = n / x; cx = n - n % x; &#125; &#125; printf("%I64d %I64d", ax, bx);&#125; 教训 小心无解情况。如果允许输出多组解中的任意一个，请不要使用&lt;或者&gt;，用&lt;=和&gt;=替代它们。如果不允许，则将当前答案设置成无解。 C 令f−s=kf-s=kf−s=k。 最开始我写了个前缀和，然后在最后追加kkk个数，把每个长度为kkk的子段算出来然后取个max。 无数次Wrong answer on test 20之后还是没有发现错在哪里。 然后我比赛时就没过这题…… 比赛结束后，我改成了另外一种写法，又无数次Wrong answer on test 9后也没有发现问题。 最后我写了个尺取法或two-pointer，然后还是Wrong answer on test 9。 在我砸键盘前的那一刻，我提交了一份骗数据的代码。于是…… Output 12320280: 5007229129971799717: 500722912 Answer 120280 卧槽(上这么难你是人吗)答案一样为什么是202802028020280？百思不得姐。 直到我看见了这句话： If there are many answers, output the smallest among them. mmp。 更错 上面这333个算法，虽然是正着枚举，但是时间是反的。 于是就Wrong answer on test 9了。 估计是LJ出题人不想写太长的SPJ，然后就在Output最后写了这句话。 前缀和的最后 我的前缀和还是莫名其妙的Wrong answer on test 20了，估计算法还是有问题。 代码(双指针) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#ifdef LOCAL#define lld "%lld"#else#define lld "%I64d"#endifusing namespace std;long long arr[200005];long long ax, ai, cur;int n, s, f, t;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%lld", arr+i); &#125; scanf("%d%d", &amp;s, &amp;f); s--; f -= 2; for (int i = s; i &lt;= f; i++) &#123; cur += arr[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (cur &gt;= ax) &#123; ai = t + 1; ax = cur; &#125; f = (f + 1) % n; cur += arr[f] - arr[s]; s = (s + 1) % n; t = (t + n - 1) % n; &#125; printf(lld, ai);&#125; 教训 防被坑最好的方法是多读题。 D 第一感图论，然后写了个枚举。如果a[i] == b[i]那么gph[ax][bx] = 1，然后把所有连边输出。 然后挂在了这个数据上： 1233abcbca 接下来我写了个初始化为000的并查集，然后因为有000点，与初始值矛盾，于是第二个样例挂了。 最后我写了个把所有字母替换成一个字符串中存在的字符的代码，于是Wrong answer on pretest 4。类似这样： 1232abcd 比赛完我才发现，(卧槽上这么难你是人吗)我把并查集的初始值设矛盾了，于是我把初始值设为−1-1−1，然后就Accepted了！ 代码 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char a[100005], b[100005];int par[31];int n, ans;int find(int x) &#123; return ~par[x] ? par[x] = find(par[x]) : x;&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y, ans++;&#125;int main() &#123; memset(par, -1, sizeof par); scanf("%d\n", &amp;n); gets(a + 1); gets(b + 1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i] != b[i]) &#123; int ax = a[i] - 'a'; int bx = b[i] - 'a'; merge(ax, bx); &#125; &#125; printf("%d\n", ans); for (int i = 0; i &lt; 26; i++) &#123; find(i); if (par[i] != -1) printf("%c %c\n", i + 'a', par[i] + 'a'); &#125;&#125; 教训 乱初始化的后果是很严重的。写并查集前先想想有没有0号点。 E 二分三分不会写不好写，于是来优化暴力。 令f(x,i)f(x,i)f(x,i)代表选择最大的数xxx和前iii个数时的max−meanmax-meanmax−mean。 显然添加数字之后并不会影响以前的答案。 于是可以O(n)O(n)O(n)Accepted这道题。 代码 123456789101112131415161718192021222324252627282930313233343536// mmp为什么只有C++14及以上可以通过编译?详见下一篇底层博客————坑爹的编译器。#include &lt;bits/stdc++.h&gt;#ifdef LOCAL#define lld "%lld"#else#define lld "%I64d"#endifusing namespace std;typedef long long ll;typedef long double ld;int q, l, n, op, ptr;ll arr[500005];ld ans;ld f(ll x, int i) &#123; return (x * i - arr[i]) / ld(i + 1);&#125;int main() &#123; scanf("%d", &amp;q); ll x; while (q--) &#123; scanf("%d", &amp;op); if (op &amp; 1) &#123; scanf(lld, &amp;x); while (ptr &lt; n &amp;&amp; f(x, ptr) &lt;= f(x, ptr + 1)) ptr++; ans = max(ans, f(x, ptr)); arr[n+1] = arr[n] + x; n++; &#125; else &#123; printf("%.10Lf\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
        <tag>two-pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2009」HH 的项链 - 莫队]]></title>
    <url>%2F2018%2F02%2F16%2Fsdoi2009-diff%2F</url>
    <content type="text"><![CDATA[⚠️注意：「SDOI2009」HH 的项链 - 莫队⇔「算法」莫队\colorbox{lightgray}{「SDOI2009」HH 的项链 - 莫队}\Leftrightarrow\colorbox{lightgray}{「算法」莫队}「SDOI2009」HH 的项链 - 莫队​⇔「算法」莫队​。 题意 传送门：BZOJ1878 - HH的项链 莫队模板题。 给一个长度为nnn数列，要你查询mmm次[l,r][l,r][l,r]区间中不同的数字的个数。 n≤106,m≤105n\le 10^6,m\le 10^5n≤106,m≤105 解法 虽然看起来这题可以卡掉莫队，但是我还是用莫队AC了。 然后直接套模板即可。 2018-05-12 UPD：洛谷的数据加强了，把莫队卡过了。 存储结构 1234567struct query &#123; int l, r, *ans; bool operator&lt;(const query&amp; x) const &#123; if (l / blockSize == x.l / blockSize) return r &lt; x.r; return l / blockSize &lt; x.l / blockSize; &#125;&#125; q[200005]; lll和rrr代表查询中的l,rl,rl,r，ansansans代表保存答案的位置的指针(这样排序之后输出的顺序就不会乱)。 blockSize是每个块的大小。 修改操作 1234int extend(int x, int offset) &#123; if (~offset) return 1 == ++cnt[x]; // +1 else return -!--cnt[x]; // -1&#125; xxx代表更新的数字，offset代表加还是减(1,−1)(1,-1)(1,−1)，返回值用来更新答案。 如果+1+1+1之后cnt[x]正好为111，那就是新增了一种数字，返回111。 如果−1-1−1之后cnt[x]正好为000，那就是减少了一种数字，返回−1-1−1。 莫队算法 12345678int l = 1, r = 0, lans = 0;for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) lans += extend(src[++r], 1); while (r &gt; q[i].r) lans += extend(src[r--], -1); while (l &gt; q[i].l) lans += extend(src[--l], 1); while (l &lt; q[i].l) lans += extend(src[l++], -1); *q[i].ans = lans;&#125; lans代表当前查询的答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, blockSize, src[50004], ans[200005], cnt[1000006];struct query &#123; int l, r, *ans; bool operator&lt;(const query&amp; x) const &#123; if (l / blockSize == x.l / blockSize) return r &lt; x.r; return l / blockSize &lt; x.l / blockSize; &#125;&#125; q[200005];int extend(int x, int offset) &#123; if (~offset) return 1 == ++cnt[x]; else return -!--cnt[x];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", src+i); &#125; blockSize = ceil(sqrt(n)); scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;q[i].l, &amp;q[i].r); q[i].ans = ans+i; &#125; sort(q + 1, q + m + 1); int l = 1, r = 0, lans = 0; for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) lans += extend(src[++r], 1); while (r &gt; q[i].r) lans += extend(src[r--], -1); while (l &gt; q[i].l) lans += extend(src[--l], 1); while (l &lt; q[i].l) lans += extend(src[l++], -1); *q[i].ans = lans; &#125; for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>模板</tag>
        <tag>SDOI</tag>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day3 - DP]]></title>
    <url>%2F2018%2F02%2F09%2Fday3-notes%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： day2 欠账 最长简单环 fp,s,tf_{p,s,t}fp,s,t​从sss到ttt经过点集ppp是否存在。 初始：f2i−1,i,i=1f_{2^{i-1},i,i}=1f2i−1,i,i​=1 如果iii满足(t,i)∈E,(p&gt;&gt;(i+1)&amp;1)=0(t, i) \in E, (p&gt;&gt;(i+1)\&amp;1)=0(t,i)∈E,(p&gt;&gt;(i+1)&amp;1)=0，就可以转移fp∣(1&lt;&lt;(i−1)),s,if_{p|(1&lt;&lt;(i-1)),s,i}fp∣(1&lt;&lt;(i−1)),s,i​ fp,s,t=1f_{p,s,t}=1fp,s,t​=1且(t,s)∈E(t,s) \in E(t,s)∈E，则长度为__builtin_popcount(p)。 复杂度：2nn32^nn^32nn3 优化 限定sss是环中最小的编号，其它条件不变。 转移时枚举s+1...ns+1...ns+1...n ∑in2nn=n∑i=1n2i=O(2nn)\sum_i^n2^nn=n\sum_{i=1}^n2^i=O(2^nn)∑in​2nn=n∑i=1n​2i=O(2nn) 例题6 fpf_pfp​在组里的最大收益。 fp=max⁡sw[s]+fp−sf_p=\max\limits_s w[s]+f_{p-s}fp​=smax​w[s]+fp−s​ (p&amp;s)=s(p\&amp;s)=s(p&amp;s)=s O(4n)O(4^n)O(4n)并不能跑过n=16n=16n=16。 优化 ppp有2k−12^{k-1}2k−1个非空子集，可以用000~2k−12^{k-1}2k−1表示所有的子集。只需2k−12^{k-1}2k−1枚举子集。 对于每一个集合PPP，那么子集数为2∣P∣2^{|P|}2∣P∣。 复杂度O(3n)O(3^n)O(3n) 123for (s=p; s; s=(s-1)&amp;p) &#123; // 不重复枚举所有p的子集 // do something...&#125; 生成树计数 令111为根。 fi,pf_{i,p}fi,p​代表iii的子树中，有ppp个点的子树个数。 1init : f[i][1&lt;&lt;(i-1)] = 1; fi,p=∑fj,sfi,p−s,s⊆P−{i},j∈sf_{i,p}=\sum f_{j,s}f_{i,p-s}, s\subseteq P-\{i\} , j\in sfi,p​=∑fj,s​fi,p−s​,s⊆P−{i},j∈s 设min⁡(P−{i})=k\min(P-\{i\})=kmin(P−{i})=k。 复杂度O(3nn2)O(3^nn^2)O(3nn2) 枚举顺序 i 1~n P 0~2^n-1 斯坦纳树 fi,pf_{i,p}fi,p​以iii为根，经过关键点集合ppp。 i,ji,ji,j是关键点fi,p=min⁡fj,s+fi,p−s+wi,jf_{i,p}=\min f_{j,s}+f_{i,p-s}+w_{i,j}fi,p​=minfj,s​+fi,p−s​+wi,j​ 孤立点从子树接边fi,p=min⁡fj,p+wi,jf_{i,p}=\min f_{j,p}+w_{i,j}fi,p​=minfj,p​+wi,j​ 带环，需要用最短路转移！ 轮廓线DP⊆\subseteq⊆状压 例题9 暴力 fi,pf_{i,p}fi,p​代表扫到了iii列，ppp从上一行突出来了。 Procedure： ppp碰到障碍点，直接扔掉。 枚举sss，代表在第iii行会横出下一行。 满足s&amp;(p|障碍)=0。 而且竖着的骨牌必须可以摆在~(s|障碍|p)中。 复杂度3^nn^{很多次方} 高端操作(轮廓线DP) 首先一列一列放骨牌，然后总共有n+1n+1n+1个边界。 放置的方式： 12345671 8 15 . #2 9 . . #3 10. . #4 11. #5 12. #6 13. #7 14. # 边界： 1234567. . . . # 1. . . . # 1. . . . # 1. . . # 2. . . # 1. . . # 1. . . # 1 如图，有n+1n+1n+1个边界。 可以记录状态fi,j,pf_{i,j,p}fi,j,p​代表放到了(i,j)(i,j)(i,j)点，边界ppp方案数。 不合法状态： iii要长出来或i+1i+1i+1要长出来并且(i,j)(i,j)(i,j)是障碍。 iii和i+1i+1i+1都要长出来。 合法状态： iii和i+1i+1i+1只有一个长出来并且(i,j)(i,j)(i,j)不是障碍， 转移到P−(1&lt;&lt;(i−1))P-(1&lt;&lt;(i-1))P−(1&lt;&lt;(i−1))或P−(1&lt;&lt;i)P-(1&lt;&lt;i)P−(1&lt;&lt;i)。 其它长出情况直接转移到P+(1&lt;&lt;(i−1))P+(1&lt;&lt;(i-1))P+(1&lt;&lt;(i−1))或P+(1&lt;&lt;i)P+(1&lt;&lt;i)P+(1&lt;&lt;i)。 最后扫完一行后需要更新轮廓线才可以继续DP。 新的轮廓线中的第一个一定是000(边界外不可能有股牌下来) 如果n+1n+1n+1为111就直接丢掉(伸到了边界外面) 然后就直接左移一位(111移到222 222移到333…nnn移到n+1n+1n+1) 复杂度O(2nn2)O(2^nn^2)O(2nn2) 枚举顺序jjj、iii、ppp。 k国王问题 fi,j,k,pf_{i,j,k,p}fi,j,k,p​ 放到(i,j)(i,j)(i,j)，放了kkk个国王，轮廓线外的ppp格会被攻击。 讨论两种情况：放还是不放。 放就把周围一圈的ppp更新，否则直接转移。 max⁡i=0\max\limits_i=0imax​=0 day2e B f_{叶子}=+\inf,f_.=0 fi+=min⁡(w,fj)f_i+=\min(w,f_j)fi​+=min(w,fj​) C fi,pf_{i,p}fi,p​ 前iii选ppp是否能到达 枚举aaa、bbb。 fi,p−&gt;fi+1,p+(1&lt;&lt;(a−1))+(1&lt;&lt;(b−1))f_{i,p}-&gt;f_{i+1,p+(1&lt;&lt;(a-1))+(1&lt;&lt;(b-1))}fi,p​−&gt;fi+1,p+(1&lt;&lt;(a−1))+(1&lt;&lt;(b−1))​ (p&gt;&gt;(a,b−1))&amp;1=0(p&gt;&gt;(a,b-1))\&amp;1=0(p&gt;&gt;(a,b−1))&amp;1=0，满足边 A fi,j=∑k=0wifi−1,j−k(jk)f_{i,j}=\sum_{k=0}^{w_i}f_{i-1,j-k}\binom jkfi,j​=∑k=0wi​​fi−1,j−k​(kj​) O((∑wi)2)O((\sum w_i)^2)O((∑wi​)2) D 改板轮廓线DP模板 E fi,jf_{i,j}fi,j​深度≤j\le j≤j，有iii点。 fi−1,j−1⋅2⋅if_{i-1,j-1}\cdot 2\cdot ifi−1,j−1​⋅2⋅i ∑k=1i−2fk,j−1⋅fi−k−1,j−1⋅i⋅(i−2i−k−2)\sum_{k=1}^{i-2}f_{k,j-1}\cdot f_{i-k-1,j-1}\cdot i\cdot \binom{i-2}{i-k-2}∑k=1i−2​fk,j−1​⋅fi−k−1,j−1​⋅i⋅(i−k−2i−2​) f0,i=1f_{0,i}=1f0,i​=1 f1,i=1f_{1,i}=1f1,i​=1 状态O(nd)O(nd)O(nd)，转移O(n)O(n)O(n) 复杂度O(n2d)O(n^2d)O(n2d)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day2 - DP]]></title>
    <url>%2F2018%2F02%2F08%2Fday2-notes%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： day1欠账 简单题 fn,x,yf_{n,x,y}fn,x,y​长度aaa，x,yx,yx,y表示111和000的奇偶性。 fn,0,y−&gt;fn,0,y xor 1f_{n,0,y} -&gt; f_{n,0,y\ xor\ 1}fn,0,y​−&gt;fn,0,y xor 1​ fn,x,0−&gt;fn,x xor 1,0f_{n,x,0} -&gt; f_{n,x\ xor\ 1,0}fn,x,0​−&gt;fn,x xor 1,0​ 矩阵优化 fn+1,0,0,fn+1,0,1,fn+1,1,0,fn+1,1,1f_{n+1,0,0}, f_{n+1,0,1}, f_{n+1,1,0}, f_{n+1,1,1}fn+1,0,0​,fn+1,0,1​,fn+1,1,0​,fn+1,1,1​ 000 0/10/10/1 不放 111 转移矩阵 [0100100100000100]\left[ \begin{array}{c} 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right] ⎣⎢⎢⎡​0100​1001​0000​0100​⎦⎥⎥⎤​ 树形DP 重点！如果合并两个子树时间是两个子树的乘积，那么这个树形DP是平方的 模板 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;void merge(int x, int p) &#123; // 合并子树 f[p][0] = f[p][1] + /* max(f[k][0], f[k][1]) */; f[p][1] = f[p][0] + f[x][1];&#125;void init(int x) &#123; // 初始化 // f[k][0] = 0;// f[k][1] = 1;&#125;void treedp(int x) &#123; // 树形dp 不需要改 for (int i = 0; i &lt; c[x].size(); i++) &#123; treedp(c[x][i]); &#125; init(x); for (int i = 0; i &lt; c[x].size(); i++) &#123; merge(c[x][i], x); &#125;&#125;int main() &#123; // 状态 -&gt; init -&gt; merge &#125; 最大独立集 同模板 例题2 123456state: f[i][0], f[i][1]init : f[i][1] = f[i][0] = 0;merge: f[x][1] = max(f[p][1] + max(f[x][1], f[x][0]), f[p][0] + f[x][0] + 1); : f[x][0] = f[p][0] + max(f[x][1], f[x][0]); // 缺失部分 例题3 12345state: f[i][0] 我不是，孩子也不是[不合法] : f[i][1] 我不是，孩子是[合法] : f[i][2] 我是[满足]init : f[i][0] = 0, f[i][2] = 1, f[i][1] = 0x3f3f3f3fmerge: x\p 0 1 2 0 2 1 0 1 2 2 1 1 2 HOMEWORK：距离为222 例题4 简化版(只考虑子树) 12345f[i][x][y] 当前子树关键点 当前子树的子树f[i][0][0] = 0f[i][1][0] = 1f[i][0][1] = f[i][1][1] = 0x3f3f3f3f x\p 0,0 0,1 1,0 1,1 0 0,1 1,1 1 1,0 1,1 1,0 1,1 普通版 存在度数大于333的点 贪心地选一个度大于333的点为根，然后同简化版 不存在(链)，输出111。 例题5 1234567f[i]表示只删以i为根的子树的ans(minimal maximum)f[叶子]=0x3f3f3f3ff[其它]=0merge:f[i]=max(f[i], x); 练习1 1234 0 1 ---0|0 11|0 x ans = 5471492 [暂缺] 例题6 简化版(只考虑子树) ff=max⁡(ff,fj−wj)f_f=\max(f_f, f_j-w_j)ff​=max(ff​,fj​−wj​) 普通版 令子树外最长路为uiu_iui​。 维护次大值gfg_fgf​和fff_fff​的来源wherefwhere_fwheref​。 gfg_fgf​初始000。 1234if (f[k] + w &gt; f[f]) &#123; g[f] = f[k]; &#125; 123456User -&gt; Web: SubmitWeb -&gt; Judger: SubmitNote right of Judger: Waiting &amp; JudgingJudger -&gt; Web: WAWeb -&gt; User: WANote left of User: MMP 123456789101112131415161718start=&gt;start: 做题needIOOptimize=&gt;condition: 需要快速IO?kengDie=&gt;operation: 坑爹,命题人SBimplementation=&gt;condition: 大模拟题?codeLong=&gt;operation: 难写,命题人SBconstant=&gt;condition: 题目还卡常?boring=&gt;operation: 无聊,命题人SBisEasy=&gt;condition: 题目太简单?water=&gt;operation: 太水,命题人SBend=&gt;end: 婊死出题人start-&gt;needIOOptimizeneedIOOptimize(yes)-&gt;kengDie-&gt;endneedIOOptimize(no)-&gt;implementationimplementation(yes)-&gt;codeLong-&gt;endimplementation(no)-&gt;constantconstant(yes)-&gt;boring-&gt;endconstant(no)-&gt;water-&gt;end 例题7 令每条边经过fif_ifi​次，那么ans=∑difians = \sum d_if_ians=∑di​fi​，did_idi​是权值。 dfs求出fif_ifi​即可。 监测站 乱搞 树形背包 fi,jf_{i,j}fi,j​表示iii子树jjj容量 gi,jg_{i,j}gi,j​表示不选iii的子树jjj容量 初始gi,j=0g_{i,j}=0gi,j​=0 如果选iii就一定选整个子树 ：max(gi,j,∑vi)(j≥∑vi)max(g_{i,j},\sum v_i)(j \ge \sum v_i)max(gi,j​,∑vi​)(j≥∑vi​) gi,a+b′=gi,a+fc,bg&#x27;_{i,a+b}=g_{i,a}+f_{c,b}gi,a+b′​=gi,a​+fc,b​ fi,j={gi,jj&gt;∑vi,max(gi,j,∑vi)j≥∑vi.f_{i,j}=\left\{\begin{array}l g_{i,j} &amp; j&gt;\sum v_i,\\ max(g_{i,j}, \sum v_i) &amp; j\ge \sum v_i. \end{array}\right. fi,j​={gi,j​max(gi,j​,∑vi​)​j&gt;∑vi​,j≥∑vi​.​ 时间复杂度O(n3)O(n^3)O(n3) 状压DP 例题1 fi,p[n]f_{i,p[n]}fi,p[n]​前iii衣服，pip_ipi​裤子是否配对。 for j=1...n (i+1, j)可配对，pj=0p_j=0pj​=0 f[i+1][j|(1&lt;&lt;(j-1))] += f[i][j]; 12343 91 1 1 2 1 32 1 2 2 2 33 1 3 2 3 3 例题2 拓扑排序计数(NP-Hard) fpf_pfp​选的点数。 对于所有满足要求的(k, j)，jjj没被选，kkk放了，fp∣(1&lt;&lt;(j−1))+=fpf_{p|(1&lt;&lt;(j-1))} += f_pfp∣(1&lt;&lt;(j−1))​+=fp​。 20:2n20: 2^n20:2n 18:2nn18: 2^nn18:2nn 16:2nn2/3n16: 2^nn^2 / 3^n16:2nn2/3n 例题3 tit_iti​代表第iii条直线覆盖点的。 fp=min⁡(fp∣ti,...,fp+1)f_p=\min(f_{p|t_i},...,f_p+1)fp​=min(fp∣ti​​,...,fp​+1) 固定一个端点，可以将枚举直线改为O(n)O(n)O(n)。 2n个点最短路乱搞？ 例题4 Who knows？ for i=1..m fp∣ti=max⁡(...,fp+1)(p&amp;ti=0)f_{p|t_i}=\max(..., f_p+1)(p\&amp;t_i=0)fp∣ti​​=max(...,fp​+1)(p&amp;ti​=0) 例题5 最长简单环(NP-Hard NPC) 实现例题2 (选做例题5)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day1 - DP]]></title>
    <url>%2F2018%2F02%2F07%2Fday1-notes%2F</url>
    <content type="text"><![CDATA[⚠️注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： fi,j+1=fa,b(Aa=Ab,Ai=Aj,Aa&gt;Ai,i&lt;a,j&lt;b)f_{i,j}+1=f_{a,b}(A_a=A_b, A_i=A_j, A_a &gt; A_i, i&lt;a, j&lt;b)fi,j​+1=fa,b​(Aa​=Ab​,Ai​=Aj​,Aa​&gt;Ai​,i&lt;a,j&lt;b) 二叉树枚举aaa，求出jjj之后第一个Aa=AbA_a = A_bAa​=Ab​ 预处理？ ni,x≠i+1,ni,x=ni+1,xn_{i,x} \ne i+1, n_{i,x}=n_{i+1,x}ni,x​≠i+1,ni,x​=ni+1,x​ ni,x=i+1,ni,x=i+1n_{i,x} = i+1, n_{i,x} = i+1ni,x​=i+1,ni,x​=i+1 1| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | fn,m=(s−1n−1)∑s=1nfn−s,m−1f_{n,m} = \binom {s-1} {n-1}\sum_{s=1}^nf_{n-s,m-1}fn,m​=(n−1s−1​)∑s=1n​fn−s,m−1​ fn,m=mfn−1,m+fn−1,m−1f_{n,m}=mf_{n-1,m}+f_{n-1,m-1}fn,m​=mfn−1,m​+fn−1,m−1​ 优化状态？转移？ 错排问题 fnf_nfn​ 当a≠na \ne na≠n时，(n−1)fn−2(n-1)f_{n-2}(n−1)fn−2​ 当a=na=na=n时，(n−1)fn−1(n-1)f_{n-1}(n−1)fn−1​ fn=(n−1)(fn−1+fn−2)f_n=(n-1)(f_{n-1}+f_{n-2})fn​=(n−1)(fn−1​+fn−2​) 逆序对 fn,mf_{n,m}fn,m​代表nnn个数产生mmm个逆序对的数量。 fn,m=∑k=1nfn−1,m−k+1f_{n,m}=\sum_{k=1}^nf_{n-1,m-k+1}fn,m​=∑k=1n​fn−1,m−k+1​ 前缀和优化 (m−n,m](m-n,m](m−n,m] fn,m=gi,m−gi,m−nf_{n,m}=g_{i,m}-g_{i,m-n}fn,m​=gi,m​−gi,m−n​ 例题2 【IMPOSSIBLE】 f_{i,j}前iii物品，取jjj的长度，方案数。 f_{i,j}=\sum_{k=0}^{w_i}g_{j-k,k}f_{i-1,j-k} 例题3 二叉树：fn=∑i=0n−1fifn−i−1(n−1i)f_n=\sum_{i=0}^{n-1}f_if_{n-i-1}\binom {n-1} ifn​=∑i=0n−1​fi​fn−i−1​(in−1​) 二叉树的子结构性质 有根树：fn=∑i=1n−1fifn−i(n−2i−1)f_n = \sum_{i=1}^{n-1}f_if_{n-i}\binom{n-2}{i-1}fn​=∑i=1n−1​fi​fn−i​(i−1n−2​) 去掉一棵子树还是一棵树 kkk叉树：f_{n,k}=\sum_{i=1}^{n-1}f_{i,1}f_{n-i,k-1}\binom{n-2}{i-1} gn,m=∑i=1n−1gn−i,m−1fig_{n,m}=\sum_{i=1}^{n-1}g_{n-i,m-1}f_ign,m​=∑i=1n−1​gn−i,m−1​fi​ fi=∑j=0kgi,jf_i=\sum_{j=0}^kg_{i,j}fi​=∑j=0k​gi,j​ gn,mg_{n,m}gn,m​ 根mmm其它nnn 拆分数 fi,j=fi,j−i+fi−1,j−if_{i, j} = f_{i, j-i} + f_{i-1, j} - ifi,j​=fi,j−i​+fi−1,j​−i n≤105n \le 10^5n≤105情况 gi,jg_{i,j}gi,j​ iii个数，和为jjj。 i≤ni \le \sqrt ni≤n​时：fi,j=fi−1,j+fi,j−if_{i,j}=f_{i-1,j}+f_{i,j}-ifi,j​=fi−1,j​+fi,j​−i i≥ni \ge \sqrt ni≥n​时：gi,j=gi−1,j−1+gi,j−ig_{i,j}=g_{i-1,j-1}+g_{i,j-i}gi,j​=gi−1,j−1​+gi,j−i​ h_j = \sum_{i=0}^\sqrt ng_{i,j-i\sqrt n} Ans=∑A=0nfn,Ahn−AAns = \sum_{A=0}^nf_{\sqrt n, A}h_{n-A}Ans=∑A=0n​fn​,A​hn−A​ Alt+F4 F(U)⊂KF(U)\subset KF(U)⊂KING HOMEWORK Y∅∪RY\emptyset\cup RY∅∪R log⁡n\log nlogn 202020 n\sqrt nn​ 300300300 求长度为500050005000恰好有100000100000100000个逆序对的排列个数 nnn个点带标号的无向图个数 nnn个点带标号的无向连通图个数 n≤5000n \le 5000n≤5000 = = ​ 2(n2)2^\binom n22(2n​) fn=2(n2)−∑i=1nfi×2(n−22)×(n−1i−1)f_n=2^\binom n2-\sum_{i=1}^nf_i\times2^\binom{n-2}2\times\binom{n-1}{i-1}fn​=2(2n​)−∑i=1n​fi​×2(2n−2​)×(i−1n−1​) 选标号(n−1i−1)\binom{n-1}{i-1}(i−1n−1​)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码片段]]></title>
    <url>%2F2018%2F02%2F06%2Fcode-snippet%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>Internal</category>
      </categories>
      <tags>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1216-D - 差分]]></title>
    <url>%2F2017%2F12%2F20%2Fyali-1216-d%2F</url>
    <content type="text"><![CDATA[题意 传送门：1216-D 有一个n​个数的序列，一开始所有的数都是0​，每次可以将一个区间[l,r]​ (l≤r)​内的数+1​，求到达最终状态的最少操作次数。 n≤105,m≤105n \le 10^5,m \le 10^5n≤105,m≤105，mmm为操作次数。 解法 正难则反：考虑已知每次操作，求序列。可使用前缀和。 如样例输出： 123431 61 62 6 将闭区间转为左闭右开，即[1,7),[1,7),[2,7)[1, 7), [1, 7), [2, 7)[1,7),[1,7),[2,7)，则可得到： 1234下标: 1 2 3 4 5 6 7数组: 2 1 0 0 0 0 -3前缀和后得到原序列:原序列: 2 3 3 3 3 3 0 根据前缀和的逆运算是差分，得到O(n+m)O(n+m)O(n+m)解法。 优化 既然差分之后就可以求出所有区间，为什么不直接往队列里面丢呢？ 如差分序列2 1 0 0 0 0 -3，进行以下处理： 遇到正数222，直接丢222个下标111在存lll的队列中。 123l队列 r队列11 遇到正数111，直接丢111个下标222在存lll的队列中。 1234l队列 r队列112 遇到负数-3，直接丢∣−3∣=3|-3|=3∣−3∣=3个下标7−1=67-1=67−1=6在存rrr的队列中。 1234l队列 r队列1 61 62 6 输出即可。 123431 61 62 6 时间复杂度O(n+m)O(n+m)O(n+m)。 代码 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int out[100005][2]; //模拟队列int n, x, m1, m2, r;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); if (r &lt; x) for (int j = x-r; j--;) out[m1++][0] = i; if (r &gt; x) for (int j = r-x ; j--;) out[m2++][1] = i-1; r = x; &#125; for (int j = r ; j--;) out[m2++][1] = n; printf("%d\n", m1); for (int i = 0; i &lt; m1; i++) &#123; printf("%d %d\n", out[i][0], out[i][1]); &#125;&#125; 拓展 正难则反：很多题目需要逆向思考。如将差分题逆向思考得到前缀和。多考虑互逆运算之间的转化关系。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Y</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1704」寻找最优美做题曲线 - DP]]></title>
    <url>%2F2017%2F12%2F09%2Fluogu-1704%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1704 - 寻找最优美做题曲线 现在给出每一天刷题的题数，并且有几天必须刷题，问最多可以刷多少天的题并且满足严格递增。 说白了就是，给一个序列，告诉你有一些下标上的数必须包含在LIS中，求满足条件的LIS，就是被禁锢的LIS。 解法 变量定义 12345int p[500005], t[500005]; // p代表必须刷题的时间, t代表每天刷题的题数int lis[500005]; // LIS数组int c[500005]; //处理过的刷题题数int n, m, x; // n天, m天必须刷题int ans; // 答案 读入 贴代码不解释： 12345678scanf("%d%d", &amp;n, &amp;m);for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", p+i);&#125;sort(p+1, p+m+1);for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", t+i);&#125; 处理 首先，如果必须刷题的那几天不严格递增，咳咳。 1234567for (int i = 2; i &lt;= m; i++) &#123; if (t[p[i]] &lt;= t[p[i-1]]) &#123; puts("impossible"); return 0; &#125;&#125;proc(); 接下来是对LIS做一些处理。 首先，如果一个序列中的数比前面的数都大，比后面的数都小，那这个数一定包含在LIS中。 那么我们可以使需要刷题的每一天都满足这个要求。 如数据：12 6 10 11 8 12 10 11 16 14 17 13 14 18，我们可以进行以下骚操作： 12 6 10 11 8 12 10 11 16 14 17 13 14 18 得到6 10 11 16 17 18。 代码如下： 123456789101112131415161718192021void proc() &#123; // int new_n = 0; c[0] = t[0] // t中的内容处理后被存入c中 int nx = 0; *c = *t; for (int i = 1; i &lt;= m; i++) &#123; if (i &gt; 1) c[++nx] = t[p[i-1]]; for (int j = p[i-1]+1; j &lt; p[i]; j++) &#123; // 两个必须刷题的日子的中间 if (t[p[i-1]] &lt; t[j] &amp;&amp; t[j] &lt; t[p[i]]) &#123; c[++nx] = t[j]; &#125; &#125; &#125; c[++nx] = t[p[m]]; for (int i = p[m]+1; i &lt;= n; i++) &#123; // 最后一个必须刷题的日子之后 if (t[p[m]] &lt; t[i]) &#123; c[++nx] = t[i]; &#125; &#125; c[++nx] = t[p[m]]; n = nx;&#125; LIS O(nlog⁡n)O(n \log n)O(nlogn)的LIS算法参见这里，代码如下： 123456for (int i = 1; i &lt;= n; i++) &#123; int pos = lower_bound(lis+1, lis+ans+1, c[i]) - lis; lis[pos] = c[i]; ans = max(ans, pos);&#125;printf("%d", ans); 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int p[500005], t[500005];int lis[500005];int c[500005];int n, m, x; int ans;void proc() &#123; int nx = 0; *c = *t; for (int i = 1; i &lt;= m; i++) &#123; if (i &gt; 1) c[++nx] = t[p[i-1]]; for (int j = p[i-1]+1; j &lt; p[i]; j++) &#123; if (t[p[i-1]] &lt; t[j] &amp;&amp; t[j] &lt; t[p[i]]) &#123; c[++nx] = t[j]; &#125; &#125; &#125; c[++nx] = t[p[m]]; for (int i = p[m]+1; i &lt;= n; i++) &#123; if (t[p[m]] &lt; t[i]) &#123; c[++nx] = t[i]; &#125; &#125; c[++nx] = t[p[m]]; n = nx;&#125; int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", p+i); &#125; sort(p+1, p+m+1); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", t+i); &#125; for (int i = 2; i &lt;= m; i++) &#123; if (t[p[i]] &lt;= t[p[i-1]]) &#123; puts("impossible"); return 0; &#125; &#125; proc(); for (int i = 1; i &lt;= n; i++) &#123; int pos = lower_bound(lis+1, lis+ans+1, c[i]) - lis; lis[pos] = c[i]; ans = max(ans, pos); &#125; printf("%d", ans);&#125; 拓展 对于限制或改版LIS问题，可以做一定的处理，使其变为正常LIS，然后再使用裸LIS算法解决。或者设计针对题目的算法。 这里列出一些相关的题目： LICS 最长上升公共子序列 二元组LIS 最长震荡子序列]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Internetl」深拷贝之殇 - 底层]]></title>
    <url>%2F2017%2F12%2F08%2Fdeep-copy-notes%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>Internal</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Internal」一个UB引发的血案 - 底层]]></title>
    <url>%2F2017%2F12%2F08%2Fundefined-behavior-notes%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>Internal</category>
      </categories>
      <tags>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「经典」八数码问题 - BFS]]></title>
    <url>%2F2017%2F11%2F24%2Feight-digits-puzzle%2F</url>
    <content type="text"><![CDATA[题意 这么经典的题目还要题意… 传送门：洛谷 P1379(让我想到了1379号监听员😆) 思路 不会写康托展开，遂用数字存储，然后使用bitset存储visited数组。 输入后对输入的局面BFS。 交换整数中的数字 首先，数字中的下标对应以下表格： 0 1 2 3 4 5 6 7 8 那么， 上下交换就是xxx和x+3x+3x+3交换(x&lt;5)(x&lt;5)(x&lt;5)， 左右交换就是xxx和x+1x+1x+1交换(x&lt;7)(x&lt;7)(x&lt;7)。 但有个问题，如果2和3交换或者5和6交换那就不行了。 所以有一个神奇的方法：判断两数相乘是否为6或30😆。 123456789，若要将3和7交换， 首先记忆3，接下来减7×1027 \times 10^27×102，然后加3×1023 \times 10^23×102， 再减3×1063 \times 10^63×106，最后加7×1067 \times 10^67×106。 输出路径？ 集训的题目要输出路径，那就加个map存前驱，然后递归打出来。 Talk is cheap! Give me the code! 代码在这里： 可以AC洛谷P1379 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define t(x) ((((x)&lt;&lt;2)+(x))&lt;&lt;1)#define l(x, i) ((x)/p10[i]%10)#define w(x, i) (*(x+i))using namespace std;// 预处理10^nconst int p10[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000&#125;;const int dir[4] = &#123;3, -3, 1, -1&#125;; // 方向矢量map&lt;int, int&gt; dep; // 深度queue&lt;int&gt; bfs; // 广搜队列int n; // 数字int main() &#123;// #ifndef __TIGER0132__// freopen("9gong.in", "r", stdin);// freopen("9gong.out", "w", stdout);// #endif scanf("%d", &amp;n); bfs.push(n); dep[n] = 0; // 初始深度 while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); int cdep = dep[pos] + 1; // 现在搜到的数字的深度 int _0; // 数字中0的位置// printf("%d\n", pos); if (pos == 123804765) &#123; printf("%d", dep[pos]); return 0; &#125; for (_0 = 0; _0 &lt; 9; _0++) &#123; // 搜索0的位置 if (!l(pos, _0)) break; &#125; for (int i = 0; i &lt; 4; i++) &#123; int p0 = _0; // 第一个要交换的数的下标 int p1 = _0+w(dir, i); // 第二个要交换的数的下标 int p2 = pos, p3; // p2是pos的拷贝, p3临时变量 // 判断交换是否合法 if (p0 &lt; 0 || p1 &lt; 0 || p0 &gt; 8 || p1 &gt; 8 || p0*p1 == 6 || p0*p1 == 30) continue; p3 = l(p2, p0); // t = a; p2 += (l(p2,p1) - l(p2,p0))*p10[p0]; // a = b; p2 += (p3 - l(p2,p0))*p10[p1]; // b = t; if (dep.count(p2)) continue; // 判断是否搜过 bfs.push(p2); // 入队 dep[p2] = cdep; // 更新深度 &#125; &#125; puts("Oh no! Where's my solution?");&#125; 教训 ⚠️不要无脑register，不然TLE自己负责！]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Internal」二元组dp - DP]]></title>
    <url>%2F2017%2F10%2F15%2Fpair-dp-notes%2F</url>
    <content type="text"><![CDATA[请从纯文本意识流中导出密码 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]]></content>
      <categories>
        <category>Internal</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见错误]]></title>
    <url>%2F2017%2F10%2F12%2Fmistakes%2F</url>
    <content type="text"><![CDATA[本文收集常见以及不常见的各种错误！ 错误 技术问题 溢出 运算溢出(爆int/long long) 中间结果溢出(如组合数) 循环结束条件溢出(少见，会导致TLE) 其它原因导致溢出(如越界) 错误答案 参见&quot;溢出&quot; 超时 参见&quot;溢出&quot; 循环结束条件有误 崩溃 数组开大(开小) 递归(dfs)结束条件有误 scanf没写取值符 优先级 线段树(i&lt;&lt;1)|1写成i&lt;&lt;1|1 底层问题 内存和UB 深浅拷贝 非技术问题 没写文件 编译错误 没建子文件夹 随时更新…]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>常见错误</tag>
      </tags>
  </entry>
</search>
