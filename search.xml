<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【置顶】ANNOUNCEMENT]]></title>
    <url>%2F9999%2F12%2F31%2FANNOUNCEMENT%2F</url>
    <content type="text"><![CDATA[本博客仅供本蒟蒻复习用，建议初学者不要看本蒟蒻的博客。 本博客因为各种咕咕咕一般一个月更新一次 我太弱了什么也不会&gt;_&lt; TODO LIST 本站地址: inf.tiger0132.tk 欢迎互链。 注意：因为我太弱了，所以博客中有一些渲染出错的数学公式 / Markdown代码，请见谅。 永久地址 咕咕咕 LIST 本蒟蒻常用代码头 编译器：gcc version 7.3.0 (Ubuntu 7.3.0-27ubuntu1~18.04) 代码中的表示 链接 备注 HEADER 1 https://www.luogu.org/paste/z2t5smdd 头文件&lt;bits/stdc++.h&gt;中抽取的部分内容 HEADER 2 https://www.luogu.org/paste/zsrsl7ck 头文件&lt;bits/stdc++.h&gt;的全部内容 HEADER 3 https://www.luogu.org/paste/nt7rzb09 快读和各种宏 1 2 3 4 5 6 7 \(\sum_{i=1}^{n} i^2 = \dfrac{n(n+1)(2n+1)}6\) \[\sum_{i=1}^{n} i^2 = \dfrac{n(n+1)(2n+1)}6\] abc ==a== ==abc== a1 a2 b1 b2 c a1b1 a1b2 a2b1 a2b2 123​```23333​``` \[ \begin{align*} &amp;(a+b)(c+d)\\ =&amp;a(c+d)+b(c+d)\\ =&amp;ac+ad+bc+bd \end{align*} \]]]></content>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 570D」Tree Requests - dsu on tree]]></title>
    <url>%2F2018%2F12%2F08%2Fcodeforces-570d%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 570D - Tree Requests。 给一棵树，每个点上有个字母。你要支持查询一个数对 \((x, y)\)，即查询 \(x\) 子树所有在原树深度为 \(y\) 的点上的字母是否可以重排成一个回文串。 解法 考虑离线。每到一个点，维护一个数组 cntx，其中 \(cntx_i\) 代表当前子树下，深度为 \(i\) 的所有点上的字母出现次数的奇偶性。 因为回文串中至多只有一个字符出现次数为奇数，所以 \(cntx_i\) 必须是 \(2^x\) 或 \(0\)。可以用 !(x &amp; (x-1)) 判断。 接下来考虑怎么维护。 最暴力的做法是直接暴力计算 \(cnt_x\)。复杂度 \(O(n^2)\) 肯定爆炸。我们来考虑优化这个东西。 我们发现，对于每一个点，可以钦定一个儿子，继承那个儿子统计出来的答案，然后把这棵子树剩下的部分合并到答案里。 因为二叉树下时间一定最接近上界，所以假设数据是二叉树，并且没有只含一个儿子的点。 令那个儿子的大小为 \(m\)，那么复杂度就是 \(T(n) = T(n) + T(m) + O(n - m)\)。 显然，\(m\) 越大越好。子树大小最大的儿子不就是重儿子么？ 所以复杂度为 \(T(n) = 2T\left(\dfrac n2\right) + O(n)\)。也就是 \(O(n \log n)\)。 这就是 dsu on tree。翻译叫树上启发式合并？ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;vector&gt;#include &lt;cstdio&gt;const int N = 5e5+55;struct edge &#123; int to, next; &#125; e[N&lt;&lt;1];int head[N], cnt;void addedge(int x, int y) &#123; e[++cnt] = (edge)&#123;y, head[x]&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y]&#125;; head[y] = cnt;&#125;struct node &#123; int x, *ans; &#125;;std::vector&lt;node&gt; q[N];int sz[N], dep[N], son[N], par[N];void dfs1(int x, int p, int d) &#123; sz[x] = 1; dep[x] = d; par[x] = p; int mx = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == p) continue; dfs1(nx, x, d+1); sz[x] += sz[nx]; if (sz[nx] &gt; mx) &#123; mx = sz[nx]; son[x] = nx; &#125; &#125;&#125;int cntx[N];bool vis[N];char rec[N];void dfs3(int x) &#123; cntx[dep[x]] ^= 1 &lt;&lt; (rec[x] - 'a'); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == par[x] || vis[nx]) continue; dfs3(nx); &#125;&#125;void dfs2(int x, int f) &#123; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == par[x] || nx == son[x]) continue; dfs2(nx, 0); &#125; if (son[x]) dfs2(son[x], 1), vis[son[x]] = 1; dfs3(x); vis[son[x]] = 0; for (int i = 0; i &lt; q[x].size(); i++) &#123; *q[x][i].ans = !(cntx[q[x][i].x] &amp; (cntx[q[x][i].x]-1)); &#125; if (!f) dfs3(x);&#125;int n, m, x, y;int ans[N];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;x); addedge(i, x); &#125; scanf("%s", rec+1); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;x, &amp;y); q[x].push_back((node)&#123;y, ans+i&#125;); &#125; dfs1(1, -1, 1); dfs2(1, 0); for (int i = 1; i &lt;= m; i++) &#123; puts(ans[i] ? "Yes" : "No"); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>Codeforces</tag>
        <tag>dsu on tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 P3372」线段树 1 - 标记永久化]]></title>
    <url>%2F2018%2F12%2F07%2Fluogu-3372%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P3372 - 线段树 1。 维护数列，支持区间加、区间和。 解法 这道题，我们可以使用树状数组、线段树、分块、带修莫队、CDQ 分治、暴力做。 这里我们用标记永久化线段树。 一般的线段树是用 Lazy Tag，即标记下放维护的区间打标记。 而标记永久化线段树中是没有标记下放这个操作的。 对于线段树中的每一个点，从根到该点的整条路径的标记都要计算在贡献里。 比如下面这棵线段树： 1234567+-------------------+| +4 |+---------+---------+| +2 | |+----+----+----+----+| +1 | | | |+----+----+----+----+ \(\mathbf{+1}\) 所对应的区间对答案的贡献是 \(sum + 7(r-l+1)\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;const int N = 1e5+15;struct node *newNode();struct node &#123; long long val, add; int l, r, mid; node *lc, *rc; void pushup() &#123; val = lc-&gt;val + rc-&gt;val; &#125; void build(int L, int R) &#123; val = 0; add = 0; l = L; r = R; mid = (l+r) &gt;&gt; 1; if (l == r) &#123; scanf("%lld", &amp;val); return; &#125; (lc = newNode())-&gt;build(l, mid); (rc = newNode())-&gt;build(mid+1, r); pushup(); &#125; void update(int L, int R, long long x) &#123; val += x * (R-L+1); if (L == l &amp;&amp; r == R) &#123; add += x; return; &#125; if (R &lt;= mid) lc-&gt;update(L, R, x); else if (mid &lt; L) rc-&gt;update(L, R, x); else lc-&gt;update(L, mid, x), rc-&gt;update(mid+1, R, x); &#125; long long query(int L, int R, long long tag = 0) &#123; if (L == l &amp;&amp; r == R) return val + tag * (r-l+1); tag += add; if (R &lt;= mid) return lc-&gt;query(L, R, tag); else if (mid &lt; L) return rc-&gt;query(L, R, tag); else return lc-&gt;query(L, mid, tag) + rc-&gt;query(mid+1, R, tag); &#125;&#125; pool[N&lt;&lt;2], *root, *null = pool;node *newNode() &#123; static node *ptr = pool+1; ptr-&gt;lc = ptr-&gt;rc = null; return ptr++;&#125;int n, m, op, x, y, z;int main() &#123; scanf("%d%d", &amp;n, &amp;m); (root = newNode())-&gt;build(1, n); while (m--) &#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op == 1) &#123; scanf("%d", &amp;z); root-&gt;update(x, y, z); &#125; else &#123; printf("%lld\n", root-&gt;query(x, y)); &#125; &#125;&#125; 永久化的标记就是值。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>线段树</tag>
        <tag>数据结构</tag>
        <tag>标记永久化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 600E」Lomsat gelral - 线段树合并]]></title>
    <url>%2F2018%2F12%2F06%2Fcodeforces-600e%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 600E - Lomsat gelral。 给你一棵树，每个点有点权。求每个子树中的所有众数的和。 如 1 2 1 3 2，答案为 \(1+2\)。 解法 区间众数。改个标记就可以套板子了。 考虑线段树合并。 对于每个点，开一棵动态开点权值线段树。 然后对于每一个非叶子节点，把所有子节点的线段树合并起来。 维护标记 考虑维护三个标记：max, sum, ans。分别代表指定值域的众数（任意一个）、出现次数和答案。 那么 pushup 可以这么写： 如果左儿子的 sum 更大，那么三个标记都从左儿子更新。 如果右儿子的 sum 更大，那么从右儿子更新。 如果相同，那么 ans 等于两个区间的 ans 的和，其它的从任意一个儿子更新。 合并 node *z = x-&gt;merge(node *y) 代表把 \(x\) 和 \(y\) 所在的子树合并到 \(z\)。且保证 \(x\) 和 \(y\) 的值域区间相同。 合并的流程如下： 如果 \(x\) 为空，返回 \(y\)。 如果 \(y\) 为空，返回 \(x\)。 如果值域里只有一个数，那么将 \(y\) 合并到 \(x\) 并返回 \(x\)。 否则对左右子树分别合并，并将返回值作为新的左右子树。 pushup 后返回 \(x\)。 具体实现如下： 代码 123456789101112struct node &#123; ... node *merge(node *rhs) &#123; if (this == null) return rhs; if (rhs == null) return this; if (l == r) &#123; max = ans = l; sum += rhs-&gt;sum; return this; &#125; lc = lc-&gt;merge(rhs-&gt;lc); rc = rc-&gt;merge(rhs-&gt;rc); pushup(); return this; &#125;&#125; 合并 \(\mathbf{n}\) 棵大小为 \(\mathbf{m}\) 的线段树的时间复杂度是 \(\mathbf{O(n + m \log n)}\)。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1e5+15;extern struct node *newNode(int l, int r), *null;struct node &#123; int max, sum, l, r, mid; long long ans; node *lc, *rc; void pushup() &#123; sum = std::max(lc-&gt;sum, rc-&gt;sum); if (lc-&gt;sum &gt;= rc-&gt;sum) &#123; max = lc-&gt;max; ans = lc-&gt;ans; if (lc-&gt;sum == rc-&gt;sum) ans += rc-&gt;ans; &#125; else &#123; max = rc-&gt;max; ans = rc-&gt;ans; &#125; &#125; void update(int x) &#123; if (l == r) &#123; max = ans = x; sum++; return; &#125; if (x &lt;= mid) &#123; if (lc == null) lc = newNode(l, mid); lc-&gt;update(x); &#125; else &#123; if (rc == null) rc = newNode(mid+1, r); rc-&gt;update(x); &#125; pushup(); &#125; node *merge(node *rhs) &#123; if (this == null) return rhs; if (rhs == null) return this; if (l == r) &#123; max = ans = l; sum += rhs-&gt;sum; return this; &#125; lc = lc-&gt;merge(rhs-&gt;lc); rc = rc-&gt;merge(rhs-&gt;rc); pushup(); return this; &#125;&#125; pool[int(3e6+36)], *null = pool;void init() &#123; null-&gt;max = 0xcfcfcfcf; &#125;node *newNode(int l = 1, int r = 1e5) &#123; static node *ptr = pool+1; ptr-&gt;lc = ptr-&gt;rc = null; ptr-&gt;l = l; ptr-&gt;r = r; ptr-&gt;mid = (l+r)&gt;&gt;1; return ptr++;&#125;struct edge &#123; int to, next; &#125; e[N&lt;&lt;1];int head[N], cnt;void addedge(int x, int y) &#123; e[++cnt] = (edge)&#123;y, head[x]&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y]&#125;; head[y] = cnt;&#125;long long ans[N];node *root[N];int c[N];void dfs(int x, int par) &#123; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == par) continue; dfs(nx, x); root[x]-&gt;merge(root[nx]); &#125; root[x]-&gt;update(c[x]); ans[x] = root[x]-&gt;ans;&#125;int n, x, y;int main() &#123; init(); scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", c+i); root[i] = newNode(); &#125; for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;x, &amp;y); addedge(x, y); &#125; dfs(1, -1); for (int i = 1; i &lt;= n; i++) &#123; printf("%I64d ", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>线段树</tag>
        <tag>线段树合并</tag>
        <tag>数据结构</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Violet」蒲公英 - 分块]]></title>
    <url>%2F2018%2F12%2F02%2Fluogu-4168%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P4168 - 蒲公英。 区间众数，强制在线。\(n \le 4 \times 10^4, m \le 5 \times 10^4\)。 解法 沿用 Ynoi 2019 T3 的做法。 但是这道题要求的是最小众数，而不是众数个数。 我们令 \(ans\) 为出现次数，\(out\) 为最小众数，即答案。 我们考虑多维护一个整块最小众数，然后在回答查询的更新 \(ans\) 时更新 \(out\)。 坑 如果一个数不能更新 \(ans\)，但是出现次数等于 \(ans\)，仍然是可以更新 \(out\) 的。 如果区间 \((l, r)\) 是空的，那么需要手动初始化 \(ans\) 和 \(out\)，否则可能会出现奇奇怪怪的锅。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 4e4+44, M = 2e2+22;int n, m, q, l, r, L, R, ans, out, a[N], _[N], cnt[M][M], mode[M][M], sum[N], lnk[N], S$;std::vector&lt;int&gt; idx[N];int main() &#123; scanf("%d%d", &amp;n, &amp;q); m = ceil(sqrt(n)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); _[i] = a[i]; &#125; std::sort(_+1, _+n+1); S$ = std::unique(_+1, _+n+1) -_- 1; for (int i = 1; i &lt;= n; i++) &#123; a[i] = std::lower_bound(_+1, _+S$+1, a[i]) - _; idx[a[i]].push_back(i); lnk[i] = idx[a[i]].size()-1; &#125; memset(mode, 0x3f, sizeof mode); for (int i = 1; i &lt;= m; i++) &#123; memset(sum, 0, sizeof sum); for (int j = i; j &lt;= m; j++) &#123; cnt[i][j] = cnt[i][j-1]; mode[i][j] = mode[i][j-1]; for (int k = lb(j); k &lt;= rb(j); k++) &#123; sum[a[k]]++; if (sum[a[k]] &gt; cnt[i][j] || (sum[a[k]] == cnt[i][j] &amp;&amp; a[k] &lt; mode[i][j])) &#123; cnt[i][j] = sum[a[k]]; mode[i][j] = a[k]; &#125; &#125; &#125; &#125; while (q--) &#123; scanf("%d%d", &amp;l, &amp;r); l = (l + out - 1) % n + 1; r = (r + out - 1) % n + 1; if (l &gt; r) std::swap(l, r); L = be(l); R = be(r); ans = cnt[L+1][R-1]; out = mode[L+1][R-1]; if (!ans) &#123; // 注意这里 ans = 1; out = a[l]; &#125; for (int i = l; i &lt;= std::min(rb(L), r); i++) &#123; int orig = lnk[i] + ans - 1; if (0 &lt;= orig &amp;&amp; orig &lt; idx[a[i]].size() &amp;&amp; // 还有这里 l &lt;= idx[a[i]][orig] &amp;&amp; idx[a[i]][orig] &lt;= r &amp;&amp; a[i] &lt; out) &#123; out = a[i]; &#125; while (lnk[i] + ans &lt; idx[a[i]].size() &amp;&amp; idx[a[i]][lnk[i] + ans] &lt;= r) &#123; out = a[i]; ans++; &#125; &#125; if (L != R) for (int i = lb(R); i &lt;= r; i++) &#123; int orig = lnk[i] - ans + 1; if (0 &lt;= orig &amp;&amp; orig &lt; idx[a[i]].size() &amp;&amp; // 以及这里 l &lt;= idx[a[i]][orig] &amp;&amp; idx[a[i]][orig] &lt;= r &amp;&amp; a[i] &lt; out) &#123; out = a[i]; &#125; while (lnk[i] - ans &gt;= 0 &amp;&amp; idx[a[i]][lnk[i] - ans] &gt;= l) &#123; out = a[i]; ans++; &#125; &#125; printf("%d\n", out = _[out]); // 忘记加上 "out = " 坑了我好久…… &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi 2019」Yuno loves sqrt technology III - 分块]]></title>
    <url>%2F2018%2F12%2F02%2Fynoi2019-t3%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P5048 - Yuno loves sqrt technology III。 维护一个序列，支持查询区间众数出现次数。强制在线。 \(n, m \le 5 \times 10^5\)。空间 64 Mb。 解法 区间众数显然是分块，但是一般的方法空间显然不能接受。 毒瘤 lxl 提出了一种线性空间的算法： 考虑维护 \([i, j]\) 整块的众数，以及每一个数出现的下标。 然后显然，区间众数肯定是 整块的众数 和 非整块中出现的数。 那么记当前答案为 \(ans\)。对于每一个数，如果它在整个区间中出现次数超过 \(ans\)，那么暴力 ans++。 出现次数超过 \(ans\) 怎么判断？ 对于每一个位置，维护一个 lnk，代表它在 vector 中的下标。 如果第 lnk[i] + ans 个数仍然 \(&lt; r\)，那么 ans 就需要更新了。 显然 \(ans\) 更新的次数是 \(O(\sqrt n)\) 的。所以这个做法的时间复杂度是 \(O(n \sqrt n)\)，空间是 \(O(n)\) 的。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 5e5+55, M = 1e3+13;int n, m, q, l, r, L, R, ans, a[N], _[N], cnt[M][M], sum[N], lnk[N], S$;std::vector&lt;int&gt; idx[N];int main() &#123; scanf("%d%d", &amp;n, &amp;q); m = ceil(sqrt(n)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); _[i] = a[i]; &#125; std::sort(_+1, _+n+1); S$ = std::unique(_+1, _+n+1) -_- 1; for (int i = 1; i &lt;= n; i++) &#123; a[i] = std::lower_bound(_+1, _+S$+1, a[i]) - _; idx[a[i]].push_back(i); lnk[i] = idx[a[i]].size()-1; &#125; for (int i = 1; i &lt;= m; i++) &#123; memset(sum, 0, sizeof sum); for (int j = i; j &lt;= m; j++) &#123; cnt[i][j] = cnt[i][j-1]; for (int k = lb(j); k &lt;= rb(j); k++) &#123; cnt[i][j] = std::max(cnt[i][j], ++sum[a[k]]); &#125; &#125; &#125; while (q--) &#123; scanf("%d%d", &amp;l, &amp;r); l ^= ans; r ^= ans; L = be(l); R = be(r); ans = cnt[L+1][R-1]; for (int i = l; i &lt;= std::min(rb(L), r); i++) &#123; while (lnk[i] + ans &lt; idx[a[i]].size() &amp;&amp; idx[a[i]][lnk[i] + ans] &lt;= r) ans++; &#125; if (L != R) for (int i = lb(R); i &lt;= r; i++) &#123; while (lnk[i] - ans &gt;= 0 &amp;&amp; idx[a[i]][lnk[i] - ans] &gt;= l) ans++; &#125; printf("%d\n", ans); &#125;&#125; 拓展 块大小一定要设成 ceil(sqrt(n))！ 这里好像有更好的区间众数科技：Range mode query, Wikipedia。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
        <tag>Ynoi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数颜色 - 带修莫队]]></title>
    <url>%2F2018%2F12%2F01%2Fbzoj-2120%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1903 - 数颜色、BZOJ 2120 - 数颜色、DarkBZOJ 2120 - 数颜色。 维护一个数列，支持两种操作：单点修改和查询区间内的数字种数。 解法 查询操作很容易让人想到莫队。 有修改怎么办？ 对于每个询问，记录三个数：左端点、右端点和时间戳。时间戳就是每个查询前的修改操作数。 比如样例的后两个操作时间戳为 \(1\)。 考虑原来的莫队写法： 1234while (l &lt; q[i].l) del(rec[l++]);while (l &gt; q[i].l) add(rec[--l]);while (r &lt; q[i].r) add(rec[++r]);while (r &gt; q[i].r) del(rec[r--]); 多了时间戳之后，我们可以这样写（tp 即 time point）： 12while (tp &lt; q[i].tp) modify(++tp);while (tp &gt; q[i].tp) modify(tp--); 即如果当前时间戳和目标不同，就把中间的修改操作做掉。 modify 函数实现如下： 123456void modify(int x) &#123; if (l &lt;= upd[x].x &amp;&amp; upd[x].x &lt;= r) &#123; del(rec[upd[x].x]); add(upd[x].y); &#125;&#125; 其中 rec 为原数组、upd 为记录修改操作的数组。 为了方便，我们 modify 完之后，将 rec[upd[x].x] 和 upd[x].y 交换一下。这样我们就不需要写两个函数了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N = 5e4+54, M = 1e6+16;int sz;struct node &#123; int l, r, tp, *ans; bool operator&lt;(const node&amp; rhs) const &#123; return l / sz == rhs.l / sz ? r / sz == rhs.r / sz ? tp &lt; rhs.tp : r &lt; rhs.r : l &lt; rhs.l; &#125;&#125; q[N];struct &#123; int x, y; &#125; upd[N];int rec[N], ans[N], tmp[M], lans, l, r;void a$(int x) &#123; lans += !tmp[x]++; &#125;void d$(int x) &#123; lans -= !--tmp[x]; &#125;void u$(int x) &#123; if (l &lt;= upd[x].x &amp;&amp; upd[x].x &lt;= r) &#123; d$(rec[upd[x].x]); a$(upd[x].y); &#125; std::swap(upd[x].y, rec[upd[x].x]);&#125;int n, m, _, cnt, tp, x, y;char op[2];int main() &#123; scanf("%d%d", &amp;n, &amp;_); sz = sqrt(n)*15; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec+i); &#125; while (_--) &#123; scanf("%s%d%d", op, &amp;x, &amp;y); if (*op ^ 'R') q[++m] = (node)&#123;x, y, cnt, ans+m&#125;; else upd[++cnt] = &#123;x, y&#125;; &#125; std::sort(q+1, q+m+1); l = 1; r = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &lt; q[i].l) d$(rec[l++]); while (l &gt; q[i].l) a$(rec[--l]); while (r &lt; q[i].r) a$(rec[++r]); while (r &gt; q[i].r) d$(rec[r--]); while (tp &lt; q[i].tp) u$(++tp); while (tp &gt; q[i].tp) u$(tp--); /*printf("query [%d, %d], timepoint = %d\nlans = %d: ", q[i].l, q[i].r, q[i].tp, lans); for (int j = 1; j &lt;= 15; j++) printf("%d ", tmp[j]); puts("");*/ *q[i].ans = lans; &#125; for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi 2017」由乃的玉米田 - 莫队]]></title>
    <url>%2F2018%2F11%2F28%2Fynoi2017-t1%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P3674 - 小清新人渣的本愿、DBZOJ 4801 - 由乃的玉米田。 维护一个数列，支持查询一个区间内： 是否有两个数差为 \(x\)。 是否有两个数和为 \(x\)。 是否有两个数乘积为 \(x\)。 解法 显然是莫队。 差为 \(x\) 可以用 bitset 直接维护。即 (p &amp; (p &lt;&lt; x)).any()。 因为 \(a+b = a-(-b)\)，所以和为 \(x\) 可以开两个 bitset 做。另外一个存相反数。 乘积直接大力 \(\sqrt c\) 搞。 时间复杂度上界：\(O(n \sqrt n + m \sqrt c)\)。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;algorithm&gt;#include &lt;bitset&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;const int N = 1e5+15;int sz;struct node &#123; int op, l, r, x, *ans; bool operator&lt;(const node&amp; rhs) const &#123; return l / sz == rhs.l / sz ? r &lt; rhs.r : l &lt; rhs.l; &#125;&#125; q[N];int n, m, l, r, ans[N];int rec[N], cnt[N];std::bitset&lt;N&gt; p, px;void add(int x) &#123; if (!cnt[x]++) p[x] = px[N-x] = 1; &#125;void del(int x) &#123; if (!--cnt[x]) p[x] = px[N-x] = 0; &#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); sz = std::sqrt(n); for (int i = 1; i &lt;= n; i++) scanf("%d", rec+i); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d%d", &amp;q[i].op, &amp;q[i].l, &amp;q[i].r, &amp;q[i].x); q[i].ans = ans+i; &#125; std::sort(q+1, q+m+1); l = 1; r = 0; for (int i = 1; i &lt;= m; i++) &#123; while (l &lt; q[i].l) del(rec[l++]); while (l &gt; q[i].l) add(rec[--l]); while (r &lt; q[i].r) add(rec[++r]); while (r &gt; q[i].r) del(rec[r--]); switch (q[i].op) &#123; case 1: *q[i].ans = (p &amp; (p &lt;&lt; q[i].x)).any(); break; case 2: *q[i].ans = (p &amp; (px &gt;&gt; (N-q[i].x))).any(); break; case 3: for (int j = 1; j*j &lt;= q[i].x; j++) &#123; if (q[i].x % j == 0 &amp;&amp; p[j] &amp;&amp; p[q[i].x / j]) &#123; *q[i].ans = 1; break; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= m; i++) puts(ans[i] ? "yuno" : "yumi");&#125; 总结 莫队套 bitset 题好像挺少的？Ynoi 里只会做莫队 + bitset]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[帮帮蒟蒻吧！]]></title>
    <url>%2F2018%2F11%2F26%2Fhelp-me-please%2F</url>
    <content type="text"><![CDATA[本蒟蒻积攒了一些 idea，可是因为我太菜，做不出。现在在这里征解。 如果有思路可以在下面评论。 Graph’s Reality II 题意 定义一张平面图是现实的，当且仅当这张图有一种方法，可以将其画在二维平面上，且边之间不重合、不交叠，而且边的长度等于边权。并且图中的点在平面上表示为几何上的点。 现在给你一张平面图，问你这张图是否现实。 \(n \le 10^5, m \le 3n-6\)。 简易版解法 如果这张图有自环或重边，那么肯定不行。 如果没有边权限制，且满足上一条限制，那么肯定可以。 未解决的问题 怎么做带边权限制的？ 可以考虑用三角形不等式搞，但是需要找到图中所有的环？感觉是 NP 的。 送你一张有向图 题意 给一张有向图，你需要做正好 \(k\) 次操作，每次操作反转一条边。可以对一条边多次操作。 求最优操作下，\(s\) 到 \(t\) 的路径长度的最小值是多少。 保证图无负权。 \(n \le 10^4, k \le 10^9\)。 简易版解法 首先特判链上的情况。 因为最短路 \(=\) 最短简单路。所以有一些边肯定走不到。可以考虑将剩下的操作次数浪费在那些走不到的边上。 然后就可以缩小 \(k\) 的范围了。 然后就是个裸的分层图了。 未解决的问题 但是它过不了 \(n \le 10^4\)。 有向图可达性 题意 给你一张有向图，每次查询两个点 \(x, y\)，问你能不能从 \(x\) 到达 \(y\)。 \(n, m, q \le 10^5\)。 std::tr1::tree 题意 求使平面上给定点集两两点连通的最短长度。 \(n \le 100\)。 完全没有思路。我大概会做 \(n \le 3\)？ 数列预测 3 题意 给你一个数列的前 \(n\) 项。已知这个数列的通项公式是不超过 \(n-1\) 次的，求这个数列接下来的 \(m\) 项。输出对 \(998244353\) 取模。 \(n, m \le 10^5\)。 毫无思路，只会 \(O(nm)\)……]]></content>
      <categories>
        <category>自闭</category>
      </categories>
      <tags>
        <tag>自闭</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[POI×N 2018 自闭记]]></title>
    <url>%2F2018%2F11%2F23%2Fnoip2018-diary%2F</url>
    <content type="text"><![CDATA[NOIp 爆零了，自闭自闭。 Day \((-\infty, 0]\) 在洛谷和 LOJ 上复习了一些模板，比如 Splay、Z Algorithm 等等……顺便学了下分块入门。 可以的，复习的都没考 Day 1 公布解压密码的时候发现没带眼镜，看不清 &gt;_&lt; 密码好像是 Fei2Xue@Lian$Tian!。 后来查了下跟金庸有关？ 一看题发现 T1 是积木大赛？不对不对，NOIp 怎么会考原题呢……首尾相连肯定是指的环…… 然后发现如果是环，样例应该是 \(7\)。于是写了个链的差分，发现过了大数据。 做完之后发现已经过了一个小时了。 辣鸡 €€£，坑我时间，降我分数。 T2 本来以为是要解扩欧方程，然后发现值域炒鸡小，发现是个复杂度为 \(O(Tn \text{值域})\) 的傻逼题。转移类似于完全背包。 T3 想到了一个树形 DP 的做法，但是转移貌似很麻烦……发现没时间了，只好打一个二叉树的暴力。期望得分：链 + 二叉树 = \(65pts\)。 Day 1 期望得分：100 + 100 + 65 = 265pts。 Day 1.5 改革开放 \(40\) 年？emmm T1 T2 ZZ 题，\(30\) min 秒了。 T3 显然 DP。写了个 \(O(n m^2)\) 的 DP，然后一直没调出来。 只有两个半小时的时候，我弃疗 T3 去做 T4，然后一个小时用树哈希做完了。 最后发现 T3 间隔设小了，改好之后过了。 期望得分：100 + 100 + 100 + 100 = 400pts。 Day 1.75 晚上复习了下 Dinic 和 Splay 板子，水了水群。 Day 2 解压密码 %xiao#SHU!shen9XIA。 T1 题面真鬼畜，绕了半个小时……然后发现对于基环树的情况，直接枚举断一条边就好了，并不想写判环。感觉复杂度 \(O(n^2\log n)\) 是对的。 T2 感觉是奇怪的 DP？写了个奇怪的暴力打表找规律，就像这样： 暴力代码 1234567891011121314151617181920/* abcdefghijklmo*/#define f(x) x &amp;&amp; xfor (int a = 0; a &lt; 2; a++)for (int b = 0; b &lt; 2; b++)...for (int o = 0; o &lt; 2; o++) &#123; int A = a * 16; int D = d * 16; int B = b * 8; ... int O = o; if (A+B+C+G+K &lt;= f(A+B+F+G+K) &lt;= ... &lt;= f(D+H+L+M+O)) ans++;&#125; 然后推出 \(2, 3\) 的规律。\(65\) 分走人。 T3 动态 DP 模板题。void* mmap(void* start,size_t length, int prot, int flags, int fd, off_t offset);。打了个 \(44\) 分走人。 比赛最后我写了个 T2 爆搜验证公式，貌似推出了 \(n = 4\)？反正没分 Day 2 期望得分：100 + 65 + 44 = 209pts。 Day 2.5 我普及 T4 的树哈希貌似被 G♂LX 用链叉了？但是我自己的程序还是过了 2333。 听说 T4 正解 \(O(n \log n)\) 而且 \(3 \text{min}\) 就能写出来？（爆搜）技不如人甘拜下风。 普及 T1 卡各种读入？scanf(&quot;%[^\n]&quot;); 大法好！虽然其实怎么读入都不会被卡 普及 T2 洛谷数据卡 INF？不管不管。 人是死的，程序是活的，出题人是懒的。 T3 其他人都是写的 \(O(n^2 m)​\)？不管不管。 提高 D2T1 会被卡？不管不管。毕竟 €€£ 今年租了北航的少爷机用于骗取上百万的报名费，而且据说少爷机跑得比洛谷评测机快？emmmm 赛后 普及组期望得分：100 + 100 + 100 + 100 = 400pts。 普及组自测得分：100 + 80 + 100 + 100 = 380pts。 普及组实际得分：100 + 100 + 100 + 100 = 400pts。 提高组期望得分：100 + 100 + 65 + 100 + 65 + 44 = 474pts。 提高组自测得分：100 + 100 + 45 + 88 + 65 + 0 = 398pts。 提高组实际得分：100 + 100 + 45 + 100 + 65 + 0 = 410pts。 这次比赛主要的问题在于 D2T3 爆零了，没有达到题题拿分的目标。 分数是同省同届 rk2，海星吧。虽然 D2T3 没爆零就 rk1 了 还有就是 D1T3 炸掉了 \(20\) 分，貌似是二叉树出锅了。 吐槽 春春幼儿园园长竟然是一位道路工程师！ 小凯的疑惑时隔一年加强后重出江湖！ 飞车的葛老师来到了 C 城！ 旅行的小 Y 为何无故倒退？ 毒瘤打表题究竟从何而来？ 动态 DP 又是何方神圣？ 欢迎来到第二十四届 NOIp！ 试探究 \(S_{NOIP}\)、\(S_{\triangle POI}\) 与 \(N\) 的数量关系，并证明你的结论。 \(NOIP = POI \times N\)。 其它的东西 输入密码以查看内容 Incorrect Password! No content to display! U2FsdGVkX19rYxAWz1W59QHdJiak2EORQk3u5BEusURU5qFCmiqIs/pJ611A+Se0CSu3jMVSb+/j+0685RXSlfciMbvCt+9uzCQpThyCPeplXH/QPtSBi5Skil+gvyBKxM3evbmJWbKC4onqPhtL6auuOWEuLzmFsNR+3cW8x74yjeVv8W6esgOKAhJHHPWAmntZnzjvHL6mDBIrpTr/8SNpC0IDf+U5+3bEatd45t45aS9KZHEVZwKKDb7H2Sii]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>NOIp</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构」LCT (TBC)]]></title>
    <url>%2F2018%2F11%2F22%2Flink-cut-tree-notes%2F</url>
    <content type="text"><![CDATA[简介 LCT 是动态树的一种，可以维护森林上的动态加边、删边、换根、链上信息等操作。 实链剖分 （还是觉得「Preferred *」比较形象） 实链剖分就是随便定一个儿子作为实儿子（可以不定），然后可以虚实动态变化的一个东西。 存储方式 LCT 实际上就是用若干棵 Splay 维护一棵树（森林）的所有实链。 对于实链，我们将包含的点存储在 Splay 中。（不一定要用 Splay，貌似 FHQ Treap 也可以？） 具体存储方式是：Splay 的中序遍历按实链中点深度递增的顺序存储。 为了方便后面的操作，我们规定，对于连接实链的虚边，我们将儿子所在的 Splay 的父亲单向设置为父亲节点。即认父不认子。 接下来我们来考虑 LCT 支持的各种操作。 12#define l(x) ch[x][0]#define r(x) ch[x][1] 基本操作 Access \(\operatorname{access}(x)\)：将根与 \(x\) 合并到同一个 Splay 中。 实现方法显然是将根与 \(x\) 的这条链强制设为实链。 所以我们要把根与 \(x\) 之间的若干棵 Splay 合并成一棵。 现在，令 \(x\) 为当前操作的节点，\(y\) 为要合并的 Splay 的根节点。 显然，\(y\) 的父亲为 \(x\) 当前所在实链的某个点。 将 \(x\) splay 到根。 把 \(x\) 的实儿子变成虚的。 即：删除 \(x\) 的右儿子。 把 \(y\) 所在的实链合并到 \(x\) 的下面。 即：将 \(x\) 的右儿子设为 \(y\)。（因为 \(y\) 已经是根了） 如果 \(x\) 不是根，那么\(y\) 设为 \(x\)，\(x\) 设为 \(x\) 的父亲。 看起来很麻烦，事实上很好写： 1void access(int x) &#123; for (int i = 0; x; x = par[i = x]) splay(x), r(x) = i, pushup(x); &#125; Makeroot \(\operatorname{makeroot}(x)\)：将 \(x\) 设为 LCT 的根。 实现方法：将 \(x\) 和原根放在同一条实链里，然后钦定 \(x\) 为实链的链顶。 因为 \(\operatorname{access}(x)\) 之后，\(x\) 会在链底。那么 \(\operatorname{splay}(x)\) 之后，\(x\) 一定没有右子树。 然后翻转整棵 Splay 即可。 \(\operatorname{makeroot} = \operatorname{access} + \operatorname{splay} + \operatorname{reverse}\)。 1void makeroot(int x) &#123; access(x); splay(x); rev[x] ^= 1; &#125; Findroot \(\operatorname{findroot}(x)\)：找到 \(x\) 所在 LCT 的根。 实现方法：将 \(x\) 和原根放在同一条实链里，然后找到实链的链顶。 类似于 \(\operatorname{makeroot}\)，只是最后不需要 \(\operatorname{reverse}\)，而是找第一个元素而已。 1int findroot(int x) &#123; access(x); splay(x); while (l(x)) x = l(x); return x; &#125; Split \(\operatorname{split}(x, y)\)：将 \(x\) 到 \(y\) 的链放在同一棵 Splay 中。 实现方法：先 \(\operatorname{makeroot}(x)\)，再 \(\operatorname{access}(y)\)。 为了方便维护，该 Splay 以 \(y\) 为根。所以还需 \(\operatorname{splay}(y)\)。 \(\operatorname{split} = \operatorname{makeroot} + \operatorname{access} + \operatorname{splay}\)。 1void split(int x, int y) &#123; makeroot(x); access(y); splay(y); &#125; Cut \(\operatorname{cut}(x, y)\)：断掉 \(x\) 和 \(y\) 之间的边。 实现方法：首先 \(\operatorname{split}(x, y)\)。因为此时 \(y\) 是 Splay 的根，\(x\) 是原树的根，所以 \(x\) 深度一定比 \(y\) 小 \(1\)。 即：\(y\) 的左儿子是 \(x\)。 某些毒瘤题不保证边存在，所以记得判断一下。 1void cut(int x, int y) &#123; split(x, y); if (l(y) == x) l(y) = par[x] = 0; &#125; Link \(\operatorname{link}(x, y)\)：在 \(x\) 和 \(y\) 之间连边。 我们考虑在 \(x\) 和 \(y\) 之间连一条虚边。并且 \(x\) 的父亲指向 \(y\)。 1void link(int x, int y) &#123; makeroot(x); if (findroot(y) != x) p[x] = y; &#125; 和普通 Splay 的差异 LCT 中的 Splay 和普通 Splay 有着以下的差异： 增加一个 notroot 操作，判断一个点是不是当前 Splay 的根。 根据认父不认子的性质，我们可以写出下面的代码： 1bool notroot(int x) &#123; return l(p[x]) == x || r(p[x]) == x; &#125; rotate 的时候，要特判 \(y\) 是根的情况。代码如下： 1234567void rotate(int x) &#123; int y = par[x], z = par[y], k = chk(x), w = ch[x][!k]; ch[y][k] = w; par[w] = y; if (nr(y)) ch[z][chk(y)] = x; par[x] = z; ch[x][!k] = y; par[y] = x; pushup(y); pushup(x);&#125; splay 的时候，要沿着整条链从上到下先 pushdown 一遍。因为 LCT 打标记时没有下传干净（或者说完全没有下传）。并且要使用 notroot 操作重写判断部分。 1234567891011void splay(int x) &#123; static int top = 0; st[++top] = x; for (int i = x; nr(i); i = par[i]) st[++top] = par[i]; while (top) pushdown(st[top--]); while (notroot(x)) &#123; int y = par[x]; if (notroot(y)) rt(chk(x) == chk(y) ? y : x); rotate(x); &#125;&#125; 结束了？结束了。 模板题 Link Cut Tree 题意 维护一棵树，支持连边、断边、单点修改、链上异或和。 解法 模板题。直接维护即可。 代码 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define l(x) ch[x][0]#define r(x) ch[x][1]const int N = 3e5+35;int n, m, _[N];struct LCT &#123; int ch[N][2], p[N], v[N], r[N], st[N]; void up(int x) &#123; v[x] = v[l(x)] ^ v[r(x)] ^ _[x]; &#125; bool c(int x) &#123; return r(p[x]) == x; &#125; void pd(int x) &#123; if (!r[x]) return; std::swap(l(x), r(x)); r[l(x)] ^= 1; r[r(x)] ^= 1; r[x] = 0; &#125; bool nr(int x) &#123; return l(p[x]) == x || r(p[x]) == x; &#125; void rt(int x) &#123; int y = p[x], z = p[y], k = c(x), w = ch[x][!k]; ch[y][k] = w; p[w] = y; if (nr(y)) ch[z][c(y)] = x; p[x] = z; ch[x][!k] = y; p[y] = x; up(y); up(x); &#125; void sp(int x) &#123; static int top = 0; st[++top] = x; for (int i = x; nr(i); i = p[i]) st[++top] = p[i]; while (top) pd(st[top--]); while (nr(x)) &#123; int y = p[x]; if (nr(y)) rt(c(x) == c(y) ? y : x); rt(x); &#125; &#125; void ac(int x) &#123; for (int i = 0; x; x = p[i = x]) sp(x), r(x) = i, up(x); &#125; void mr(int x) &#123; ac(x); sp(x); r[x] ^= 1; &#125; int fr(int x) &#123; ac(x); sp(x); while (l(x)) x = l(x); return x; &#125; void spl(int x, int y) &#123; mr(x); ac(y); sp(y); &#125; void cut(int x, int y) &#123; spl(x, y); if (l(y) == x) l(y) = p[x] = 0; &#125; void link(int x, int y) &#123; mr(x); if (fr(y) != x) p[x] = y; &#125;&#125; lct;int op, x, y;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) scanf("%d", _+i), lct.v[i] = _[i]; while (m--) &#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); switch (op) &#123; case 0: lct.spl(x, y); printf("%d\n", lct.v[y]); break; case 1: lct.link(x, y); break; case 2: lct.cut(x, y); break; case 3: lct.sp(x); _[x] = y; lct.up(x); &#125; &#125;&#125; Tree II 题意 维护一棵树，支持链上加、连边、断边、链上乘、链上和。 解法 LCT 模板 + 线段树 2。 代码 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;stack&gt;#define int unsigned#define l(x) ch[x][0]#define r(x) ch[x][1]const int N = 1e5+15, P = 51061;int n, m, _[N];struct LCT &#123; int ch[N][2], p[N], v[N], a[N], m[N], s[N], r[N], sz[N], st[N]; inline void up(int x) &#123; s[x] = (s[l(x)] + s[r(x)] + v[x]) % P; sz[x] = sz[l(x)] + sz[r(x)] + 1; &#125; inline void add(int x, int y) &#123; (s[x] += y * sz[x]) %= P; (v[x] += y) %= P; (a[x] += y) %= P; &#125; inline void mul(int x, int y) &#123; (s[x] *= y) %= P; (v[x] *= y) %= P; (a[x] *= y) %= P; (m[x] *= y) %= P; &#125; inline bool c(int x) &#123; return r(p[x]) == x; &#125; inline void pd(int x) &#123; if (r[x]) &#123; std::swap(l(x), r(x)); r[l(x)] ^= 1; r[r(x)] ^= 1; &#125; mul(l(x), m[x]); mul(r(x), m[x]); add(l(x), a[x]); add(r(x), a[x]); a[x] = r[x] = 0; m[x] = 1; &#125; inline bool nr(int x) &#123; return l(p[x]) == x || r(p[x]) == x; &#125; inline void rt(int x) &#123; int y = p[x], z = p[y], k = c(x), w = ch[x][k^1]; ch[y][k] = w; p[w] = y; if (nr(y)) ch[z][c(y)] = x; p[x] = z; ch[x][k^1] = y; p[y] = x; up(y); up(x); &#125; inline void sp(int x) &#123; static int top = 0; st[++top] = x; for (int i = x; nr(i); i = p[i]) st[++top] = p[i]; while (top) pd(st[top--]); while (nr(x)) &#123; int y = p[x]; if (nr(y)) rt(c(x) == c(y) ? y : x); rt(x); &#125; &#125; inline void ac(int x) &#123; for (int i = 0; x; x = p[i = x]) sp(x), r(x) = i, up(x); &#125; inline void mr(int x) &#123; ac(x); sp(x); r[x] ^= 1; &#125; inline int fr(int x) &#123; ac(x); sp(x); while (l(x)) x = l(x); return x; &#125; inline void spl(int x, int y) &#123; mr(x); ac(y); sp(y); &#125; inline void cut(int x, int y) &#123; spl(x, y); if (l(y) == x) p[x] = l(y) = 0; &#125; inline void link(int x, int y) &#123; mr(x); if (fr(x) != fr(y)) p[x] = y; &#125;&#125; lct;int x, y, z, w;char op[2];signed main() &#123; scanf("%u%u", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) lct.v[i] = lct.m[i] = lct.sz[i] = lct.s[i] = 1; for (int i = 1; i &lt; n; i++) &#123; scanf("%u%u", &amp;x, &amp;y); lct.link(x, y); &#125; while (m--) &#123; scanf("%s%u%u", op, &amp;x, &amp;y); switch (*op) &#123; case '+': scanf("%u", &amp;z); lct.spl(x, y); lct.add(y, z); break; case '-': scanf("%u%u", &amp;z, &amp;w); lct.cut(x, y); lct.link(z, w); break; case '*': scanf("%u", &amp;z); lct.spl(x, y); lct.mul(y, z); break; case '/': lct.spl(x, y); printf("%u\n", lct.s[y]); break; &#125; &#125;&#125; 弹飞绵羊 题意 维护一棵树，支持换父亲、查深度。 解法 深度就是根到当前点的链的长度。 裸的 LCT。 代码 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define l(x) ch[x][0]#define r(x) ch[x][1]const int N = 2e5+25;int n, m;struct LCT &#123; int ch[N][2], p[N], sz[N], r[N], st[N]; void up(int x) &#123; sz[x] = sz[l(x)] + sz[r(x)] + 1; &#125; bool c(int x) &#123; return r(p[x]) == x; &#125; void pd(int x) &#123; if (!r[x]) return; std::swap(l(x), r(x)); r[l(x)] ^= 1; r[r(x)] ^= 1; r[x] = 0; &#125; bool nr(int x) &#123; return l(p[x]) == x || r(p[x]) == x; &#125; void rt(int x) &#123; int y = p[x], z = p[y], k = c(x), w = ch[x][!k]; ch[y][k] = w; p[w] = y; if (nr(y)) ch[z][c(y)] = x; p[x] = z; ch[x][!k] = y; p[y] = x; up(y); up(x); &#125; void sp(int x) &#123; static int top = 0; st[++top] = x; for (int i = x; nr(i); i = p[i]) st[++top] = p[i]; while (top) pd(st[top--]); while (nr(x)) &#123; int y = p[x]; if (nr(y)) rt(c(x) == c(y) ? y : x); rt(x); &#125; &#125; void ac(int x) &#123; for (int i = 0; x; x = p[i = x]) sp(x), r(x) = i, up(x); &#125; void mr(int x) &#123; ac(x); sp(x); r[x] ^= 1; &#125; int fr(int x) &#123; ac(x); sp(x); while (l(x)) x = l(x); return x; &#125; void spl(int x, int y) &#123; mr(x); ac(y); sp(y); &#125; void cut(int x, int y) &#123; spl(x, y); if (l(y) == x) l(y) = p[x] = 0; &#125; void link(int x, int y) &#123; mr(x); if (fr(y) != x) p[x] = y; &#125;&#125; lct;int op, x, y;int rec[N];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) lct.sz[i] = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec+i); if (i + rec[i] &gt; n) rec[i] = n+1-i; lct.link(i, i + rec[i]); &#125; for (scanf("%d", &amp;m); m--; ) &#123; scanf("%d%d", &amp;op, &amp;x); x++; if (op == 1) &#123; lct.spl(x, n+1); printf("%d\n", lct.sz[n+1] - 1); &#125; else &#123; scanf("%d", &amp;y); lct.cut(x, x + rec[x]); rec[x] = y; if (x + rec[x] &gt; n) rec[x] = n+1-x; lct.link(x, x + rec[x]); &#125; &#125;&#125; 洞穴勘测 题意 维护一棵树，支持加边、断边、连通性。 解法 模板题。 代码 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;algorithm&gt;#include &lt;cstdio&gt;#define l(x) ch[x][0]#define r(x) ch[x][1]const int N = 1e4+14;int ch[N][2], p[N], r[N], st[N];bool c(int x) &#123; return r(p[x]) == x; &#125;void pd(int x) &#123; if (!r[x]) return; std::swap(l(x), r(x)); r[l(x)] ^= 1; r[r(x)] ^= 1; r[x] = 0;&#125;bool nr(int x) &#123; return l(p[x]) == x || r(p[x]) == x; &#125;void rt(int x) &#123; int y = p[x], z = p[y], k = c(x), w = ch[x][!k]; ch[y][k] = w; p[w] = y; if (nr(y)) ch[z][c(y)] = x; p[x] = z; ch[x][!k] = y; p[y] = x;&#125;void sp(int x) &#123; static int top = 0; st[++top] = x; for (int i = x; nr(i); i = p[i]) st[++top] = p[i]; while (top) pd(st[top--]); while (nr(x)) &#123; int y = p[x]; if (nr(y)) rt(c(x) == c(y) ? y : x); rt(x); &#125;&#125;void ac(int x) &#123; for (int i = 0; x; x = p[i = x]) sp(x), r(x) = i; &#125;void mr(int x) &#123; ac(x); sp(x); r[x] ^= 1; &#125;int fr(int x) &#123; ac(x); sp(x); while (l(x)) x = l(x); return x; &#125;void spl(int x, int y) &#123; mr(x); ac(y); sp(y); &#125;void cut(int x, int y) &#123; spl(x, y); l(y) = p[x] = 0; &#125;void link(int x, int y) &#123; mr(x); p[x] = y; &#125;int n, m, x, y;char buf[' '];int main() &#123; for (scanf("%*d%d", &amp;m); m--; ) &#123; scanf("%s%d%d", buf, &amp;x, &amp;y); switch (*buf) &#123; case 'C': link(x, y); break; case 'D': cut(x, y); break; case 'Q': puts(fr(x) == fr(y) ? "Yes" : "No"); &#125; &#125;&#125; TBC]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>LCT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题目汇总」数列分块入门]]></title>
    <url>%2F2018%2F10%2F30%2Fsequnce-partition-problems%2F</url>
    <content type="text"><![CDATA[这里是 LOJ 上「数列分块入门」系列题目的汇总。 数列分块入门 1 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及区间加法，单点查值。 解法 树状数组。 考虑将数列分成 \(k\) 块，并给每个块打上块内加的标记。 区间加时对整块直接加，对左右两端暴力加。时间复杂度 \(O(k +\dfrac nk)\)。 单点查询时将区间标记加上单点值输出即可。 显然 \(k\) 取 \(\sqrt n\) 时复杂度最优，即 \(O(n \sqrt n)\)。 代码 代码12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, 0x3f3f3f3f)const int N = 50004, M = 250;int n, m, op, l, r, c, a[N], add[M];int main() &#123; scanf("%d", &amp;n); m = sqrt(n); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%d", &amp;op, &amp;l, &amp;r, &amp;c); int L = be(l), R = be(r); if (!op) &#123; for (int i = l; i &lt;= std::min(rb(L), r); i++) a[i] += c; if (L != R) for (int i = lb(R); i &lt;= r; i++) a[i] += c; for (int i = L+1; i &lt; R; i++) add[i] += c; &#125; else &#123; printf("%d\n", a[r] + add[R]); &#125; &#125;&#125; 数列分块入门 2 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及区间加法，询问区间内小于某个值 \(x\) 的元素个数。 双倍经验：洛谷 P2801 - 教主的魔法。 解法 注意到整体加对顺序没有影响，我们考虑块内排序。 开一个数组 \(b\)，存每一段排完序后的值。 区间加时对整块直接加，对左右两端暴力加完后重新排序。时间复杂度 \(O(k \log k +\dfrac nk)\)。 查询 rank 时对整块 lower_bound，左右两端暴力计算。时间复杂度 \(O(k + \dfrac nk \cdot \log k)\)。 此时 \(k\) 取 \(???\) 时复杂度最优，即 \(O(???)\)。 块大小貌似比 \(\sqrt n\) 要稍微大一些？但是 \(k\) 与 \(\sqrt n\) 的差随着 \(n\) 的增大越来越小了，就当它是 \(\sqrt n\) 就好了。 可以通过均值不等式计算出更优的分块大小，就不展开讨论了。 数列分块入门, hzwer UPD 2：貌似是 \(\sqrt{n \log n}\)？但是不仅跑得慢，而且怪怪的…… 代码 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 50004, M = 250;int n, m, op, l, r, c, a[N], b[N], add[M];int main() &#123; scanf("%d", &amp;n); m = sqrt(n); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); memcpy(b, a, sizeof a); for (int i = 1; i &lt;= be(n); i++) &#123; int L = (i-1)*m + 1; int R = std::min(i*m, n); std::sort(b+L, b+R+1); &#125; for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%d", &amp;op, &amp;l, &amp;r, &amp;c); int L = be(l), R = be(r); if (!op) &#123; for (int i = l; i &lt;= std::min(rb(L), r); i++) a[i] += c; if (L != R) for (int i = lb(R); i &lt;= r; i++) a[i] += c; for (int i = L+1; i &lt; R; i++) add[i] += c; memcpy(b + lb(L), a + lb(L), (rb(L) - rb(L-1)) &lt;&lt; 2); memcpy(b + lb(R), a + lb(R), (rb(R) - rb(R-1)) &lt;&lt; 2); std::sort(b + lb(L), b + rb(L)+1); std::sort(b + lb(R), b + rb(R)+1); &#125; else &#123; c = c*c; int lans = 0; for (int i = l; i &lt;= std::min(rb(L), r); i++) lans += a[i] + add[L] &lt; c; if (L != R) for (int i = lb(R); i &lt;= r; i++) lans += a[i] + add[R] &lt; c; for (int i = L+1; i &lt; R; i++) &#123; if (b[lb(i)] + add[i] &gt; c) continue; if (b[rb(i)] + add[i] &lt; c) &#123; lans += rb(i) - lb(i) + 1; continue; &#125; lans += std::lower_bound(b+lb(i), b+lb(i+1), c-add[i]) - b-lb(i); &#125; printf("%d\n", lans); &#125; &#125;&#125; 数列分块入门 3 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及区间加法，询问区间内小于某个值 \(x\) 的前驱（比其小的最大元素）。 解法 解法类似于「数列分块入门 2」，考虑块内排序。 查询前驱时对每一块的前驱和左右两端所有大于 \(\mathbf{x}\) 的数取 \(\max\)。 时空复杂度同上题。 代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 100005, M = 1003;int n, m, op, l, r, c, a[N], b[N], add[M];int main() &#123; scanf("%d", &amp;n); m = sqrt(n); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); memcpy(b, a, sizeof a); for (int i = 1; i &lt;= be(n); i++) &#123; std::sort(b+lb(i), b+rb(i)+1); &#125; for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%d", &amp;op, &amp;l, &amp;r, &amp;c); int L = be(l), R = be(r); if (!op) &#123; for (int i = l; i &lt;= std::min(rb(L), r); i++) a[i] += c; if (L != R) for (int i = lb(R); i &lt;= r; i++) a[i] += c; for (int i = L+1; i &lt; R; i++) add[i] += c; memcpy(b + lb(L), a + lb(L), (rb(L) - rb(L-1)) &lt;&lt; 2); memcpy(b + lb(R), a + lb(R), (rb(R) - rb(R-1)) &lt;&lt; 2); std::sort(b + lb(L), b + rb(L)+1); std::sort(b + lb(R), b + rb(R)+1); &#125; else &#123; int lans = -1; for (int i = l; i &lt;= std::min(rb(L), r); i++) &#123; if (a[i] + add[L] &lt; c) lans = std::max(lans, a[i] + add[L]); &#125; if (L != R) for (int i = lb(R); i &lt;= r; i++) &#123; if (a[i] + add[R] &lt; c) lans = std::max(lans, a[i] + add[R]); &#125; for (int i = L+1; i &lt; R; i++) &#123; int *p = std::lower_bound(b+lb(i), b+rb(i)+1, c-add[i]); if (p == b+lb(i) || (p == b+rb(i)+1 &amp;&amp; *(p-1) &gt;= c-add[i])) continue; lans = std::max(lans, *--p + add[i]); &#125; printf("%d\n", lans); &#125; &#125;&#125; 坑点 lower_bound 非常毒瘤：如果所有数都比它大，它会返回第一个元素的指针；如果只有最后一个数比他大，它会返回最后一个数的后一个数的指针。判断起来十分蛋疼。 数列分块入门 4 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及区间加法，区间求和。 解法 树状数组。 解法类似于「数列分块入门 1」，只是要多维护一个标记，代表块内元素和。 代码 代码123456789101112131415161718192021222324252627282930313233343536#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 5e4+54, M = 3e2+32;long long a[N], sum[M], add[M];int n, m, op, l, r, c;int main() &#123; scanf("%d", &amp;n); m = sqrt(n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", a+i); sum[be(i)] += a[i]; &#125; for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%d", &amp;op, &amp;l, &amp;r, &amp;c); int L = be(l), R = be(r); if (!op) &#123; for (int i = l; i &lt;= std::min(rb(L), r); i++) a[i] += c, sum[L] += c; if (L != R) for (int i = lb(R); i &lt;= r; i++) a[i] += c, sum[R] += c; for (int i = L+1; i &lt; R; i++) add[i] += c; &#125; else &#123; long long lans = 0; for (int i = l; i &lt;= std::min(rb(L), r); i++) (lans += a[i] + add[L]) %= c+1; if (L != R) for (int i = lb(R); i &lt;= r; i++) (lans += a[i] + add[R]) %= c+1; for (int i = L+1; i &lt; R; i++) (lans += sum[i] + add[i] * (rb(i) - lb(i) + 1)) %= c+1; printf("%lld\n", lans); &#125; &#125;&#125; 数列分块入门 5 题意 给出一个长为 \(n\) 的数列 \(a_1\ldots a_n\)，以及 \(n\) 个操作，操作涉及区间开方，区间求和。 解法 结论：一个数 \(n\) 用 \(O(\log \log n)\) 次开方可以变成 \(1\)。 然后把数组分成 \(k\) 块。并且对于每一块，维护块内和和块内是否有 \(\mathbf{&gt;1}\) 的元素。 显然每块至多被更新 \(\log \text{值域}​\) 次，那么 \(q (q = n)​\) 次更新的总时间复杂度是 \(O(q \cdot \dfrac nk + k \log \log \text{值域})​\)[可能有锅]？ 单次查询复杂度：\(O(\dfrac nk)\)。 取 \(k = \sqrt n\) 时复杂度最优。 代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 5e4+54, M = 3e2+32;long long a[N], sum[M], all_1[M];int n, m, op, l, r;void rebuild(int id) &#123; sum[id] = 0; all_1[id] = 1; for (int i = lb(id); i &lt;= rb(id); i++) &#123; sum[id] += a[i] = sqrt(a[i]); all_1[id] &amp;= a[i] &lt;= 1; &#125;&#125;int main() &#123; scanf("%d", &amp;n); m = sqrt(n); for (int i = 1; i &lt;= be(n); i++) all_1[i] = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", a+i); sum[be(i)] += a[i]; all_1[be(i)] &amp;= a[i] == 1; &#125; for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%*d", &amp;op, &amp;l, &amp;r); int L = be(l), R = be(r); if (!op) &#123; for (int i = l; i &lt;= std::min(rb(L), r); i++) &#123; sum[L] -= a[i]; a[i] = sqrt(a[i]); sum[L] += a[i]; &#125; if (L != R) for (int i = lb(R); i &lt;= r; i++) &#123; sum[R] -= a[i]; a[i] = sqrt(a[i]); sum[R] += a[i]; &#125; for (int i = L+1; i &lt; R; i++) if (!all_1[i]) &#123; rebuild(i); &#125; &#125; else &#123; long long lans = 0; for (int i = l; i &lt;= std::min(rb(L), r); i++) lans += a[i]; if (L != R) for (int i = lb(R); i &lt;= r; i++) lans += a[i]; for (int i = L+1; i &lt; R; i++) lans += sum[i]; printf("%lld\n", lans); &#125; &#125;&#125; 数列分块入门 6 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及单点插入，单点询问，数据随机生成。 解法 Splay 大法好！ Splay 模板题不解释。 代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;const int N = 2e5+25;int ch[N][2], par[N], size[N], cnt[N], val[N], ncnt, root;void pushup(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x]; &#125;bool chk(int x) &#123; return ch[par[x]][1] == x; &#125;void rotate(int x) &#123; int y = par[x], z = par[y], k = chk(x), w = ch[x][k^1]; ch[y][k] = w; par[w] = y; ch[z][chk(y)] = x; par[x] = z; ch[x][k^1] = y; par[y] = x; pushup(y); pushup(x);&#125;int newNode(int x) &#123; int cur = ++ncnt; size[cur] = cnt[cur] = 1; val[cur] = x; return cur;&#125;void slay(int x, int goal = 0) &#123; while (par[x] != goal) &#123; int y = par[x], z = par[y]; if (z != goal) rotate(chk(x) == chk(y) ? y : x); rotate(x); &#125; if (!goal) root = x;&#125;int kth(int k) &#123; int cur = root; while (1) &#123; if (ch[cur][0] &amp;&amp; k &lt;= size[ch[cur][0]]) &#123; cur = ch[cur][0]; &#125; else if (k &gt; size[ch[cur][0]] + cnt[cur]) &#123; k -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else &#123; return cur; &#125; &#125;&#125;int build(int l, int r, int *a) &#123; if (l &gt; r) return 0; int mid = (l+r) &gt;&gt; 1, cur = newNode(a[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid-1, a))) par[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid+1, r, a))) par[ch[cur][1]] = cur; pushup(cur); return cur;&#125;int n, op, l, r, c;int a[N];int main() &#123; scanf("%d", &amp;n); a[0] = -1; for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); root = build(0, n, a); for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%d", &amp;op, &amp;l, &amp;r, &amp;c); if (!op) &#123; int x = kth(l), y = kth(l+1); slay(x); slay(y, x); par[ch[y][0] = newNode(r)] = y; &#125; else &#123; printf("%d\n", val[kth(r+1)]); &#125; &#125;&#125; 数列分块入门 7 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及区间乘法，区间加法，单点询问。 解法 令 \(add_i\) 和 \(mul_i\) 代表第 \(i\) 块的加法标记和乘法标记。具体优先级为 \(x \times mul + add\)。 那么整块加可以表示为 \(add = add + c\)，整块乘可以表示为 \(add = add \times c, mul = mul \times c\)。 如果优先级为 \((x + add) \times mul\)，那么整块加就必须只能表示为 \(add = add + \dfrac{c}{mul}\)，实现不方便。 对于不完整块，我们先下传标记，然后暴力修改。 这不就是洛谷线段树 2 么？ 代码 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 1e5+15, M = 3e2+32, P = 1e4+7;int n, m, op, l, r, c, a[N], add[M], mul[M];void pushdown(int id) &#123; for (int i = lb(id); i &lt;= rb(id); i++) &#123; a[i] = (a[i] * mul[id] + add[id]) % P; &#125; mul[id] = 1; add[id] = 0;&#125;int main() &#123; scanf("%d", &amp;n); m = sqrt(n); for (int i = 1; i &lt;= be(n); i++) mul[i] = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); a[i] %= P; &#125; for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d%d", &amp;op, &amp;l, &amp;r, &amp;c); c %= P; int L = be(l), R = be(r); if (!op) &#123; pushdown(L); for (int i = l; i &lt;= std::min(rb(L), r); i++) (a[i] += c) %= P; if (L != R) &#123; pushdown(R); for (int i = lb(R); i &lt;= r; i++) (a[i] += c) %= P; &#125; for (int i = L+1; i &lt; R; i++) (add[i] += c) %= P; &#125; else if (op == 1) &#123; pushdown(L); for (int i = l; i &lt;= std::min(rb(L), r); i++) (a[i] *= c) %= P; if (L != R) &#123; pushdown(R); for (int i = lb(R); i &lt;= r; i++) (a[i] *= c) %= P; &#125; for (int i = L+1; i &lt; R; i++) &#123; (add[i] *= c) %= P; (mul[i] *= c) %= P; &#125; &#125; else &#123; printf("%d\n", (a[r] * mul[R] + add[R]) % P); &#125; &#125;&#125; 数列分块入门 8 题意 给出一个长为 \(n\) 的数列，以及 \(n\) 个操作，操作涉及区间询问等于一个数 \(c\) 的元素，并将这个区间的所有元素改为 \(c\)。 解法 打一个 set 标记。对于整块，如果标记等于 \(c\) 那么答案加上区间长度，否则不加。对于非整块，先 pushdown 再暴力更新。 代码 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 1e5+15, M = 3e2+32, INF = 0x2b2b2b2b;int n, m, l, r, c, a[N], set[M];void pushdown(int id) &#123; if (set[id] != INF) for (int i = lb(id); i &lt;= rb(id); i++) a[i] = set[id]; set[id] = INF;&#125;int getans(int id) &#123; int ret = 0; if (set[id] != INF) return (set[id] == c) * (rb(id) - lb(id) + 1); for (int i = lb(id); i &lt;= rb(id); i++) ret += a[i] == c; return ret;&#125;int main() &#123; scanf("%d", &amp;n); m = sqrt(n); memset(set, 0x2b, sizeof set); for (int i = 1; i &lt;= n; i++) scanf("%d", a+i); for (int _ = 0; _ &lt; n; _++) &#123; scanf("%d%d%d", &amp;l, &amp;r, &amp;c); int L = be(l), R = be(r), lans = 0; pushdown(L); for (int i = l; i &lt;= std::min(rb(L), r); i++) &#123; lans += a[i] == c; a[i] = c; &#125; if (L != R) &#123; pushdown(R); for (int i = lb(R); i &lt;= r; i++) &#123; lans += a[i] == c; a[i] = c; &#125; &#125; for (int i = L+1; i &lt; R; i++) &#123; lans += getans(i); set[i] = c; &#125; printf("%d\n", lans); &#125;&#125; 数列分块入门 9 题意 区间众数。 解法 解法参见 这里。 代码 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cmath&gt;#define be(x) (((x)-1) / m + 1)#define lb(x) (((x)-1) * m + 1)#define rb(x) std::min((x) * m, n)const int N = 5e5+55, M = 1e3+13;int n, m, q, l, r, L, R, ans, a[N], _[N], cnt[M][M], mode[M][M], sum[N], lnk[N], S$;std::vector&lt;int&gt; idx[N];int main() &#123; scanf("%d", &amp;n); q = n; m = ceil(sqrt(n)); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); _[i] = a[i]; &#125; std::sort(_+1, _+n+1); S$ = std::unique(_+1, _+n+1) -_- 1; for (int i = 1; i &lt;= n; i++) &#123; a[i] = std::lower_bound(_+1, _+S$+1, a[i]) - _; idx[a[i]].push_back(i); lnk[i] = idx[a[i]].size()-1; &#125; memset(mode, 0x3f, sizeof mode); for (int i = 1; i &lt;= m; i++) &#123; memset(sum, 0, sizeof sum); for (int j = i; j &lt;= m; j++) &#123; cnt[i][j] = cnt[i][j-1]; mode[i][j] = mode[i][j-1]; for (int k = lb(j); k &lt;= rb(j); k++) &#123; sum[a[k]]++; if (sum[a[k]] &gt; cnt[i][j] || (sum[a[k]] == cnt[i][j] &amp;&amp; a[k] &lt; mode[i][j])) &#123; cnt[i][j] = sum[a[k]]; mode[i][j] = a[k]; &#125; &#125; &#125; &#125; while (q--) &#123; scanf("%d%d", &amp;l, &amp;r); L = be(l); R = be(r); ans = cnt[L+1][R-1]; int out = mode[L+1][R-1]; if (!ans) &#123; ans = 1; out = a[l]; &#125; for (int i = l; i &lt;= std::min(rb(L), r); i++) &#123; int orig = lnk[i] + ans - 1; if (0 &lt;= orig &amp;&amp; orig &lt; idx[a[i]].size() &amp;&amp; l &lt;= idx[a[i]][orig] &amp;&amp; idx[a[i]][orig] &lt;= r &amp;&amp; a[i] &lt; out) &#123; out = a[i]; &#125; while (lnk[i] + ans &lt; idx[a[i]].size() &amp;&amp; idx[a[i]][lnk[i] + ans] &lt;= r) &#123; out = a[i]; ans++; &#125; &#125; if (L != R) for (int i = lb(R); i &lt;= r; i++) &#123; int orig = lnk[i] - ans + 1; if (0 &lt;= orig &amp;&amp; orig &lt; idx[a[i]].size() &amp;&amp; l &lt;= idx[a[i]][orig] &amp;&amp; idx[a[i]][orig] &lt;= r &amp;&amp; a[i] &lt; out) &#123; out = a[i]; &#125; while (lnk[i] - ans &gt;= 0 &amp;&amp; idx[a[i]][lnk[i] - ans] &gt;= l) &#123; out = a[i]; ans++; &#125; &#125; printf("%d\n", _[out]); &#125;&#125;]]></content>
      <categories>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>分块</tag>
        <tag>LOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」ODT (TBC)]]></title>
    <url>%2F2018%2F10%2F23%2Fodt-notes%2F</url>
    <content type="text"><![CDATA[简介 ODT 是一种基于平衡树的算法，可以高效地处理带有区间 set 操作的问题，且数据随机。 思想 ODT 的主要思想是：因为数据随机，所以区间 set 操作非常常见。我们可以在区间 set 时将多个节点合并为一个，以降低复杂度。 模板题 (CF897E) 题意 传送门：Codeforces 897E - Willem, Chtholly and Seniorious 维护一个数列，支持区间加、区间 set、区间 \(k\) 小、区间 \(x\) 次方和。 保证数据随机，\(n, m \le 10^5\)。 存储方式 因为我们有将多个点合并的操作，所以一个点代表一个区间。 平衡树我们这里使用 std::set。 为了可以在 std::set 中修改变量，我们这里使用指针来存储值。老 K：语言毒瘤 123456struct node &#123; int l, r, *v; bool operator&lt;(const node&amp; rhs) const &#123; return l &lt; rhs.l; &#125;&#125;; 各种定义 123typedef std::set&lt;node&gt;::iterator _; /// 迭代器std::set&lt;node&gt; root; // 平衡树 分离区间 split(l) 的作用是：返回一个以 \(l\) 为左端点的节点。如果没有，则从已有节点中分裂出一个。 12345678910_ split(int l) &#123; _ it = root.lower_bound((node)&#123;l, 0, 0&#125;); if (it != root.end() &amp;&amp; it-&gt;l == l) return it; // 已经存在了 it--; // 如果不存在，lower_bound 会返回第一个大于 l 的节点的迭代器，所以必须减一 int L = it-&gt;l, R = it-&gt;r, V = *(it-&gt;v); root.erase(it); // 将原来的一个节点分裂成两个 root.insert((node)&#123;L, l-1, new int(V)&#125;); return root.insert((node)&#123;l, R, new int(V)&#125;).first;&#125; 区间 set 我们暴力的把 \([l, r]\) 区间的所有点删除，然后合并成一个点。 123456void set(int l, int r, int x) &#123; split(l); _ ub = split(r+1); // 为了防止迭代器失效引发的 UB，左端点为 l 的迭代器必须要在 split 完之后计算 root.erase(root.lower_bound((node)&#123;l, 0, 0&#125;), ub); root.insert((node)&#123;l, r, new int(x)&#125;);&#125; 其中 std::set&lt;node&gt;::erase(l, r) 代表删除迭代器区间 \([l, r)\) 之间的所有元素。 区间加 暴力加即可。 123456void add(int l, int r, int x) &#123; split(l); _ ub = split(r+1); for (_ i = root.lower_bound((node)&#123;l, 0, 0&#125;); i != ub; i++) &#123; *(i-&gt;v) += x; &#125;&#125; 什么鬼？ 区间 k 小 暴力排序即可。 123456789101112int ktg(int l, int r, int x) &#123; std::vector&lt;std::pair&lt;int, int&gt; &gt; vec; split(l); _ ub = split(r+1); for (_ i = root.lower_bound((node)&#123;l, 0, 0&#125;); i != ub; i++) &#123; vec.push_back(std::make_pair(*(i-&gt;v), i-&gt;r - i-&gt;l + 1)); &#125; sort(vec.begin(), vec.end()); for (std::vector&lt;std::pair&lt;int, int&gt; &gt;::iterator it = vec.begin(); it != vec.end(); it++) &#123; if ((x -= it-&gt;second) &lt;= 0) return it-&gt;first; &#125; return -1;&#125; 怎么越来越暴力了？ 区间 x 次方和 暴力累加即可。 12345678int psum(int l, int r, int x, int y) &#123; int ret = 0; split(l); _ ub = split(r+1); for (_ i = root.lower_bound((node)&#123;l, 0, 0&#125;); i != ub; i++) &#123; (ret += (i-&gt;r - i-&gt;l + 1) * p(*(i-&gt;v), x, y)) %= y; &#125; return ret;&#125; WTF？ 复杂度证明 证明十分玄学：这里 如果不是数据随机，这货随便就会 T 飞。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ODT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「订正」Lyft Level 5 Challenge 2018 - Elimination Round]]></title>
    <url>%2F2018%2F10%2F17%2Flyft-level5-challenge-2018-elimination-round%2F</url>
    <content type="text"><![CDATA[传送门：Lyft Level 5 Challenge 2018 - Elimination Round A 只要相对于皇后在同一个象限即可。 1main(a,b,c,d,e,f)&#123;scanf("%*d%d%d%d%d%d%d",&amp;a,&amp;b,&amp;c,&amp;d,&amp;e,&amp;f);puts((c-a)*(e-a)&gt;0&amp;(d-b)*(f-b)&gt;0?"YES":"NO");&#125; B 题意 \(a^2 - b^2\) 是不是质数？ 解法 \(a^2 - b^2=(a + b)(a - b)\)。所以只要满足 \(a-b = 1, a+b\mbox{ is prime}\) 即可。 代码 1long long x,y,i;main(f)&#123;for(gets(&amp;f);~scanf("%I64d%I64d",&amp;x,&amp;y);puts(f?"YES":"NO"))&#123;f=x-1==y;y+=x;for(i=2;i*i&lt;=y;i++)f&amp;=y%i&gt;0;&#125;&#125; C 题意 解法 既然要字典序最小，那么肯定要以最快的速度使 \(\gcd\) 变大。 因为 \(\gcd(3, 5) = 0\)，所以对于 \(n &gt; 4\) 的情况，我们显然应该先把奇数删完。 剩下的数都是偶数后，因为 \(\gcd(ax, ay) = a \cdot \gcd(x,y)\)，所以我们可以把所有数字 \(\div 2\) 之后递归地处理。 最后特判 \(n = 1,3\) 的情况。 代码 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int n;void prt(int x, int v) &#123; if (x == 1) &#123; printf("%d ", v); return; &#125; if (x == 3) &#123; printf("%d %d %d ", v, v, 3*v); return; &#125; for (int i = 0; i &lt; ((x+1)&gt;&gt;1); i++) &#123; printf("%d ", v); &#125; prt(x&gt;&gt;1, v&lt;&lt;1);&#125;int main() &#123; scanf("%d", &amp;n); prt(n, 1);&#125; D 题意 给定一堆点，找到一个与 \(x\) 轴相切的圆，使得它包含所有的点，并且半径最小。 解法 显然，对于一个可行的半径 \(r\)，大于 \(r\) 的半径也都是可行的。 所以我们可以考虑二分。 判断也很简单：对于每个点，计算出圆心可能的 \(x\) 值范围，然后取交即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 120005;int x[N], y[N];int n, c;bool check(double k) &#123; double l = -1e18, r = 1e18, tmp; for (int i = 1; i &lt;= n; i++) &#123; if (2 * k &lt; x[i]) return 0; tmp = sqrt(x[i] * (2. * k - x[i]));// tmp = sqrt(k*k - (x[i]-k) * (x[i]-k)); l = max(l, y[i] - tmp); r = min(r, y[i] + tmp); &#125; return l &lt;= r;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", y+i, x+i); c += x[i] &lt; 0; &#125; if (c &amp;&amp; c != n) return puts("-1"),0; if (c) &#123; for (int i = 1; i &lt;= n; i++) &#123; x[i] = -x[i]; &#125; &#125; double l = 0, r = 1e14; c = 0; while (c++ &lt; 100) &#123; double mid = (l+r) / 2; if (check(mid)) r = mid; else l = mid; &#125; printf("%.7lf", l);&#125; E 题意 给你一棵带点权的树，你要把树剖成尽量少的链，使得每条链的长度 \(\le L\)，点权和 \(\le S\)。 解法 考虑贪心。对于每一个节点，我们计算出可以延伸的最浅节点。计算可以使用倍增和前缀和。 然后对于每一个点，贪心地从子节点找最大的延伸距离就好了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;const int N = 100005;struct edge &#123; int to, next;&#125; e[N&lt;&lt;1];int head[N], cnt;void addedge(int x, int y) &#123; e[++cnt] = (edge)&#123;y, head[x]&#125;; head[x] = cnt;&#125;int par[N], top[N], dep[N], t[N], anc[N][21];long long s, w[N];int n, l;void prework() &#123; for (int i = 1; i &lt; 20; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; anc[j][i] = anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;void dfs1(int x, int p) &#123; dep[x] = dep[p]+1; w[x] += w[p]; top[x] = x; int len = l-1; for (int i = 19; i &gt;= 0; i--) &#123; if (!anc[top[x]][i] || (1 &lt;&lt; i) &gt; len) continue; if (w[x] - w[par[anc[top[x]][i]]] &lt;= s) &#123; len -= 1 &lt;&lt; i; top[x] = anc[top[x]][i]; &#125; &#125; for (int i = head[x]; i; i = e[i].next) &#123; dfs1(e[i].to, x); &#125;&#125;int dfs2(int x) &#123; int ret = 0, mx = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; ret += dfs2(nx); if (t[nx] == nx) continue; if (!mx || dep[mx] &gt; dep[t[nx]]) mx = t[nx]; &#125; if (mx) t[x] = mx; else t[x] = top[x], ret++; return ret;&#125;int main() &#123; scanf("%d%d%I64d", &amp;n, &amp;l, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf("%I64d", w+i); if (w[i] &gt; s) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", par+i); anc[i][0] = par[i]; addedge(par[i], i); &#125; prework(); dfs1(1, 0); dep[0] = 0x3f3f3f3f; printf("%d", dfs2(1));&#125;]]></content>
      <categories>
        <category>订正</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「HNOI2018」寻宝游戏 - 数学]]></title>
    <url>%2F2018%2F10%2F17%2Fhnoi2018-hunt%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P4424 - 寻宝游戏、UOJ 384。 给你 \(n\) 个长度为 \(m\) 的二进制数 \(\{a_i\}\) 和 \(q\) 个询问，每个询问也是一个长度为 \(m\) 的二进制数。对于每一个查询，你要输出：在 \(0, a_1, a_2, \cdots, a_n\) 之间插入 \(n\) 个 \(\lor\) 或 \(\land\)，使结果等于查询的数的方案数。 解法 首先我们只考虑一位。 观察 \(\lor\) 和 \(\land\) 的真值表，可以发现只有当 \(\lor 1\) 和 \(\land 0\) 时会改变值。考虑把操作序列转换成一个二进制数，让 \(0 = \lor, 1 = \land\)。记该数的第 \(i\) 位为 \(b_i\)，经过前 \(i\) 次操作得到的数为 \(c_i\)。 可以发现，\(\forall i \in [1, n]\)： 如果 \(a_i = b_i\)，那么 \(c_i = c_{i-1}\)； 如果 \(a_i &gt; b_i\)，那么 \(c_i = 1\)； 如果 \(a_i &lt; b_i\)，那么 \(c_i = 0\)。 因为没有异或操作，所以最终的结果取决于 \(\{b_i\}\) 最后的那几位。 是不是有点似曾相识？ 1234567bool cmp(const BigInt&amp; lhs, const BigInt&amp; rhs) &#123; if (lhs.n != rhs.n) return lhs.n &lt; rhs.n; for (int i = n-1; i &gt;= 0; i--) &#123; if (lhs.data[i] != rhs.data[i]) return lhs.data[i] &lt; rhs.data[i]; &#125; return false;&#125; 这不就是整数比较么…… 所以得出结论：如果 \(\mathbf{b &lt; a}\)，那么 \(\mathbf{c_n = 1}\)；如果 \(\mathbf{b \ge a}\)，那么 \(\mathbf{c_n = 0}\)。 然后我们把每一位的限制条件综合起来，如果得到了类似于 \(b \in [l, r)\) 的东西，那么答案就是 \(r-l\) 了啦。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;functional&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;const int N = 1033, M = 5033, P = 1000000007;int n, m, q;struct bitset &#123; int val, id, data[N]; bool operator&gt;(const bitset&amp; rhs) const &#123; for (int i = n-1; i &gt;= 0; i--) &#123; if (data[i] != rhs.data[i]) return data[i] &gt; rhs.data[i]; &#125; return false; &#125;&#125; rec[M];int p2[M] = &#123;1&#125;, mmp[M];char buf[M];int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i++) &#123; p2[i] = (p2[i-1] &lt;&lt; 1) % P; &#125; for (int i = 1; i &lt;= m; i++) &#123; rec[i].id = i; &#125; for (int i = 0; i &lt; n; i++) &#123; scanf("%s", buf+1); for (int j = 1; j &lt;= m; j++) &#123; rec[j].data[i] = buf[j] - 48; (rec[j].val += rec[j].data[i] * p2[i] % P) %= P; &#125; &#125; std::sort(rec+1, rec+m+1, std::greater&lt;bitset&gt;()); for (int i = 1; i &lt;= m; i++) &#123; mmp[rec[i].id] = i; &#125; rec-&gt;val = p2[n]; while (q--) &#123; scanf("%s", buf+1); int lb = 0, ub = m+1; for (int i = 1; i &lt;= m; i++) &#123; if (buf[i] == 49) lb = std::max(lb, mmp[i]); else ub = std::min(ub, mmp[i]); &#125; if (lb &gt; ub) puts("0"); else printf("%d\n", (rec[lb].val - rec[ub].val + P) % P); &#125;&#125; 总结 操作串转换成整数有时候会有意想不到的效果。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>HNOI</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Ynoi2016」掉进兔子洞]]></title>
    <url>%2F2018%2F10%2F15%2Fynoi2016-t1%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P4692 - 掉进兔子洞、DarkBZOJ 4939、BZOJ4939。 这当然不是云南省选，这是由乃OI 您正在打galgame，然后突然发现您今天太颓了，于是想写个数据结构题练练手： 一个长为 n 的序列 a。 有 m 个询问，每次询问三个区间，把三个区间中同时出现的数一个一个删掉，问最后三个区间剩下的数的个数和，询问独立。 注意这里删掉指的是一个一个删，不是把等于这个值的数直接删完，比如三个区间是 [1,2,2,3,3,3,3] , [1,2,2,3,3,3,3] 与 [1,1,2,3,3]，就一起扔掉了 1 个 1，1 个 2，2 个 3。 n , m &lt;= 100000 , 1 &lt;= a[i] &lt;= 1000000000 解法 题目要我们求的是 \(\sum\limits_{i=1}^3(r_i-l_i+1) + \sum\limits_{i\in\{a\}}\min\{cnt1_i+cnt2_i+cnt3_i\}\)。 注意到数的值域太大，我们可以考虑先离散化。 前一部分好求，我们主要来看后一部分。 求区间中每一个数出现的次数是莫队的经典问题，但是取 \(\min\) 如果暴力做是 \(O(n)\) 的，空间复杂度会达到 \(O(nm)\) ，需要进一步优化。 我们可以尝试把取 \(\min\) 转化为 bitset 按位与：离散化时只排序，不去重。多出来的空间用来存出现次数。这样我们就可以直接将三个 bitset 按位与了。 然而空间仍然达到了 \(10^5 \times 10^5 \times \dfrac 1{8 \times 1024^2} \approx 1192\)Mib。 这时候我们就可以用一个奇技淫巧：把询问按 \(400\)Mib 分段，时间换空间。 然后就过了。 代码 哇，由乃题代码这么短…… 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005, M = 35004;int block[N], size;struct query &#123; int l, r, id; bool operator&lt;(const query&amp; rhs) const &#123; return block[l] == block[rhs.l] ? r &lt; rhs.r : block[l] &lt; block[rhs.l]; &#125;&#125; q[N*3];bitset&lt;N&gt; p[M], lans;int n, m, l, r, x;int rec[N], t[N];bool vis[N];int ans[N];int cnt[N];inline void add(int x) &#123; lans[x+cnt[x]++] = 1; &#125;inline void del(int x) &#123; lans[x+--cnt[x]] = 0; &#125;void solve(int lb, int rb) &#123; sort(q+lb, q+rb+1); for (int i = lb; i &lt;= rb; i++) &#123; while (r &lt; q[i].r) add(rec[++r]); while (l &gt; q[i].l) add(rec[--l]); while (r &gt; q[i].r) del(rec[r--]); while (l &lt; q[i].l) del(rec[l++]); if (!vis[q[i].id - lb/3]) &#123; p[q[i].id - lb/3] = lans; vis[q[i].id - lb/3] = 1; &#125; else p[q[i].id - lb/3] &amp;= lans; &#125; for (int i = lb/3; i &lt; rb/3; i++) &#123; ans[i] -= p[i - lb/3].count() * 3; vis[i - lb/3] = 0; &#125;&#125;int l1, r1, l2, r2, l3, r3;int main() &#123; scanf("%d%d", &amp;n, &amp;m); size = int(sqrt(n) + .5); l = 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec+i); block[i] = (i-1) / size; &#125; memcpy(t, rec, sizeof t); sort(t+1, t+n+1); for (int i = 1; i &lt;= n; i++) &#123; rec[i] = lower_bound(t+1, t+n+1, rec[i]) - t; &#125; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d%d%d%d", &amp;l1, &amp;r1, &amp;l2, &amp;r2, &amp;l3, &amp;r3); q[3*i+1] = (query)&#123;l1, r1, i&#125;; q[3*i+2] = (query)&#123;l2, r2, i&#125;; q[3*i+3] = (query)&#123;l3, r3, i&#125;; ans[i] = r1 + r2 + r3 - l1 - l2 - l3 + 3; &#125; for (int i = 0; i &lt; m; i += M) &#123; solve(i*3+1, min(m, i+M)*3); &#125; for (int i = 0; i &lt; m; i++) &#123; printf("%d\n", ans[i]); &#125;&#125; 拓展 对付卡空间的毒瘤出题人的好方法：把询问分段处理。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>莫队</tag>
        <tag>Ynoi</tag>
        <tag>bitset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「订正」Codeforces Round #514 (Div. 2)]]></title>
    <url>%2F2018%2F10%2F13%2Fcodeforces-round-514%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #514 (Div. 2) A 枚举每次休息的时间即可。注意最后还可以一直休息到下班的细节。 B 题意 给你一个图形，问你能不能用 \(3 \times 3\) 中空的笔画出来。 解法 首先最边缘一圈肯定不能作为中心点。如果一个点是空的，那么周围 \(8\) 个点不可能作为中心点。最后判断是否每个黑点周围是否都有中心点。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1030, dir[][2] = &#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125;;bool f[N][N];char r[N][N];int n, m;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s", r[i]+1); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (i == 1 || i == n || j == 1 || j == m) &#123; f[i][j] = 1; continue; &#125; if (r[i][j] == '.') &#123; for (int k = 0; k &lt; 8; k++) &#123; f[i+dir[k][0]][j+dir[k][1]] = 1; &#125; &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (r[i][j] == '#') &#123; for (int k = 0; k &lt; 8; k++) &#123; if (i+dir[k][0] &lt; 1 || n &lt; i+dir[k][0]) continue; if (j+dir[k][0] &lt; 1 || m &lt; j+dir[k][1]) continue; if (!f[i+dir[k][0]][j+dir[k][1]]) goto end; &#125; puts("NO"); return 0; end:; &#125; &#125; &#125; puts("YES");&#125; C 题意 给你一个 \(1 \sim n\) 的数列和一个空序列。每次把当前整个序列的 \(\gcd\) 加到空序列里，然后删掉一个数。输出所有可能产生出的序列中字典序最大的那个。 解法 既然要字典序最小，那么肯定要以最快的速度使 \(\gcd\) 变大。 因为 \(\gcd(3, 5) = 0\)，所以对于 \(n &gt; 4\) 的情况，我们显然应该先把奇数删完。 剩下的数都是偶数后，因为 \(\gcd(ax, ay) = a \cdot \gcd(x,y)\)，所以我们可以把所有数字 \(\div 2\) 之后递归地处理。 最后特判 \(n = 1,3\) 的情况。 代码 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int n;void prt(int x, int v) &#123; if (x == 1) &#123; printf("%d ", v); return; &#125; if (x == 3) &#123; printf("%d %d %d ", v, v, 3*v); return; &#125; for (int i = 0; i &lt; ((x+1)&gt;&gt;1); i++) &#123; printf("%d ", v); &#125; prt(x&gt;&gt;1, v&lt;&lt;1);&#125;int main() &#123; scanf("%d", &amp;n); prt(n, 1);&#125; D 题意 给定一堆点，找到一个与 \(x\) 轴相切的圆，使得它包含所有的点，并且半径最小。 解法 显然，对于一个可行的半径 \(r\)，大于 \(r\) 的半径也都是可行的。 所以我们可以考虑二分。 判断也很简单：对于每个点，计算出圆心可能的 \(x\) 值范围，然后取交即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 120005;int x[N], y[N];int n, c;bool check(double k) &#123; double l = -1e18, r = 1e18, tmp; for (int i = 1; i &lt;= n; i++) &#123; if (2 * k &lt; x[i]) return 0; tmp = sqrt(x[i] * (2. * k - x[i]));// tmp = sqrt(k*k - (x[i]-k) * (x[i]-k)); l = max(l, y[i] - tmp); r = min(r, y[i] + tmp); &#125; return l &lt;= r;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", y+i, x+i); c += x[i] &lt; 0; &#125; if (c &amp;&amp; c != n) return puts("-1"),0; if (c) &#123; for (int i = 1; i &lt;= n; i++) &#123; x[i] = -x[i]; &#125; &#125; double l = 0, r = 1e14; c = 0; while (c++ &lt; 100) &#123; double mid = (l+r) / 2; if (check(mid)) r = mid; else l = mid; &#125; printf("%.7lf", l);&#125; E 题意 给你一棵带点权的树，你要把树剖成尽量少的链，使得每条链的长度 \(\le L\)，点权和 \(\le S\)。 解法 考虑贪心。对于每一个节点，我们计算出可以延伸的最浅节点。计算可以使用倍增和前缀和。 然后对于每一个点，贪心地从子节点找最大的延伸距离就好了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;const int N = 100005;struct edge &#123; int to, next;&#125; e[N&lt;&lt;1];int head[N], cnt;void addedge(int x, int y) &#123; e[++cnt] = (edge)&#123;y, head[x]&#125;; head[x] = cnt;&#125;int par[N], top[N], dep[N], t[N], anc[N][21];long long s, w[N];int n, l;void prework() &#123; for (int i = 1; i &lt; 20; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; anc[j][i] = anc[anc[j][i-1]][i-1]; &#125; &#125;&#125;void dfs1(int x, int p) &#123; dep[x] = dep[p]+1; w[x] += w[p]; top[x] = x; int len = l-1; for (int i = 19; i &gt;= 0; i--) &#123; if (!anc[top[x]][i] || (1 &lt;&lt; i) &gt; len) continue; if (w[x] - w[par[anc[top[x]][i]]] &lt;= s) &#123; len -= 1 &lt;&lt; i; top[x] = anc[top[x]][i]; &#125; &#125; for (int i = head[x]; i; i = e[i].next) &#123; dfs1(e[i].to, x); &#125;&#125;int dfs2(int x) &#123; int ret = 0, mx = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; ret += dfs2(nx); if (t[nx] == nx) continue; if (!mx || dep[mx] &gt; dep[t[nx]]) mx = t[nx]; &#125; if (mx) t[x] = mx; else t[x] = top[x], ret++; return ret;&#125;int main() &#123; scanf("%d%d%I64d", &amp;n, &amp;l, &amp;s); for (int i = 1; i &lt;= n; i++) &#123; scanf("%I64d", w+i); if (w[i] &gt; s) &#123; puts("-1"); return 0; &#125; &#125; for (int i = 2; i &lt;= n; i++) &#123; scanf("%d", par+i); anc[i][0] = par[i]; addedge(par[i], i); &#125; prework(); dfs1(1, 0); dep[0] = 0x3f3f3f3f; printf("%d", dfs2(1));&#125;]]></content>
      <categories>
        <category>订正</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「赛后总结」Codeforces Round #513 (Div. 1 + Div. 2)]]></title>
    <url>%2F2018%2F10%2F13%2Fcodeforces-round-513%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #513 (Div. 1 + Div. 2) 比赛的时候状态不大好，本来 A~E 都能做，结果 B 题 FST…… A 答案是 \(\min\{\text{8的数量},\dfrac n{11}\}\)。 B 题意 给定一个整数，你要把它表示成两个非负整数之和，使得两数各位之和的和最大。 解法1 令 \(d = \lfloor \lg n \rfloor\)，则将原树分为 \(10^d-1\) 和 \(n - 10^d + 1\)。 代码 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;long long n, t, q;int f(long long x) &#123; int ret = 0; if (x &gt; 9) ret += f(x / 10); return ret + x % 10;&#125;int main() &#123; cin &gt;&gt; n; t = log10(n); q = (long long)pow(10, t); printf("%d", f(q-1) + f(n-q+1));&#125; 伪·hack 1input: 9999999998 这个数据我的代码会得到 \(999999998 + 9000000000\)。 但是按照思路，答案应该是\(999999999 + 8999999999\)。 然后我把 \(q-1\) 和 \(n-q+1\) 输出了下，发现 pow 函数出现了误差。 修改方式也很简单，把 \(15\) 行改成 q = (long long)(pow(10, t) + .5); :warning: pow函数误差大，尽量不用或者使用时记得四舍五入。 思路2 枚举所有的 \(10^d-1\)，然后计算即可。代码略。 C 题意 给你两串数 \(\{a\},\{b\}\)，构造一个矩阵 \(c\)，使得 \(c_{i,j} = a_i \cdot b_j\)。你要选出一个最大的子矩阵使得它的和 \(\le k\)。 或者： 给你两串数 \(\{a\},\{b\}\)，在每个序列中取一个子段，使得子段和的乘积 \(\le k\)，并且最大化长度的成绩。 比赛的时候我一直在考虑二分，认为没有复杂度正确的算法…… 解法 十分简单。对于每一个序列的每个子段长度，我们计算出该长度的子段的最小和。 预处理完后枚举两个序列的子段长度即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 3003;ll a[N], b[N], ax[N], bx[N], x;int n, m, ans;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%I64d", a+i); a[i] += a[i-1]; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%I64d", b+i); b[i] += b[i-1]; &#125; scanf("%I64d", &amp;x); memset(ax, 0x3f, sizeof ax); memset(bx, 0x3f, sizeof bx); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; ax[i - j] = min(ax[i - j], a[i] - a[j]); &#125; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; bx[i - j] = min(bx[i - j], b[i] - b[j]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (ax[i] * bx[j] &lt;= x) &#123; ans = max(ans, i*j); &#125; &#125; &#125; printf("%d", ans);&#125; D 题意 有一些人来吃饭，你需要把座位排成若干个圈。 每个人希望顺时针方向有 \(l_i\) 个座位是空的，逆时针 \(r_i\) 个座位是空的。 输出满足所有人要求时，最少需要安排的座位数。 解法 不用考虑座位是怎么安排的，只需要知道，\(\bold{l_i}\) 最小的人应该和 \(\bold{r_i}\) 坐在一起，然后以此类推即可。 代码 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int N = 100005;ll l[N], r[N], ans;int n;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%I64d%I64d", l+i, r+i); &#125; sort(l+1, l+n+1); sort(r+1, r+n+1); for (int i = 1; i &lt;= n; i++) &#123; ans += max(l[i], r[i]); &#125; printf("%I64d", ans+n);&#125; E 题意 给你一棵树，然后对于所有距离为 \(2\) 的点对 \((i, j)\)，都连一条无向边 \((i, j)\)。求所有点对的距离和。 解法 考虑加完边后对答案的影响。 首先对树黑白染色。显然，对于所有的同色点对，它们的距离变成了 \(\dfrac{dis}2\)。对于异色点对，他们的距离变成了 \(\dfrac{dis+1}2\)。 所以我们只需要把答案加上异色点对数(即黑点数与白点数的乘积)再除以二就好了。 统计所有点对距离和很简单：对于每一条边，将答案加上左侧点数和右侧点数的乘积。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200005;struct edge &#123; int to, next;&#125; e[N&lt;&lt;1];int head[N], cnt;void addedge(int x, int y) &#123; e[++cnt] = (edge)&#123;y, head[x]&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y]&#125;; head[y] = cnt;&#125;long long _[2], ans;int n, x, y;int size[N];void dfs(int x, int p, int c) &#123; _[c]++; size[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == p) continue; dfs(nx, x, c^1); size[x] += size[nx]; &#125; ans += 1ll * size[x] * (n - size[x]);&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d", &amp;x, &amp;y); addedge(x, y); &#125; dfs(1, 0, 0); printf("%I64d", (ans + _[0] * _[1]) &gt;&gt; 1);&#125;]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>前缀</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「NOIp2015」运输计划 - 二分 + 树上差分 + LCA]]></title>
    <url>%2F2018%2F09%2F04%2Fnoip2015-transport%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P2680 - 运输计划和BZOJ4326。 给你一棵树和一堆路径，现在你可以指定一条边，把它的长度变成\(0\)，问最小可能的最长路径的长度。 解法 最小化最大值显然是二分。那么我们只需要求解\(O(\log\max\{t_i\})\)个判定性问题就好啦。 判定性问题：能否使最长的路径长度\(\le T\)。 现在我们来考虑判定性问题的求解。 既然需要使所有路径的长度都\(\le T\)，那么就需要给所有长度\(&gt;T\)的路径砍掉一条边。所以我们操作的边一定在所有长度\(\bold{&gt;T}\)的路径上。 显然对于上述的这种边，我们要操作的一定是长度最大的，这样可以砍掉很长一段距离。 然后我们可以用树上差分找出这种边。(即对每一条\(&gt;T\)的路径进行路径加操作) 代码也比较好写，但是我太蒻了路径长度计算写错了&gt;_&lt;。 最后的复杂度是\(O(m\log n+n\log\max\{t_i\})\)。我偷懒没预处理LCA所以加号后面的复杂度还要乘上一个\(O(\log n)\)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 300005;struct edge &#123; int to, next, w;&#125; e[N&lt;&lt;1];int head[N], cnt;void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y], z&#125;; head[y] = cnt;&#125;int dep[N], par[N], size[N], son[N], dfn[N], top[N], idx;void dfs1(int x, int p, int d) &#123; dep[x] = d; par[x] = p; size[x] = 1; int mx = 0xcfcfcfcf; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == p) continue; dfs1(nx, x, d+1); size[x] += size[nx]; if (size[nx] &gt; mx) &#123; mx = size[nx]; son[x] = nx; &#125; &#125;&#125;void dfs2(int x, int t) &#123; dfn[x] = ++idx; top[x] = t; if (!son[x]) return; dfs2(son[x], t); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == par[x] || nx == son[x]) continue; dfs2(nx, nx); &#125;&#125;int lca(int x, int y) &#123; while (top[x] != top[y]) &#123; if (dep[top[x]] &lt; dep[top[y]]) swap(x, y); x = par[top[x]]; &#125; return dep[x] &lt; dep[y] ? x : y;&#125;int dis[N];void dfs3(int x, int p) &#123; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == p) continue; dis[nx] = dis[x] + e[i].w; dfs3(nx, x); &#125;&#125;int cnt$[N], maxlen;int dfs4(int x, int p, int c) &#123; int ret = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == p) continue; ret = max(ret, dfs4(nx, x, c)); cnt$[x] += cnt$[nx]; if (cnt$[nx] == c) ret = max(ret, e[i].w); &#125; return ret;&#125;struct record &#123; int x, y, z;&#125; rec[N];int n, m;bool check(int x) &#123; int c = 0; memset(cnt$, 0, sizeof cnt$); for (int i = 1; i &lt;= m; i++) &#123; if (rec[i].z &gt; x) &#123; cnt$[rec[i].x]++; cnt$[rec[i].y]++; cnt$[lca(rec[i].x, rec[i].y)] -= 2; c++; &#125; &#125; return maxlen - dfs4(1, -1, c) &lt;= x;&#125;int x, y, z;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt; n; i++) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); addedge(x, y, z); &#125; dfs1(1, -1, 1); dfs2(1, 1); dfs3(1, -1); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;x, &amp;y); maxlen = max(maxlen, z = dis[x] + dis[y] - (dis[lca(x, y)] &lt;&lt; 1)); rec[i] = (record)&#123;x, y, z&#125;; &#125; int l = 0, r = maxlen, ans; while (l &lt;= r) &#123; int mid = (l+r)&gt;&gt;1; if (check(mid)) &#123; ans = mid; r = mid-1; &#125; else &#123; l = mid+1; &#125; &#125; printf("%d", ans); return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>洛谷</tag>
        <tag>二分</tag>
        <tag>NOIp</tag>
        <tag>树上差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」点分治]]></title>
    <url>%2F2018%2F08%2F26%2Ftree-divide-notes%2F</url>
    <content type="text"><![CDATA[简介 点分治，即用树上分治解决路径问题的一种算法。 例题 传送门：洛谷 P3806 - 【模板】点分治1 求树上距离为\(k\)的点对是否存在。\(n\le10^4\)。 这个范围显然暴力过不了。 解法 路径的种类有两种： 经过根的路径 不经过根的路径 我们的思路很简单：先处理第一种路径，然后递归地处理第二种路径。 但是如果是一条链的情况，从链首分治到链尾，就会出现尴尬的TLE。 所以我们要考虑如何定根可以使这棵树尽可能地「平衡」。 严格的定义是：根下面最大的子树尽可能的小。 树上满足上面定义的点，被称作树的重心。 树的重心 求重心很简单，只需要一次dfs。 令\(size_x\)为\(x\)这棵子树的大小，\(mst_x\)为\(x\)这棵子树的最大子树(Maximum Subtree)，\(sum\)为整棵树的大小。 那么就有\(\displaystyle mst_x=\min\{\min_{i\in son(x)}size_i,sum-size_x\}\)。 然后找到\(mst\)最小的点，这个点就是树的重心啦。 代码也很好写(先不要管\(vis\)是干什么的)： 12345678910111213141516171819int size[N], mst[N], vis[N], root, sum;// size: 树的大小// mst: 最大子树// vis: solved标记。保证复杂度。// root: 当前的重心 // sum: 当前整棵树的节点数void dfs1(int x, int p) &#123; size[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].nx; if (nx == p || vis[nx]) continue; dfs1(nx, x); size[x] += size[nx]; mst[x] = max(mst[x], size[nx]); &#125; mst[x] = max(mst[x], sum - size[x]); if (mst[x] &gt; mst[root]) root = x;&#125; 分治过程 分治求解的过程大概是这样的： 1234567891011void solve(int x) &#123; vis[x] = 1; // app[0] = 1; calc(x); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (vis[nx]) continue; sum = size[x]; root = 0; dfs1(nx, 0); solve(nx); &#125;&#125; 现在可以公布\(vis\)的意思了：隔离子树和子树外的节点，以保证复杂度。 接下来考虑calc函数如何实现。 答案计算 因为只要处理第一类路径，所以计算答案的思路还是很简单：预处理每一棵子树中每一个点到根的距离，然后用后一棵子树更新前面所有子树的答案。 至于预处理距离，我们就需要实现另一个函数dfs2了。 12345678910111213141516int idx, dis[N], dis$[N];// idx: dfn// dis: 到根节点的距离// dis$: 按照dfs序存的dis// (顺便说一句，"$"也是合法的标识符，但是单独的"$"作为// **变量名**时可能会出现链接错误，最好别用)void dfs2(int x, int par) &#123; // 求dis dis$[++idx] = dis[x]; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == par || vis[nx]) continue; dis[nx] = dis[x] + e[i].w; dfs2(nx, x); &#125;&#125; 现在定义\(app_x\)(appear)为树中是否存在长度为\(x\)的简单路径的布尔值。 并且dis$的意义是可以使答案像01背包一样倒序更新，避免重复更新。 更新的方式类似于01背包： 1234567891011121314151617181920void calc(int x) &#123; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (vis[nx]) continue; idx = 0; dis[nx] = e[i].w; dfs2(nx, x); for (int j = idx; j; j--) &#123; // 更新答案 for (int k = 1; k &lt;= m; k++) &#123; ans[k] |= app[rec[k] - dis$[j]]; &#125; &#125; for (int j = idx; j; j--) &#123; // 更新app数组 q.push(dis$[j]); app[dis$[j]] = 1; &#125; &#125; while (!q.empty()) &#123; // 清空数组 app[q.front()] = 0; q.pop(); &#125;&#125; 代码 点分治框架 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace stdconst int N = 100005;struct edge &#123; int to, next, w;&#125; e[N];int head[N], cnt;void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y], z&#125;; head[y] = cnt;&#125;int size[N], mst[N], vis[N], root, sum;void dfs1(int x, int par) &#123; size[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (nx == par || vis[nx]) continue; dfs1(nx, x); size[x] += size[nx]; mst[x] = max(mst[x], size[nx]); &#125; mst[x] = max(mst[x], sum - size[x]); if (mst[x] &gt; mst[root]) root = x;&#125;// 存储答案// int ans[N], app[N];queue&lt;int&gt; q;int rec[N];int m;void calc(int x) &#123; // 计算答案&#125;void solve(int x) &#123; vis[x] = 1; // 初始化: app[0] = 1; calc(x); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (vis[nx]) continue; sum = size[x]; root = 0; dfs1(nx, 0); solve(nx); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>点分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构」Splay]]></title>
    <url>%2F2018%2F07%2F19%2Fsplay-notes%2F</url>
    <content type="text"><![CDATA[简介 Splay是一种平衡树，即优化后的二叉查找树。 ⚠️多图预警 图片均为原创，协议为CC0，_尽量_保留原地址。 劼司机的图片风格太赞啦 前置技能 线段树。 变量定义 N：常量，节点个数。 ch[N][2]：二维数组，ch[x][0]代表\(x\)的左儿子，ch[x][1]代表\(x\)的右儿子。 val[N]：一维数组，val[x]代表\(x\)存储的值。 cnt[N]：一维数组，cnt[x]代表\(x\)存储的重复权值的个数。 par[N]：一维数组，par[x]代表\(x\)的父节点。 size[N]：一维数组，size[x]代表\(x\)子树下的储存的权值数（包括重复权值）。 各种操作 chk操作 辅助操作，查询一个节点位于其父节点的方向。 123int chk(int x) &#123; return ch[par[x]][1] == x;&#125; pushup操作 辅助操作，更新size数组的值。 123void pushup(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125; 旋转(rotate) Splay使用旋转保持平衡。所以旋转是最重要的操作，也是最核心的操作。 Splay旋转后，中序遍历和Splay的合法性不变。 比如最开始的树是这样子的： 现在我们想把\(2\)号点搞到\(4\)号点的位置。 那么\(2\)下面的子树就有\(1,3,4,5\)。一种比较优秀的玩法是这样的： 那么我们可以考虑这么操作： 先把\(4\rightarrow2\)的边改成\(4\rightarrow3\)。 再把\(6\rightarrow4\)的边改成\(6\rightarrow2\)。 最后把\(2\rightarrow3\)的边改成\(2\rightarrow4\)。 第一次连边 第二次连边 第三次连边 连边前(原图) 旋转操作有四种。自行模拟后发现： 旋转后，父节点会将连向需旋转的该子节点的方向的边连向该子节点位于其父节点方向的反方向的节点。 令x = 该节点, y = par[x], k = chk(x), w = ch[x][k^1]，则ch[y][k] = w; par[w] = y; 旋转后，爷爷节点会将连向父节点的边连向需旋转的该节点。 ch[z][chk(y)] = x; par[x] = z; 旋转后，需旋转的该节点会将连向该子节点位于其父节点方向的反方向的子节点的边连向其父节点。 ch[x][k^1] = y; par[y] = x; 综合一下，得到下列代码(可见自然语言是多么的无力)： 1234567void rotate(int x) &#123; int y = par[x], z = par[y], k = chk(x), w = ch[x][k^1]; ch[y][k] = w; par[w] = y; ch[z][chk(y)] = x; par[x] = z; ch[x][k^1] = y; par[y] = x; pushup(y); pushup(x);&#125; 伸展(splay) 将一个节点一路rotate到指定节点的儿子。 注意，如果该节点、该父节点和该爷爷节点「三点一线」，那么应该先旋转父节点。 此处进行的操作是将\(3\) splay到根节点。 原图 旋转父节点后 旋转自身后 剩下的情况自行模拟没图片了。 并且注意处理爷爷节点已经是目标的情况。 1234567891011void splay(int x, int goal = 0) &#123; while (par[x] != goal) &#123; int y = par[x], z = par[y]; if (z != goal) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!goal) root = x;&#125; find操作 辅助操作，将最大的小于等于\(x\)的数所在的节点splay到根。 12345678void find(int x) &#123; if (!root) return; int cur = root; while (ch[cur][x &gt; val[cur]] &amp;&amp; x != val[cur]) &#123; cur = ch[cur][x &gt; val[cur]]; &#125; splay(cur);&#125; 插入(insert) 从根节点开始，一路搜索下去。如果节点存在则直接自增cnt的值。否则新建节点并与父节点连边。 因为新建节点时可能会拉出一条链，所以新建节点后需要将该节点splay到根节点。沿途的rotate操作可以使平衡树恢复平衡。 1234567891011121314151617void insert(int x) &#123; int cur = root, p = 0; while (cur &amp;&amp; val[cur] != x) &#123; p = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur) &#123; cnt[cur]++; &#125; else &#123; cur = ++ncnt; if (p) ch[p][x &gt; val[p]] = cur; ch[cur][0] = ch[cur][1] = 0; val[cur] = x; par[cur] = p; cnt[cur] = size[cur] = 1; &#125; splay(cur);&#125; 查询k大(kth) 从根节点开始，一路搜索下去。每次判断要走向哪个子树。注意考虑重复权值。 12345678910111213int kth(int k) &#123; int cur = root; while (1) &#123; if (ch[cur][0] &amp;&amp; k &lt;= size[ch[cur][0]]) &#123; cur = ch[cur][0]; &#125; else if (k &gt; size[ch[cur][0]] + cnt[cur]) &#123; k -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else &#123; return cur; &#125; &#125;&#125; 查询rank(rank) 并不需要专门写操作。将该节点find到根后返回左子树的权值数即可。 12find(x);printf("%d\n", size[ch[root][0]]); 前驱(pre) 将该节点find到根后返回左子树最右边的节点即可。 123456789int pre(int x) &#123; find(x); if (val[root] &lt; x) return root; int cur = ch[root][0]; while (ch[cur][1]) &#123; cur = ch[cur][1]; &#125; return cur;&#125; 后继(succ) 同理，返回右子树最左边的节点即可。 123456789int succ(int x) &#123; find(x); if (val[root] &gt; x) return root; int cur = ch[root][1]; while (ch[cur][0]) &#123; cur = ch[cur][0]; &#125; return cur;&#125; 删除(remove) 显然，任何一个数的前驱和后继之间只有它自身。 令该点的前驱为\(last\)，后继为\(next\)。 那么可以考虑把前驱splay到根，后继splay到前驱的右儿子，那么后继的左儿子就是要删除的点。 最后判特判权值数大于\(1\)的情况即可。 12345678910void remove(int x) &#123; int last = pre(x), next = succ(x); splay(last); splay(next, last); int del = ch[next][0]; if (cnt[del] &gt; 1) &#123; cnt[del]--; splay(del); &#125; else ch[next][0] = 0;&#125; 区间反转 考虑线段树维护区间标记的方法，将其移植到Splay即可。 打标记时，将\(l-1\)和\(r+1\)分别旋转到根节点和根节点右儿子处，那么\(r+1\)的左子树即是区间\([l,r]\)。在其根处打上标记然后在查询\(k\)大和输出中序遍历时下传标记即可。 123456789101112131415161718192021222324252627282930313233343536void pushdown(int x) &#123; if (rev[x]) &#123; swap(ch[x][0], ch[x][1]); rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1; rev[x] = 0; &#125;&#125;int kth(int k) &#123; int cur = root; while (1) &#123; pushdown(cur); if (ch[cur][0] &amp;&amp; k &lt;= size[ch[cur][0]]) &#123; cur = ch[cur][0]; &#125; else if (k &gt; size[ch[cur][0]] + cnt[cur]) &#123; k -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else &#123; return cur; &#125; &#125;&#125;void reverse(int l, int r) &#123; int x = kth(l), y = kth(r+2); splay(x); splay(y, x); rev[ch[y][0]] ^= 1;&#125;void output(int x) &#123; pushdown(x); if (ch[x][0]) output(ch[x][0]); if (val[x] &amp;&amp; val[x] &lt;= n) printf("%d ", val[x]); if (ch[x][1]) output(ch[x][1]);&#125; // 这张图有点小 区间打标记 平衡树像线段树一样，可以打标记。但是有一个不同点，就是平衡树的每个节点都有权值。所以更新标记时和线段树不一样，要考虑自身节点的权值。 因为Splay可以直接提取指定区间，所以Splay的区间操作在某些意义上比线段树还好写。 例题 P2042 维护数列 策爷：“splay/块状链表的自虐题。” 看到插入、删除、反转就很容易想到fhq-treapSplay。 简化版问题 如果只考虑修改、求和、求最大子段和，就可以直接用线段树解决。 考虑维护la[N]、ra[N]、gss[N]、sum[N]、upd[N]，分别代表最大前缀和、最大后缀和、最大子段和、区间和和修改标记。 初始化la、ra时，在选与不选之间取max即可。gss则初始化为叶子的值即可。 la[x] = ra[x] = max(0, sum[x]); gss[x] = sum[x]; 考虑如何维护la、ra、gss和sum。 1234la[x] = max(la[l], sum[l] + la[r]);ra[x] = max(ra[r], sum[r] + ra[l]);gss[x] = max(ra[l] + la[r], max(gss[l], gss[r]));sum[x] = sum[l] + sum[r]; 再考虑如何维护upd。 upd的存储方式其实有两种：一种是把需要更新的值存储起来，另一种是修改时直接更新完毕，然后再打上bool标记。这里我采用的是后者。 下传也简单。将整个区间set成同一个值后，la、ra和gss的更新与初始化有些相似。 la和ra的代码不变，gss改成在选全部与选一个之间取max(题目要求必须选一个)。 没了？当然还有。 完整版问题 现在多了插入、删除和区间反转，维护方法相似。这里我们先考虑每个点都有权值后的变化。 1234la[x] = max(la[l], sum[l] + (val[x]) + la[r]);ra[x] = max(ra[r], sum[r] + (val[x]) + ra[l]);gss[x] = max(ra[l] + (val[x]) + la[r], max(gss[l], gss[r]));sum[x] = sum[l] + (val[x]) + sum[r]; 其中用括号括起来的是增加的部分。 考虑同时下传反转和set两个标记。如果区间全部设置为一个值，反转也就没有意义了。所以处理顺序是set→反转。 pushdown的完整代码如下： 123456789101112131415161718192021222324void pushdown(int x) &#123; int l = ch[x][0], r = ch[x][1]; if (upd[x]) &#123; upd[x] = rev[x] = 0; if (l) &#123; upd[l] = 1; val[l] = val[x]; sum[l] = val[x] * size[l]; la[l] = ra[l] = max(sum[l], 0); gss[l] = val[x] &lt; 0 ? val[x] : sum[l]; &#125; if (r) &#123; upd[r] = 1; val[r] = val[x]; sum[r] = val[x] * size[r]; la[r] = ra[r] = max(sum[r], 0); gss[r] = val[x] &lt; 0 ? val[x] : sum[r]; &#125; &#125; if (rev[x]) &#123; rev[l] ^= 1; rev[r] ^= 1; rev[x] = 0; swap(la[l], ra[l]); swap(la[r], ra[r]); swap(ch[l][0], ch[l][1]); swap(ch[r][0], ch[r][1]); &#125;&#125; 垃圾回收 这个毒瘤题非常恶心，卡我空间，只好写个辣鸡垃圾回收。 删除的时候，把要删除的节点全部加到一个队列里。等到要插入的时候，优先使用队列里的点。 代码很好理解。 123456789101112131415161718192021222324252627void recycle(int x) &#123; if (ch[x][0]) recycle(ch[x][0]); if (ch[x][1]) recycle(ch[x][1]); q.push(x);&#125;int newNode(int x) &#123; int cur; if (q.empty()) cur = ++ncnt; else cur = q.front(), q.pop(); ch[cur][0] = ch[cur][1] = par[cur] = 0; val[cur] = sum[cur] = gss[cur] = x; la[cur] = ra[cur] = max(0, x); upd[cur] = rev[cur] = 0; size[cur] = 1; return cur;&#125;int build(int l, int r, int *arr) &#123; if (l &gt; r) return 0; int mid = (l+r)&gt;&gt;1, cur = newNode(arr[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid-1, arr))) par[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid+1, r, arr))) par[ch[cur][1]] = cur; pushup(cur); return cur;&#125; 其他用途 Splay因为其超强的区间操作能力，所以也作为LCT的辅助树使用。 Splay也可以搭配仙人掌剖分树链剖分，把一些序列上的题目出到仙人掌树上。 代码 下面附上我那常数巨大的代码，供参考用： 普通平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 200005;int ch[N][2], par[N], val[N], cnt[N], size[N], ncnt, root;bool chk(int x) &#123; return ch[par[x]][1] == x;&#125;void pushup(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125;void rotate(int x) &#123; int y = par[x], z = par[y], k = chk(x), w = ch[x][k^1]; ch[y][k] = w; par[w] = y; ch[z][chk(y)] = x; par[x] = z; ch[x][k^1] = y; par[y] = x; pushup(y); pushup(x);&#125;void splay(int x, int goal = 0) &#123; while (par[x] != goal) &#123; int y = par[x], z = par[y]; if (z != goal) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!goal) root = x;&#125;void insert(int x) &#123; int cur = root, p = 0; while (cur &amp;&amp; val[cur] != x) &#123; p = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur) &#123; cnt[cur]++; &#125; else &#123; cur = ++ncnt; if (p) ch[p][x &gt; val[p]] = cur; ch[cur][0] = ch[cur][1] = 0; par[cur] = p; val[cur] = x; cnt[cur] = size[cur] = 1; &#125; splay(cur);&#125;void find(int x) &#123; int cur = root; while (ch[cur][x &gt; val[cur]] &amp;&amp; x != val[cur]) &#123; cur = ch[cur][x &gt; val[cur]]; &#125; splay(cur);&#125;int kth(int k) &#123; int cur = root; while (1) &#123; if (ch[cur][0] &amp;&amp; k &lt;= size[ch[cur][0]]) &#123; cur = ch[cur][0]; &#125; else if (k &gt; size[ch[cur][0]] + cnt[cur]) &#123; k -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else &#123; return cur; &#125; &#125;&#125;int pre(int x) &#123; find(x); if (val[root] &lt; x) return root; int cur = ch[root][0]; while (ch[cur][1]) cur = ch[cur][1]; return cur;&#125;int succ(int x) &#123; find(x); if (val[root] &gt; x) return root; int cur = ch[root][1]; while (ch[cur][0]) cur = ch[cur][0]; return cur;&#125;void remove(int x) &#123; int last = pre(x), next = succ(x); splay(last); splay(next, last); int del = ch[next][0]; if (cnt[del] &gt; 1) &#123; cnt[del]--; splay(del); &#125; else ch[next][0] = 0;&#125;int n, op, x;int main() &#123; scanf("%d", &amp;n); insert(0x3f3f3f3f); insert(0xcfcfcfcf); while (n--) &#123; scanf("%d%d", &amp;op, &amp;x); switch (op) &#123; case 1: insert(x); break; case 2: remove(x); break; case 3: find(x); printf("%d\n", size[ch[root][0]]); break; case 4: printf("%d\n", val[kth(x+1)]); break; case 5: printf("%d\n", val[pre(x)]); break; case 6: printf("%d\n", val[succ(x)]); break; &#125; &#125;&#125; 文艺平衡树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005;int ch[N][2], par[N], val[N], cnt[N], size[N], rev[N], root, ncnt;int n, m, x, y;bool chk(int x) &#123; return ch[par[x]][1] == x;&#125;void pushup(int x) &#123; size[x] = size[ch[x][0]] + size[ch[x][1]] + cnt[x];&#125;void pushdown(int x) &#123; if (rev[x]) &#123; swap(ch[x][0], ch[x][1]); rev[ch[x][0]] ^= 1; rev[ch[x][1]] ^= 1; rev[x] = 0; &#125;&#125;void rotate(int x) &#123; int y = par[x], z = par[y], k = chk(x), w = ch[x][k^1]; ch[y][k] = w; par[w] = y; ch[z][chk(y)] = x; par[x] = z; ch[x][k^1] = y; par[y] = x; pushup(y); pushup(x); &#125;void splay(int x, int goal = 0) &#123; while (par[x] != goal) &#123; int y = par[x], z = par[y]; if (z != goal) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!goal) root = x;&#125;void insert(int x) &#123; int cur = root, p = 0; while (cur &amp;&amp; val[cur] != x) &#123; p = cur; cur = ch[cur][x &gt; val[cur]]; &#125; if (cur) &#123; cnt[cur]++; &#125; else &#123; cur = ++ncnt; if (p) ch[p][x &gt; val[p]] = cur; ch[cur][0] = ch[cur][1] = 0; par[cur] = p; val[cur] = x; cnt[cur] = size[cur] = 1; &#125; splay(cur);&#125;void find(int x) &#123; int cur = root; while (ch[cur][x &gt; val[cur]] &amp;&amp; val[cur] != x) &#123; cur = ch[cur][x &gt; val[cur]]; &#125; splay(cur);&#125;int kth(int k) &#123; int cur = root; while (1) &#123; pushdown(cur); if (ch[cur][0] &amp;&amp; k &lt;= size[ch[cur][0]]) &#123; cur = ch[cur][0]; &#125; else if (k &gt; size[ch[cur][0]] + cnt[cur]) &#123; k -= size[ch[cur][0]] + cnt[cur]; cur = ch[cur][1]; &#125; else &#123; return cur; &#125; &#125;&#125;void reverse(int l, int r) &#123; int x = kth(l), y = kth(r+2); splay(x); splay(y, x); rev[ch[y][0]] ^= 1;&#125;int pre(int x) &#123; find(x); if (val[root] &lt; x) return root; int cur = ch[root][0]; while (ch[cur][1]) cur = ch[cur][1]; return cur;&#125;int succ(int x) &#123; find(x); if (val[root] &gt; x) return root; int cur = ch[root][1]; while (ch[cur][0]) cur = ch[cur][0]; return cur;&#125;void output(int x) &#123; pushdown(x); if (ch[x][0]) output(ch[x][0]); if (val[x] &amp;&amp; val[x] &lt;= n) printf("%d ", val[x]); if (ch[x][1]) output(ch[x][1]);&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n+1; i++) insert(i); while (m--) &#123; scanf("%d%d", &amp;x, &amp;y); reverse(x, y); &#125; output(root);&#125; P2042 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000016;int size[N], sum[N], upd[N], rev[N], la[N], ra[N], gss[N];int val[N], ch[N][2], par[N], ncnt, root;queue&lt;int&gt; q;void recycle(int x) &#123; if (ch[x][0]) recycle(ch[x][0]); if (ch[x][1]) recycle(ch[x][1]); q.push(x);&#125;inline int newNode(int x) &#123; int cur; if (q.empty()) cur = ++ncnt; else cur = q.front(), q.pop(); ch[cur][0] = ch[cur][1] = par[cur] = 0; val[cur] = sum[cur] = gss[cur] = x; la[cur] = ra[cur] = max(0, x); upd[cur] = rev[cur] = 0; size[cur] = 1; return cur;&#125;inline bool chk(int x) &#123; return ch[par[x]][1] == x;&#125;inline void pushup(int x) &#123; int l = ch[x][0], r = ch[x][1]; size[x] = size[l] + size[r] + 1; sum[x] = sum[l] + sum[r] + val[x]; // 这里和线段树不同，线段树只有叶子上有权值，平衡树上所有点都有，必须+val[x] la[x] = max(la[l], sum[l] + val[x] + la[r]); ra[x] = max(ra[r], sum[r] + val[x] + ra[l]); gss[x] = max(ra[l] + val[x] + la[r], max(gss[l], gss[r]));&#125;inline void rotate(int x) &#123; int y = par[x], z = par[y], k = chk(x), w = ch[x][k^1]; ch[y][k] = w; par[w] = y; ch[z][chk(y)] = x; par[x] = z; ch[x][k^1] = y; par[y] = x; pushup(y); pushup(x);&#125;inline void pushdown(int x) &#123; int l = ch[x][0], r = ch[x][1]; if (upd[x]) &#123; upd[x] = rev[x] = 0; if (l) &#123; upd[l] = 1; val[l] = val[x]; sum[l] = val[x] * size[l]; la[l] = ra[l] = max(sum[l], 0); gss[l] = val[x] &lt; 0 ? val[x] : sum[l]; &#125; if (r) &#123; upd[r] = 1; val[r] = val[x]; sum[r] = val[x] * size[r]; la[r] = ra[r] = max(sum[r], 0); gss[r] = val[x] &lt; 0 ? val[x] : sum[r]; &#125; &#125; if (rev[x]) &#123; rev[l] ^= 1; rev[r] ^= 1; rev[x] = 0; swap(la[l], ra[l]); swap(la[r], ra[r]); swap(ch[l][0], ch[l][1]); swap(ch[r][0], ch[r][1]); &#125;&#125;inline void splay(int x, int goal = 0) &#123; while (par[x] != goal) &#123; int y = par[x], z = par[y]; if (z != goal) &#123; if (chk(x) == chk(y)) rotate(y); else rotate(x); &#125; rotate(x); &#125; if (!goal) root = x;&#125;int build(int l, int r, int *arr) &#123; if (l &gt; r) return 0; int mid = (l+r)&gt;&gt;1, cur = newNode(arr[mid]); if (l == r) return cur; if ((ch[cur][0] = build(l, mid-1, arr))) par[ch[cur][0]] = cur; if ((ch[cur][1] = build(mid+1, r, arr))) par[ch[cur][1]] = cur; pushup(cur); return cur;&#125;inline int kth(int k) &#123; int cur = root; while (1) &#123; pushdown(cur); if (ch[cur][0] &amp;&amp; k &lt;= size[ch[cur][0]]) &#123; cur = ch[cur][0]; &#125; else if (k &gt; size[ch[cur][0]] + 1) &#123; k -= size[ch[cur][0]] + 1; cur = ch[cur][1]; &#125; else &#123; return cur; &#125; &#125;&#125;inline void insert(int x, int y) &#123; int u = kth(x+1), v = kth(x+2); splay(u); splay(v, u); ch[v][0] = y; par[y] = v; pushup(v); pushup(u); &#125;inline int qsum(int x, int y) &#123; int u = kth(x), v = kth(x+y+1); splay(u); splay(v, u); return sum[ch[v][0]];&#125;inline int qgss() &#123; return gss[root];&#125;inline void remove(int x, int y) &#123; int u = kth(x), v = kth(x+y+1); splay(u); splay(v, u); recycle(ch[v][0]); ch[v][0] = 0; pushup(v); pushup(u);&#125;inline void reverse(int x, int y) &#123; int u = kth(x), v = kth(x+y+1); splay(u); splay(v, u); int w = ch[v][0]; if (!upd[w]) &#123; rev[w] ^= 1; swap(ch[w][0], ch[w][1]); swap(la[w], ra[w]); pushup(v); pushup(u); &#125;&#125;inline void update(int x, int y, int z) &#123; int u = kth(x), v = kth(x+y+1); splay(u); splay(v, u); int w = ch[v][0]; upd[w] = 1; val[w] = z; sum[w] = size[w] * z; la[w] = ra[w] = max(0, sum[w]); gss[w] = z &lt; 0 ? z : sum[w]; pushup(v); pushup(u);&#125;int n, m, arr[N], c, x, y, z;char buf[32];int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 2; i &lt;= n+1; i++) &#123; scanf("%d", arr+i); &#125; gss[0] = val[0] = 0xcfcfcfcf; arr[1] = arr[n += 2] = 0xcfcfcfcf; build(1, n, arr); root = 1; while (m--) &#123;// debug(); scanf("%s", buf); switch ((buf[2] + buf[1]) ^ *buf) &#123; case 'G'^('E'+'T'): scanf("%d%d", &amp;x, &amp;y); printf("%d\n", qsum(x, y)); break; case 'M'^('A'+'X'): printf("%d\n", qgss()); break; case 'R'^('E'+'V'): scanf("%d%d", &amp;x, &amp;y); reverse(x, y); break; case 'M'^('A'+'K'): scanf("%d%d%d", &amp;x, &amp;y, &amp;z); update(x, y, z); break; case 'D'^('E'+'L'): scanf("%d%d", &amp;x, &amp;y); remove(x, y); break; case 'I'^('N'+'S'): scanf("%d%d", &amp;x, &amp;y); memset(arr, 0, sizeof arr); for (int i = 1; i &lt;= y; i++) &#123; scanf("%d", arr+i); &#125; insert(x, build(1, y, arr)); break; &#125; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数据结构</tag>
        <tag>平衡树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「AHOI2009」维护序列 - 线段树]]></title>
    <url>%2F2018%2F07%2F10%2Fahoi2009-seq%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P2023 - 维护序列、洛谷 P3373 - 线段树2、BZOJ1798 - 维护序列 维护一段序列，支持区间加、区间乘和区间和操作。 解法 用线段树+Lazy Tag维护。注意考虑两个标记的优先级问题。 令\(val​\)为区间的值，\(add​\)为加的标记，\(mul​\)为乘的标记。现在要用\(add&#39;​\)和\(mul&#39;​\)来更新标记。其中「\(&#39;​\)」代表用新标记更新后的结果。 先加后乘： 规则：\(new\_val=(val+add)\times mul\)。 \(new\_val&#39;=((val+add)\times mul+add&#39;)\times mul&#39;\) 展开得\(val\times mul\times mul&#39;+add\times mul\times mul&#39;+add&#39;\times mul&#39;\) 整理得\((val+(add+\dfrac {add&#39;}{mul&#39;}))\times(mul\times mul&#39;)\) 发现有奇奇怪怪的分数，舍。 先乘后加： 规则：\(new_val=val\times mul+add\)。 \(new\_val&#39;=(val\times mul+add)\times mul&#39;+add&#39;\) 展开得\(val\times mul\times mul&#39;+add\times mul&#39;+add&#39;\) 整理得\(val\times(mul\times mul&#39;)+(add\times mul&#39;+add&#39;)\) 于是规则确定为「先乘后加」。 代码 正好学习下内存池。23333。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102// 内存池#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int p;struct node *newNode();struct node &#123; ll add, mul, val; node *lc, *rc; void pushup() &#123; val = (lc-&gt;val + rc-&gt;val) % p; &#125; void pushdown(int l, int r) &#123; int mid = (l+r)&gt;&gt;1; lc-&gt;val = (lc-&gt;val * mul + add * (mid - l + 1)) % p; rc-&gt;val = (rc-&gt;val * mul + add * (r - mid)) % p; lc-&gt;mul = lc-&gt;mul * mul % p; rc-&gt;mul = rc-&gt;mul * mul % p; lc-&gt;add = (lc-&gt;add * mul + add) % p; rc-&gt;add = (rc-&gt;add * mul + add) % p; add = 0; mul = 1; &#125; void build(int l, int r, int *arr) &#123; add = 0; mul = 1; if (l == r) &#123; val = arr[l]; return; &#125; int mid = (l+r)&gt;&gt;1; (lc = newNode())-&gt;build(l, mid, arr); (rc = newNode())-&gt;build(mid+1, r, arr); pushup(); &#125; void update1(int L, int R, int l, int r, int x) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; add = (add + x) % p; val = (val + x * (r - l + 1)) % p; return; &#125; int mid = (l+r)&gt;&gt;1; pushdown(l, r); if (L &lt;= mid) lc-&gt;update1(L, R, l, mid, x); if (mid &lt; R) rc-&gt;update1(L, R, mid+1, r, x); pushup(); &#125; void update2(int L, int R, int l, int r, int x) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; val = val * x % p; add = add * x % p; mul = mul * x % p; return; &#125; int mid = (l+r)&gt;&gt;1; pushdown(l, r); if (L &lt;= mid) lc-&gt;update2(L, R, l, mid, x); if (mid &lt; R) rc-&gt;update2(L, R, mid+1, r, x); pushup(); &#125; ll query(int L, int R, int l, int r) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return val; &#125; int mid = (l+r)&gt;&gt;1; ll ret = 0; pushdown(l, r); if (L &lt;= mid) ret = (ret + lc-&gt;query(L, R, l, mid)) % p; if (mid &lt; R) ret = (ret + rc-&gt;query(L, R, mid+1, r)) % p; return ret; &#125;&#125; pool[500005], *null = pool, *root;node *newNode() &#123; static node *ptr = pool+1; ptr-&gt;lc = null; ptr-&gt;rc = null; return ptr++;&#125;int n, m, op, x, y, z, rec[100005];int main() &#123; scanf("%d%d%d", &amp;n, &amp;m, &amp;p); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec+i); &#125; (root = newNode())-&gt;build(1, n, rec); while (m--) &#123; scanf("%d%d%d", &amp;op, &amp;x, &amp;y); if (op ^ 3) scanf("%d", &amp;z); if (op == 1) &#123; root-&gt;update2(x, y, 1, n, z); &#125; else if (op == 2) &#123; root-&gt;update1(x, y, 1, n, z); &#125; else &#123; printf("%lld\n", root-&gt;query(x, y, 1, n)); &#125; &#125; return 0;&#125; 拓展 维护一段序列。 修改：区间加、区间乘、区间乘方(\(exp\in \mathbb{R}\))、区间set。 查询：区间和、区间乘积、区间max、区间min、区间中位数、区间众数、区间GCD、区间LCM、区间最大子段和、区间LIS、两个区间的LCS。 限制：强制在线、可持久化(历史版本)。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>AHOI</tag>
        <tag>线段树</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 999D」Equalize the Remainders - 贪心]]></title>
    <url>%2F2018%2F06%2F22%2Fcodeforces-999d%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 999D - Equalize the Remainders 有\(n\)个数，每次操作可以将某一个数加\(1\)。问最少要多少次可以使它们模\(m\)的结果平均。保证\(m\)能被\(n\)整除。需输出最少次数和最终结果。 解法 贪心。考虑将其模\(m\)然后统计每一个模数出现次数与\(\dfrac nm\)的差。然后对于每个数，如果该数模数的出现次数多余于\(\dfrac nm\)，那么将这个数的余数改为与其最近的少于\(\dfrac nm\)的位置。 123456789101112131415161718192021222324252627282930313233input:10 108 8 8 9 9 9 9 9 2 7-------------------------------------8 8 8 9 9 9 9 9 2 7vv10 8 8 9 9 9 9 9 2 7 (2) vv10 11 8 9 9 9 9 9 2 7 (3) vv10 11 8 9 9 9 9 9 2 7 (0) vv10 11 8 13 9 9 9 9 2 7 (4) vv10 11 8 13 14 9 9 9 2 7 (5) vv10 11 8 13 14 15 9 9 2 7 (6) vv10 11 8 13 14 15 16 9 2 7 (7) vv10 11 8 13 14 15 16 9 2 7 (0) vv10 11 8 13 14 15 16 9 2 7 (0) vv10 11 8 13 14 15 16 9 2 7 (0)2 + 3 + 4 + 5 + 6 + 7 = 27output:2710 11 8 13 14 15 16 9 2 7 代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;long long rec[200005], ans;int mod[200005];int n, m, k, x;set&lt;int&gt; q;int start;int main() &#123; scanf("%d%d", &amp;n, &amp;m); k = n / m; for (int i = 1; i &lt;= n; i++) &#123; scanf("%I64d", rec+i); mod[rec[i] % m]++; &#125; for (int i = 0; i &lt; m; i++) &#123; mod[i] -= k; if (mod[i] &lt; 0) q.insert(i); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (mod[rec[i] % m] &gt; 0) &#123; set&lt;int&gt;::const_iterator it = q.lower_bound(rec[i] % m); if (it == q.end()) it = q.begin(); if (!++mod[x = *it]) q.erase(it); mod[rec[i] % m]--; ans += (m + x - rec[i] % m) % m; rec[i] += (m + x - rec[i] % m) % m; &#125; &#125; printf("%I64d\n", ans); for (int i = 1; i &lt;= n; i++) &#123; printf("%I64d ", rec[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」AC自动机]]></title>
    <url>%2F2018%2F06%2F07%2Faho-corasick-automaton-notes%2F</url>
    <content type="text"><![CDATA[简介 AC自动机是一种用来进行多模式匹配的算法。 或者说，给你一个文本串和若干个模式串，问你每个模式串的出现位置。 先决条件 KMP、Trie。 概述 AC自动机相当于是在Trie树上跑KMP。 KMP有失配函数，AC自动机有失配指针。 失配指针的定义参照KMP。 匹配 匹配时从根节点开始。 没有需要的子节点，那么就一直往失配指针跳，直到出现那个子节点或到根。 如果匹配到完整的模式串，就匹配到了模式串和失配指针那一条链上的所有的字符串。 其他情况就直接往子节点跳。 代码如下： 1234567891011int query(const char *str) &#123; int pos = 0, ans = 0, n = strlen(str); for (int i = 0; i &lt; n; i++) &#123; pos = trie[pos][str[i] - 97]; for (int t = pos; t/* &amp;&amp; ~val[t] */; t = fail[t]) &#123; ans += val[t]; // val[t] = -1; &#125; &#125; return ans;&#125; 失配指针 从根到某个点的失配指针得到的字符串与该点的等长后缀相同且该字符串是最长的。 一个点的失配指针取决于其父亲的失配指针。 一个点失配指针的求法如下： 首先跳到父亲的失配指针处。 如果跳到根，那么失配指针指向根。 如果当前位置包含源点包含的字符的子节点，那么失配指针指向该子节点。 否则跳到当前位置的失配指针处。 回到步骤2。 每一次都向上跳太麻烦。可以考虑把所有不存在的子节点指向失配指针。 因为要用到父节点，所以可以广搜（应该也可以深搜？没试过） 这样代码就可以这样写了： 1234567891011121314151617181920212223void ac() &#123; queue&lt;int&gt; bfs; // fail[0] = 0; 这个随便取多少 for (int i = 0; i &lt; 26; i++) &#123; // 一定要特判 int nx = trie[0][i]; if (nx) &#123; fail[nx] = 0; bfs.push(nx); &#125; &#125; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = 0; i &lt; 26; i++) &#123; int&amp; nx = trie[pos][i]; if (nx) &#123; fail[nx] = trie[fail[pos]][i]; bfs.push(nx); &#125; else &#123; nx = trie[fail[pos]][i]; &#125; &#125; &#125;&#125; 代码 用于Accepted洛谷 P3808 - 【模板】AC自动机（简单版） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int trie[1000006][26], cnt;int fail[1000006];int val[1000006];void add(const char *str) &#123; int pos = 0, n = strlen(str); for (int i = 0; i &lt; n; i++) &#123; int nx = str[i] - 97; if (!trie[pos][nx]) &#123; trie[pos][nx] = ++cnt; &#125; pos = trie[pos][nx]; &#125; val[pos]++;&#125;void ac() &#123; queue&lt;int&gt; bfs; // fail[0] = 0; 这个随便取多少 for (int i = 0; i &lt; 26; i++) &#123; // 一定要特判 int nx = trie[0][i]; if (nx) &#123; fail[nx] = 0; bfs.push(nx); &#125; &#125; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = 0; i &lt; 26; i++) &#123; int&amp; nx = trie[pos][i]; if (nx) &#123; fail[nx] = trie[fail[pos]][i]; bfs.push(nx); &#125; else &#123; nx = trie[fail[pos]][i]; &#125; &#125; &#125;&#125;int query(const char *str) &#123; int pos = 0, ans = 0, n = strlen(str); for (int i = 0; i &lt; n; i++) &#123; pos = trie[pos][str[i] - 97]; for (int t = pos; t &amp;&amp; ~val[t]; t = fail[t]) &#123; ans += val[t]; val[t] = -1; &#125; &#125; return ans;&#125;char buf[1000006];int n;int main() &#123; for (scanf("%d", &amp;n); n--; ) &#123; scanf("%s", buf); add(buf); &#125; ac(); scanf("%s", buf); printf("%d", query(buf)); return 0;&#125; 未完 还有一种科技叫last数组。施工中……]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>AC自动机</tag>
        <tag>字符串</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」KMP]]></title>
    <url>%2F2018%2F06%2F01%2Fkmp-notes%2F</url>
    <content type="text"><![CDATA[简介 KMP是一种在线性时间执行单模式串字符串匹配（以及其他一些问题）的算法。 BF算法 所谓的「BF算法」，也就是brute-force算法，时间复杂度是\(O(nm)\)的。也就是暴力匹配。 这显然是不行的，于是我们考虑优化。 优化 显然，并不是所有的匹配都是必要的。有一些匹配是注定不会成功的。 如下面的例子： 123baaababaabbaabbbaabx aababaabx ^ 当已经进行到这一步时，显然如果只往右边移动一位 123baaababaabbaabbbaabx aababaabx ^ 那么肯定是不能匹配上的。 注意到 1234baaababaabbaabbbaabx aababaabx --- --- ^ 中用-标记出的两段是相同的且第二段的右端点正好是最后一个匹配到的字符。那么肯定只有把左端点移到第二段的左端点才会对答案有贡献了。所以失配后可以直接跳到 123baaababaabbaabbbaabx aababaabx --- 这可就省了一大截时间了:smile:。 怎么在程序里实现呢？ 失配函数 失配函数，即「next数组」或「fail数组」。 这里统一使用「fail数组」。 令x = fail[i]，则S[0...x]和以i为右端点的等长后缀相等且x为最大值。例如 12string: a a b a b a a bfail : 0 1 0 1 0 1 2 3 我们暂时不考虑fail的求法。 这里的S[0...x]就是上面例子 1234baaababaabbaabbbaabx aababaabx --- --- ^ 中的第一段，后缀就是例子中的第二段。 考虑到连续跳跃的可能性，代码实现如下： 123while (match &gt;= 0 &amp;&amp; pattern[match + 1] != src[i]) &#123; match = fail[match];&#125; 其中i为源串匹配到的下标，match为模式串匹配到的下标。 加上匹配部分，我们可以得到以下代码： 123456789101112131415void kmp() &#123; getfail(); int match = -1; for (int i = 0; i &lt; n; i++) &#123; while (match &gt;= 0 &amp;&amp; pattern[match + 1] != src[i]) &#123; match = fail[match]; &#125; if (pattern[match + 1] == src[i]) &#123; match++; if (match == m-1) &#123; printf("%d\n", i - m + 2); &#125; &#125; &#125;&#125; 失配函数的求法 fail数组其实求起来很像。相当于是自己匹配自己。代码如下： 12345678910111213void getfail() &#123; fail[0] = -1; int match = -1; for (int i = 1; i &lt; m; i++) &#123; while (match &gt;= 0 &amp;&amp; pattern[match + 1] != pattern[i]) &#123; match = fail[match]; &#125; if (pattern[match + 1] == pattern[i]) &#123; match++; &#125; fail[i] = match; &#125;&#125; 代码 用于Accepted洛谷 P3375 - 【模板】KMP字符串匹配的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;char src[1000006], pattern[1000006];int fail[1000006];int n, m;void getfail() &#123; fail[0] = -1; int match = -1; for (int i = 1; i &lt; m; i++) &#123; while (match &gt;= 0 &amp;&amp; pattern[match + 1] != pattern[i]) &#123; match = fail[match]; &#125; if (pattern[match + 1] == pattern[i]) &#123; match++; &#125; fail[i] = match; &#125;&#125;void kmp() &#123; getfail(); int match = -1; for (int i = 0; i &lt; n; i++) &#123; while (match &gt;= 0 &amp;&amp; pattern[match + 1] != src[i]) &#123; match = fail[match]; &#125; if (pattern[match + 1] == src[i]) &#123; match++; if (match == m-1) &#123; printf("%d\n", i - m + 1 + 1); &#125; &#125; &#125;&#125;int main() &#123; scanf("%s%s", src, pattern); n = strlen(src); m = strlen(pattern); kmp(); for (int i = 0; i &lt; m; i++) &#123; printf("%d ", fail[i] + 1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>模板</tag>
        <tag>KMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 P1262」间谍网络 - 强连通分量]]></title>
    <url>%2F2018%2F05%2F30%2Fluogu-1262%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1262 - 间谍网络 国家内部出现了一些间谍。有一部分间谍给钱就能控制。如果控制了一个间谍就可以控制其他的一些间谍。问最少需要多少钱可以控制所有的间谍。或者说这是不可能的。 可以说是非常模板的一道题了。 解法 显然如果一个强连通分量中有一个间谍被控制了，那么整个强连通分量(里的间谍)就都被控制了。 显然在图中没有环的时候，控制了所有入度为0的间谍就可以控制整张图。 缩点后维护两个信息：控制这个强连通分量所需的最少的钱数和强连通分量里编号最小的点。 根据上面的结论，显然可以推出，如果入度为0的点控制不了那么就NO了。 于是我们可以强连通分量缩点之后在DAG上按照上面的策略dfs就好了。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int from, to, next;&#125; e[20004];int deg[3003], srcv[3003], val[3003], controlled;int head[3003], cnt, ans, m;bool vis[3003];void addedge(int x, int y) &#123; e[++cnt] = (edge)&#123;x, y, head[x]&#125;; head[x] = cnt;&#125;int idx, scnt, dfn[3003], low[3003], scc[3003], id[3003];stack&lt;int&gt; st;void tarjan(int x) &#123; dfn[x] = low[x] = ++idx; vis[x] = true; st.push(x); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (!dfn[nx]) &#123; tarjan(nx); low[x] = min(low[x], low[nx]); &#125; else if (vis[nx]) &#123; low[x] = min(low[x], dfn[nx]); &#125; &#125; if (dfn[x] == low[x]) &#123; val[++scnt] = srcv[x]; id[scnt] = x; // printf("scc #%d:\n", scnt); while (!st.empty()) &#123; int _ = st.top(); st.pop(); // printf("%d\n", _); scc[_] = scnt; vis[_] = false; id[scnt] = min(id[scnt], _); val[scnt] = min(val[scnt], srcv[_]); if (_ == x) return; &#125; &#125;&#125;void dfs(int x) &#123; if (vis[x]) return; vis[x] = true; controlled++; for (int i = head[x]; i; i = e[i].next) &#123; dfs(e[i].to); &#125;&#125;int n, k, x, y;int main() &#123; memset(srcv, 0x3f, sizeof srcv); scanf("%d%d", &amp;n, &amp;k); while (k--) &#123; scanf("%d%d", &amp;x, &amp;y); srcv[x] = min(srcv[x], y); &#125; scanf("%d", &amp;k); while (k--) &#123; scanf("%d%d", &amp;x, &amp;y); addedge(x, y); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) tarjan(i); &#125; n = scnt; m = cnt; memset(head, 0, sizeof head); cnt = 0; memset(vis, 0, sizeof vis); for (int i = 1; i &lt;= m; i++) &#123; if (scc[e[i].from] != scc[e[i].to]) &#123; deg[scc[e[i].to]]++; addedge(scc[e[i].from], scc[e[i].to]); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!deg[i]) &#123; if (val[i] == 0x3f3f3f3f) &#123; printf("NO\n%d", id[i]); return 0; &#125; ans += val[i]; dfs(i); &#125; &#125; assert(controlled == n); printf("YES\n%d", ans); return 0;&#125; 总结 很多DAG上的东西在一般的有向图上很难做，这是就可以考虑用Tarjan将图变成DAG。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>缩点</tag>
        <tag>DAG</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」差分约束系统]]></title>
    <url>%2F2018%2F05%2F29%2Fsystem-of-difference-constraints-notes%2F</url>
    <content type="text"><![CDATA[简介 差分约束系统是一类不等式组。其中每一个不等式都是\(x_a-x_b\ge c\)的形式。 流程 对于每一个不等式\(x_a-x_b\ge c\)，都有\(x_a-x_b\ge c\Rightarrow x_a-c\ge x_b\)。可以转化为下面这张图： 同理，对于\(x_a-x_b\le c\)，都有\(x_a-x_b\le c\Rightarrow x_b+c\ge x_a\)。可以转化为下面这张图： 同理，对于\(x_a-x_b=c\)，都有\(x_a-x_b=c\Rightarrow c\le x_a-x_b\le c\)。可以转化为下面这张图： 差分约束系统可以使用最短路计算。(因为有负权边，所以一般使用队列优化的Bellman-Ford算法) 算法初始化时，会从0号节点向每一个节点连一条长度为0的边(\(x_0-x_a\ge0\Rightarrow x_0\le x_a\)，不影响结果)，以保证整个差分约束系统全部被计算到。 可以证明，若图中有负环，则差分约束系统无解。 理解不了？ 比如第一张图： 可以理解为点a和点b都有一个点权，这个点权既是dis(最短路)数组又是差分约束系统的解。 因为两个点之间满足dis[a]+(-c)&lt;=dis[b](最短路性质)，而且左边的式子正好就是原不等式。 所以我们就能把不等式转换到图上啦~ 代码 该代码用于Accepted洛谷 P1993 - 小K的农场。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int to, next, w;&#125; e[1000006];int op, n, m, u, v, w;int head[200005], cnt;bool flag[200005];bool vis[200005];int dis[200005];int upd[200005];void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z&#125;; head[x] = cnt;&#125;int spfa(int x) &#123; vis[x] = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (dis[nx] &gt; dis[x] + e[i].w) &#123; dis[nx] = dis[x] + e[i].w; upd[nx] = upd[x] + 1; if (upd[nx] &gt; n) return 0; if (!vis[nx]) &#123; vis[nx] = 1; if (!spfa(nx)) return 0; &#125; &#125; &#125; return 1;&#125;int main() &#123; for (scanf("%d%d", &amp;n, &amp;m); m--; ) &#123; scanf("%d%d%d", &amp;op, &amp;u, &amp;v); if (op == 3) &#123; addedge(u, v, 0); addedge(v, u, 0); continue; &#125; scanf("%d", &amp;w); if (op == 1) &#123; addedge(u, v, -w); &#125; else &#123; addedge(v, u, w); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; addedge(0, i, 0); &#125; memset(dis, 0x3f, sizeof dis); dis[0] = 0; puts(spfa(0) ? "Yes" : "No"); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Pollard-Rho算法]]></title>
    <url>%2F2018%2F05%2F24%2Fpollard-rho-notes%2F</url>
    <content type="text"><![CDATA[简介 Pollard-Rho是一种用来快速找到一个数的一个因子的算法。 生日悖论 23个人之间有人生日相同的概率超过50%。 有这么玄学的悖论那我们就可以随机分解了23333。 于是我们试除时就不用盲目选数了。 Pollard-Rho算法 现在有一个伪随机函数\(f(x)=(x^2+c)\bmod n,c=\text{rand}()\)。 然后每次判断\(\gcd(|a-b|,n)\)是不是大于\(1\)就好了。玄学证明：这个伪随机函数效果不错。 但是如果出现死循环了怎么办？ 我们有Floyd发明的机智判环算法。弄两个数字\(a\)和\(b\)。每次使\(a=f(a),b=f(f(b))\)。 如果发现\(a=b\)那么显然\(b\)已经走完至少一个圈了。那时我们就可以直接return了。 时间复杂度\(O(\text{玄学})\) or \(O(n^\frac14)\)。 分解之前先要Miller-Rabin素性测试下。 代码 这里有一份可以Accepted洛谷 P1075 - 质因数分解的代码： 因为题目保证了正整数n是两个不同的质数的乘积 ，于是就不用米勒拉宾了。 12345678910111213141516171819202122232425262728293031#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const ll c = 20060516;ll f(ll x, ll n) &#123; return (x * x + c) % n;&#125;ll pollard(ll x) &#123; begin: ll a = rand() % x, b = a; while (1) &#123; a = f(a, x); b = f(f(b, x), x); if (a == b) goto begin; ll p = __gcd(__builtin_llabs(a - b), x); if (p &gt; 1) return p; &#125;&#125;ll n, x;int main() &#123; scanf("%lld", &amp;n); x = pollard(n); printf("%lld", max(x, n/x)); return 0;&#125; 拓展 好像有一种东西叫做Brent判环，比Floyd判环高效。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>Pollard-Rho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Miller-Rabin算法]]></title>
    <url>%2F2018%2F05%2F22%2Fmiller-rabin-notes%2F</url>
    <content type="text"><![CDATA[简介 fAKe： Miller-Rabin算法是目前主流的基于概率的素数测试算法，在构建密码安全体系中占有重要的地位。通过比较各种素数测试算法和对Miller-Rabin算法进行的仔细研究，证明在计算机中构建密码安全体系时， Miller-Rabin算法是完成素数测试的最佳选择。通过对Miller-Rabin算法底层运算的优化，可以取得较以往实现更好的性能。…… REAL： Miller-Rabin算法是一种用来判断素数的概率算法。 概念 费马小定理 对于素数\(p\)。若有整数\(0&lt;a&lt;p\)，则有\(a^{p-1}\equiv1\pmod p\)。 可惜就算试遍所有的\(a\)，也不能保证\(p\)是个质数。这种测试叫费马测试。 即费马定理的逆命题是错的。 二次探测定理 对于奇素数\(p\)，若有整数\(0&lt;x&lt;p\)满足方程\(x^2\equiv1\pmod p\)，则方程的解为\(x_1=1,x_2=p-1\)。 二次探测定理的逆命题是对的。 接下来我们假设待测试的数是\(n\)。 特殊 假设天上掉下来一个结论说\(341\)可以通过\(a=2\)时的费马测试。那么有\(2^{340}\equiv1\pmod{341}\)。 根据二次探测定理，有\(2^{170}\equiv1\text{ or }340\pmod{341}\)。测试之后发现是对的。 但是当我们测试\(2^{85}\bmod341\)是，却发现等于\(32\)。然后我们就得出\(341\)并不是素数了。 一般 现在假设\(a\)还是等于\(2\)。 其实上面的过程就是把\(n-1\)分解为\(2^s\cdot t\)的形式(\(t\)为奇数)。 然后根据二次探测定理。\((a^t)^2\equiv1\pmod n\Rightarrow x_1=1,x_2=n-1\)。 式子中的\((a^t)^2\)也就是\(a^{2t}\)。 所以我们可以让指数从\(t\)开始，不停的翻倍(s++)，然后每次计算\(a^{2^it}\bmod n\)的值。 最后测试\(a^{p-1}\)(即\(a^{2^st}\))即可。 对于任意给定的正整数\(a\)，如果通过了上述的所有步骤，则称n通过了以a为底的Miller-Rabin测试。 然后我们多试几个\(a\)就好了。 代码 这里有一份可以Accepted洛谷 P3383 - 线性筛素数的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;const int testcase[3] = &#123;2, 7, 61&#125;;ll pow_mod(ll x, ll y, int z) &#123; ll ret = 1; while (y) &#123; if (y&amp;1) ret = ret * x % z; x = x * x % z; y &gt;&gt;= 1; &#125; return ret;&#125;bool check(int p, int x) &#123; int s = 0, t = p-1; while (1&amp;~t) &#123; t &gt;&gt;= 1; s++; &#125; ll mod = pow_mod(x, t, p); if (mod == 1 || mod == p-1) return true; while (s--) &#123; mod = mod * mod % p; if (mod == p-1) return true; // 1 * 1 = 1 &#125; return false;&#125;bool prime(int x) &#123; if (x == 2 || x == 7 || x == 61) return true; if (x == 1 || 1&amp;~x || !(x%7) || !(x%61)) return false; for (int i = 0; i &lt; 3; i++) &#123; if (!check(x, testcase[i])) return false; &#125; return true;&#125;int n, x;int main() &#123; for (scanf("%*d%d", &amp;n); n--; ) &#123; scanf("%d", &amp;x); puts(prime(x) ? "Yes" : "No"); &#125; return 0;&#125; 总结 老祖宗告诉我们，若\(n\)通过一次测试，则\(n\)是合数的几率就只有原来的\(\dfrac14\)。 并且有以下结论： if n &lt; 2,047, it is enough to test a = 2; if n &lt; 1,373,653, it is enough to test a = 2 and 3; if n &lt; 9,080,191, it is enough to test a = 31 and 73; if n &lt; 25,326,001, it is enough to test a = 2, 3, and 5; if n &lt; 3,215,031,751, it is enough to test a = 2, 3, 5, and 7; if n &lt; 4,759,123,141, it is enough to test a = 2, 7, and 61; if n &lt; 1,122,004,669,633, it is enough to test a = 2, 13, 23, and 1662803; if n &lt; 2,152,302,898,747, it is enough to test a = 2, 3, 5, 7, and 11; if n &lt; 3,474,749,660,383, it is enough to test a = 2, 3, 5, 7, 11, and 13; if n &lt; 341,550,071,728,321, it is enough to test a = 2, 3, 5, 7, 11, 13, and 17; if n &lt; 1016 and n ≠ 46,856,248,255,981, it is enough to test a = 2, 3, 7, 61, and 24251; if n &lt; 3,825,123,056,546,413,051, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, and 23; if n &lt; 18,446,744,073,709,551,616 = 264, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37; if n &lt; 318,665,857,834,031,151,167,461, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37; if n &lt; 3,317,044,064,679,887,385,961,981, it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41. 加粗的两条看起来很好用。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>Miller-Rabin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「数据结构」树状数组 (+6)]]></title>
    <url>%2F2018%2F05%2F20%2Fbit-notes%2F</url>
    <content type="text"><![CDATA[树状数组，顾名思义望文生义，就是树状的数组。 树状数组，就是压了一半空间的zkw线段树，就是没有右子树的线段树&quot;堆式存储&quot;后的数组。 (这里所有的操作全都是区间加，区间和) UPD： 2018-03-29 20:55:23：Initial Commit 2018-04-01 22:44:36：Add 支持区间查询 代码3 2018-04-05 18:39:15：Add 二维树状数组,Change[Everything](更改排版、格式) 2018-05-20 [数据删除]：Add二维树状数组·区间查询,Add例题列表,Change高维树状数组？ 概念 树状数组长这样： 观察数组下标的二进制和树，得 1234567891 12 103 114 1005 1016 1107 1118 1000... 注意到每一层最左边的点都是\(2^n\)数列上的数。如果按照树形结构排列这些下标，得 其中同一个父节点的子节点，越靠左的在上上面的图中越浅。 然后我们发现，每个点和它的父节点都有些微妙的联系。具体地，就是每一个点的下标加上该下标的lowbit等于它的父节点的下标。 什么是lowbit呢？如\((100101001100)_2\)的lowbit就是\((100)_2\)。它可以通过x&amp;-x求出来。 一维树状数组 单点修改+区间查询 区间查询 因为树状数组只有右子树，所以树状数组只能进行前缀查询。方法是把一个点所在的子树和它左边的所有子树全部加起来。 注意到树状数组还有一个性质：一个点加上自身的lowbit，得到的点正好是高于该点的左边第一个节点。 听起来很绕，代个例子就知道了： 如查询\(1\)~\(7\)时需要访问的点(显然是\(\log n\)量级的)： 这些点的下标分别是\(7\)，\(7-lowbit(7)=6\)，\(6-lowbit(6)=4\)…… 单点修改 修改一个点的值，只需要修改它到根沿路上所有的点即可。 那么这些点满足上面的性质，所以只需要一直减去当前下标的lowbit，然后进行相应的修改即可。 下面提供树状数组最基本实现的代码。 代码 这里提供Accepted洛谷 P3374 【模板】树状数组 1的代码。 1234567891011121314151617181920212223242526272829303132333435#include &lt;bits/stdc++.h&gt;int n, m, op, u, v;int rec[500005];int inp[500005];inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x) &#123; for (; i &lt;= n; i += lowbit(i)) rec[i] += x;&#125;int query(int i) &#123; int ret = 0; for (; i; i -= lowbit(i)) ret += rec[i]; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", inp + i); add(i, inp[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;op, &amp;u, &amp;v); if (op == 1) &#123; add(u, v); &#125; else &#123; printf("%d\n", query(v) - query(u - 1)); &#125; &#125;&#125; 区间修改+单点查询 树状数组是可以支持区间修改的。 方法是把原数组的差分数组存在树状数组里。这样区间修改就变成了两个单点修改。如将区间\([u,v)\)的所有数加上\(w\)，那么相当于在它的差分数组的第\(u\)个数加\(w\)，第\(v\)个数减\(w\)。 这样可以比较简单的实现区间修改和单点查询。 代码 这里提供Accepted洛谷 P3368 【模板】树状数组 2的代码。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;int n, m, op, u, v, w, l;int rec[500005];int inp[500005];inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x) &#123; for (; i &lt;= n; i += lowbit(i)) rec[i] += x;&#125;int query(int i) &#123; int ret = 0; for (; i; i -= lowbit(i)) ret += rec[i]; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", inp + i); add(i, inp[i] - l); l = inp[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;op, &amp;u); if (op == 1) &#123; scanf("%d%d", &amp;v, &amp;w); add(u, w); add(v + 1, -w); &#125; else &#123; printf("%d\n", query(u)); &#125; &#125;&#125; 区间修改+区间查询 都支持区间修改了怎么能不支持区间查询？ 还是用差分。 \[ \begin{align*} a_1+a_2+\cdots+a_i&amp;=(tree_1)+(tree_1+tree_2)+\cdots+(tree_1+tree_2+\cdots+tree_i)\\ &amp;=i\cdot(tree_1+tree_2+\cdots+tree_i)-(i-1)\cdot tree_2-(i-2)tree_3-\cdots-tree_{i-1} \end{align*} \] 于是可以开两个树状数组，一个存\(tree_i\)，一个存\(i\cdot tree_i\)。 结束了？结束了。 代码 支持区间修改+区间查询，也就是洛谷线段树1要支持的操作了。 这里提供Accepted洛谷 P3372 【模板】线段树 1的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;long long rec2[500005];long long rec[500005];long long inp[500005];long long l, u, v, w;int n, m, op;inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x, long long *arr) &#123; for (; i &lt;= n; i += lowbit(i)) arr[i] += x;&#125;long long query(int i, long long *arr) &#123; long long ret = 0; for (; i; i -= lowbit(i)) ret += arr[i]; return ret;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%lld", inp + i); add(i, inp[i] - l, rec); add(i, (i - 1) * (inp[i] - l), rec2); l = inp[i]; &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%lld%lld", &amp;op, &amp;u, &amp;v); if (op == 1) &#123; scanf("%lld", &amp;w); add(u, w, rec); add(v + 1, -w, rec); add(u, w * (u - 1), rec2); add(v + 1, -w * v, rec2); &#125; else &#123; printf("%lld\n", query(v, rec) * v - query(v, rec2) - query(u - 1, rec) * (u - 1) + query(u - 1, rec2)); &#125; &#125;&#125; 总结 :exclamation::exclamation::exclamation:重点：树状数组中的第个元素表示右端点为，长度为的闭区间。或者说。这也是为什么查询的时候要一直减去lowbit。这样可以&quot;倍增&quot;的覆盖整个区间。 二维树状数组 类比总结1中的线性树状数组，二维树状数组中的\(tree_{i,j}\)表示右下角为\((i,j)\)，长为\(lowbit(i)\)，宽为\(lowbit(j)\)的矩阵。 单点修改+区间查询 首先我们把二维树状数组想象成树状&quot;树状数组&quot;数组(树状数组套树状数组)。 然后再次类比总结1中的树状数组结构。现在假设我们要将\((x,y)\)加\(z\)。 单点修改 可以考虑把\([1,x]\)中的所有\([1,y]\)都加上\(z\)。然后可以用树状数组的lowbit优化复杂度，于是就变成\(O(\log^2n)\)的复杂度了。 区间查询 区间查询就是容斥。求\([(x_1,y_1),(x_2,y_2)]\)的子矩阵和就是\(query(x_2,y_2)-query(x_1-1,y_2)-query(x_2,y_1-1)+query(x_1-1,y_1-1)\)。 模板题1 (HDU2642 - Stars) 题意 你要维护一片\(1001\times1001(0\le x,y\le1000)\)的天空。有\(3\)种操作。B x y代表让\((x,y)\)的星星亮，D x y代表让\((x,y)\)的星星暗，Q x1 x2 y1 y2代表查询\([(x_1,y_1),(x_2,y_2)]\)亮的星星数。最开始星星都是暗的。 解法 开两个数组(一个其实就够)。一个存树状数组，一个存原数组。如果星星已经亮了那么忽略B操作，否则就让它亮。D操作同理。然后Q操作就直接套一个裸的区间查询即可。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;using namespace std;int n, rec[1003][1003], src[1003][1003];const int N = 1001;inline int lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int j, int x) &#123; while (i &lt;= N) &#123; int j_ = j; while (j_ &lt;= N) &#123; rec[i][j_] += x; j_ += lowbit(j_); &#125; i += lowbit(i); &#125;&#125;int query(int x, int y) &#123; int ret = 0; while (x) &#123; int y_ = y; while (y_) &#123; ret += rec[x][y_]; y_ -= lowbit(y_); &#125; x -= lowbit(x); &#125; return ret;&#125;int t, X1, Y1, X2, Y2;char op[2];int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s%d%d", &amp;op, &amp;X1, &amp;X2); X1++, X2++; if (*op == 'B') &#123; if (!src[X1][X2]) add(X1, X2, 1); src[X1][X2] = 1; &#125; else if (*op == 'D') &#123; if (src[X1][X2]) add(X1, X2, -1); src[X1][X2] = 0; &#125; else &#123; scanf("%d%d", &amp;Y1, &amp;Y2); Y1++; Y2++; int n1 = min(X1, X2), m1 = min(Y1, Y2), n2 = max(X1, X2), m2 = max(Y1, Y2); printf("%d\n", query(n2, m2) - query(n1 - 1, m2) - query(n2, m1 - 1) + query(n1 - 1, m1 - 1)); &#125; &#125; return 0;&#125; 模板题2 (JSOI2009 - 计数问题) 详见这篇博客。 区间修改+单点查询 根据二维前缀和公式，\(sum_{i,j}=src_{i,j}+sum_{i-1,j}+sum_{i,j-1}-sum_{i-1,j-1}\)。 那么可以令差分数组\(d_{i,j}\)为\(src_{i,j}\)与\(src_{i-1,j}+src_{i,j-1}-src_{i-1,j-1}\)的差。 比如 \[ \begin{pmatrix} 1&amp;7&amp;4\\ 9&amp;6&amp;3\\ 5&amp;8&amp;2\\ \end{pmatrix} \] 的差分矩阵就是 \[ \begin{pmatrix} 1&amp;6&amp;-3\\ 8&amp;-9&amp;0\\ -4&amp;6&amp;-3\\ \end{pmatrix} \] 如果要把\(1\)、\(7\)、\(9\)、\(6\)都加上\(x\)，那么在差分数组里这样更新： \[ \begin{pmatrix} 1\color{red}+x&amp;6&amp;-3\color{red}-x\\ 8&amp;-9&amp;0\\ -4\color{red}-x&amp;6&amp;-3\color{red}+x\\ \end{pmatrix} \] 然后区间修改就被转化成了\(4\)次单点修改。 区间修改+区间查询 \((x,y)\)的前缀和可以表示为\(\displaystyle\sum_{i=1}^x\sum_{j=1}^y\sum_{p=1}^i\sum_{q=1}^jd_{p,q}\)。 统计\(tree_{i,j}\)的出现次数，得\(\displaystyle\sum_{i=1}^x\sum_{j=1}^yd_{i,j}(x+1-i)(y+1-j)\)。 \((x+1-i)(y+1-j)\)展开得\((x+1)(y+1)-(y+1)i-(x+1)j+ij\) 也就是 \[ \begin{align*} &amp;\sum_{i=1}^x\sum_{j=1}^yd_{i,j}(x+1-i)(y+1-j)\\ =&amp;(x+1)(y+1)\sum_{i=1}^x\sum_{j=1}^yd_{i,j}\\ -&amp;(x+1)\sum_{i=1}^x\sum_{j=1}^yd_{i,j}\cdot j\\ -&amp;(y+1)\sum_{i=1}^x\sum_{j=1}^yd_{i,j}\cdot i\\ +&amp;\sum_{i=1}^x\sum_{j=1}^yd_{i,j}\cdot i\cdot j\\ \end{align*} \] 于是可以开四个树状数组，一个存\(d_{i,j}\)，一个存\(i\cdot d_{i,j}\)，一个存\(j\cdot d_{i,j}\)，一个存\(i\cdot j\cdot d_{i,j}\)。 结束了？结束了。 模板题 (BZOJ3132 - 上帝造题的七分钟) 单独放在一篇博客里，未完待续…… 高维树状数组？ 可以通过高维差分和高维前缀和类比低维情况实现。(显然我不会) 然后就可以做到每次\(O(\log^dn)\)时间复杂度了。(看起来要开\(2^d\)个树状数组？吐血) 例题列表 一维 单点修改+区间查询： 洛谷 P3374 【模板】树状数组 1 区间修改+单点查询： 洛谷 P3368 【模板】树状数组 2 区间修改+区间查询： 洛谷 P3372 【模板】线段树 1 二维 单点修改+区间查询： HDU2642 Stars JSOI2009 计数问题 区间修改+区间查询： BZOJ3132 上帝造题的七分钟]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题目汇总」网络流题目汇总]]></title>
    <url>%2F2018%2F05%2F06%2Fnetwork-flow-problems%2F</url>
    <content type="text"><![CDATA[这里是一些网络流题目的汇总。 已经咕咕，有时间再复习网络流。 进度：ABCDEF。 A, Coding Contest, 费用流 传送门：HDU5988，YaliOJ。 B, Flow Problem, 最大流 传送门：HDU3549，YaliOJ。 题意 求最大流。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 16384, INF = 0x3f3f3f3f;struct Edge;struct Node &#123; vector&lt;Edge *&gt; edges; int level;&#125; gph[N];struct Edge &#123; int from, to, capacity, flow; Edge *rev; Edge(int from_, int to_, int capacity_, int flow_ = 0) &#123; capacity = capacity_; from = from_; flow = flow_; to = to_; &#125; Edge() &#123; from = to = capacity = flow = 0; rev = 0; &#125;&#125;;bool levelGraph(int s, int t, int n) &#123; for (int i = 1; i &lt;= n; i++) &#123; gph[i].level = 0; &#125; queue&lt;int&gt; bfs; bfs.push(s); gph[s].level = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = 0; i &lt; gph[pos].edges.size(); i++) &#123; const Edge&amp; e = *gph[pos].edges[i]; if (e.flow &lt; e.capacity &amp;&amp; !gph[e.to].level) &#123; gph[e.to].level = gph[pos].level + 1; if (e.to == t) return true; // 优化一 else bfs.push(e.to); &#125; &#125; &#125; return false;&#125;int findPath(int s, int t, int flow) &#123; if (s == t) return flow; int ret = 0; for (int i = 0; i &lt; gph[s].edges.size(); i++) &#123; Edge &amp;e = *gph[s].edges[i]; if (gph[s].level + 1 == gph[e.to].level &amp;&amp; e.flow &lt; e.capacity) &#123; int tmp = findPath(e.to, t, min(flow, e.capacity - e.flow)); flow -= tmp; e.flow += tmp; e.rev-&gt;flow -= tmp; ret += tmp; if (!flow) break; // 优化二 &#125; &#125; if (!ret) gph[s].level = -1; // 优化三 return ret;&#125;int dinic(int s, int t, int n) &#123; int ans = 0; while (levelGraph(s, t, n)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;int cnt = -1;void addEdge(int from, int to, int capacity) &#123; Edge *e1 = new Edge(from, to, capacity, 0); Edge *e2 = new Edge(to, from, capacity, capacity); e1-&gt;rev = e2; e2-&gt;rev = e1; gph[from].edges.push_back(e1); gph[to].edges.push_back(e2);&#125;int t, n, m, a, b, c;int main() &#123; scanf("%d", &amp;t); for (int cn = 1; cn &lt;= t; cn++) &#123; for (int i = 1; i &lt;= n; i++) &#123; gph[i].edges.clear(); &#125; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addEdge(a, b, c); &#125; printf("Case %d: %d\n", cn, dinic(1, n, n)); &#125;&#125; C, Game, 最小割 传送门：HDU3657，YaliOJ。 D, Harry ..., 最小割 传送门：HDU3987，YaliOJ。 题意 求最小割边数。 解法 定理：最大流中满流的边属于最小割边集。 于是可以求一遍最大流，把所有满流的边流量设为\(1\)，其它的边设为\(+\infty\)，然后再跑一遍网络流就好了。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int to, next, capacity, flow;&#125; e[400005];int level[1003], head[1003], cnt = 1;bool bfs_(int s, int t) &#123; memset(level, 0, sizeof level); queue&lt;int&gt; bfs; bfs.push(s); level[s] = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = head[pos]; i; i = e[i].next) &#123; if (e[i].flow &lt; e[i].capacity &amp;&amp; !level[e[i].to]) &#123; level[e[i].to] = level[pos] + 1; bfs.push(e[i].to); &#125; &#125; &#125; return level[t];&#125;int dfs(int s, int t, int flow) &#123; if (s == t) return flow; int ret = 0; for (int i = head[s]; i; i = e[i].next) &#123; if (level[s] + 1 == level[e[i].to] &amp;&amp; e[i].flow &lt; e[i].capacity) &#123; int tmp = dfs(e[i].to, t, min(flow, e[i].capacity - e[i].flow)); ret += tmp; e[i].flow += tmp; e[i^1].flow -= tmp; flow -= tmp; &#125; &#125; if (!ret) level[s] = -1; return ret;&#125;int dinic(int s, int t) &#123; int ret = 0; while (bfs_(s, t)) &#123; ret += dfs(s, t, 0x3f3f3f3f); &#125; return ret;&#125;void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z, 0&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y], z, z&#125;; head[y] = cnt;&#125;int n, m, t, u, v, w, x, _;int main() &#123; scanf("%d", &amp;t); while (t--) &#123; memset(e, 0, sizeof e); cnt = 1; memset(head, 0, sizeof head); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;w, &amp;x); u++; v++; addedge(u, v, w); if (x) addedge(v, u, w); &#125; dinic(1, n); for (int i = 2; i &lt;= cnt; i += 2) &#123; if (e[i].flow == e[i].capacity) &#123; // 满流 e[i].capacity = 1; e[i].flow = 0; e[i^1].capacity = 1; e[i^1].flow = 1; &#125; else &#123; e[i].capacity = 0x3f3f3f3f; e[i].flow = 0; e[i^1].capacity = 0x3f3f3f3f; e[i^1].flow = 0x3f3f3f3f; &#125; &#125; printf("Case %d: %d\n", ++_, dinic(1, n)); &#125; return 0;&#125; 这个题目貌似是个什么「最小割树」，然后好像有一种只用求一次最大流就能出解的算法。 E, Destroy ..., 上下界可行流(据说乱搞可过？) 传送门：HDU4940，YaliOJ。 F, Jump, 费用流 传送门：HDU4862，YaliOJ。]]></content>
      <categories>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最大流</tag>
        <tag>费用流</tag>
        <tag>Y</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」网络流]]></title>
    <url>%2F2018%2F05%2F05%2Fnetwork-flow-notes%2F</url>
    <content type="text"><![CDATA[简介 网络流？好难啊。 由于有各种千奇百怪的网络流题的存在，网络流变得异常复杂。 UPD： 2018-02-17 21:09:35：Initial Commit 2018-03-03 22:34:54：Change最小费用最大流 to 费用流，Change代码，Add最小割 2018-03-04 13:07:48：Change代码 2018-05-05 23:31:36：Add费用流 没用的概念 网络：带权有向图，记作\(G=(V,E)\)。 容量：网络上的边权，边\((u,v)\)的容量记作\(c(u,v)\)。 网络流：指为这个有向图分配流并且使得它每条边上的流量都不能超过这条边的容量。 流量：网络流上的边权，边\((u,v)\)的流量记作\(f(u,v)\)。 可行流满足： 流量限制：\(0\le f(u,v)\le c(u,v),(u,v)\in E\)。 平衡条件：\(\sum_{v&#39;}f(u,v&#39;)-\sum_{v&#39;&#39;}f(v&#39;&#39;,u)=\left\{\begin{array}{lc}|f|&amp;u=V_s\\0&amp;u\ne V_s,V_t\\-|f|&amp;u=V_t\end{array}\right.\) 其中\(\sum_{v&#39;}f(u,v&#39;)\)是从顶点\(u\)流出的流量之和，\(\sum_{v&#39;&#39;}f(v&#39;&#39;,u)\)是流入顶点\(u\)的流量之和，\(|f|\)是可行流的总流量，是源点的净流出量，也是汇点的净流入量。 链：前后两两有边项链的点的序列。(准确的说是弧而不是边，之后均使用弧代替边) 前向弧：和链的方向相同。前向弧集合记作\(P^+\)。 后向弧：和链的方向相反。后向弧集合记作\(P^-\)。 增广路：源点到汇点的一条链，满足前向弧非饱和弧，后向弧非零流弧。 即\(0\le f(u,v)&lt;c(u,v),0&lt;f(u,v)\le c(u,v)\)。 残留容量或剩余流量：还能通过的流量。弧的残留容量或剩余流量记作$$。 每条弧对应一个反向残余流量或反向剩余流量\(c&#39;(v,u)=-f(u,v)\)。 残量网络或残余网络或剩余网络：残留容量或剩余流量组成的网络。 :warning: 注意：接下来残留容量和剩余容量统一为残留容量，残量网络、残余网络和剩余网络统称残量网络。 无聊的概念终于结束了，进入正题 就一个概念而已，一堆名字恶心不恶心 最大流 Ford-Fulkerson和Edmonds-Karp略。 Dinic 步骤 初始化 BFS构造层次网络和残量网络。 如果汇点不在层次网络中算法结束。 在层次网络中DFS进行增广，然后回到步骤2。 优化 BFS只要搜到终点就直接返回true。 DFS如果一条边的流量流满了，就不需要再对这条边DFS了，直接返回答案。 DFS如果一个点增广不出流量，那么这次DFS就不要再搜这个点了，再层次图中标记为\(0\)。 代码 2018-03-03 22:34:54 Update： 因为STL的指针失效问题，代码被改了。(难怪我不能过BZOJ1711) 只能AC洛谷的模板题可能和洛谷的数据生成器CYaRon有关，说不定生成算法或者输出没有打乱然后不加反向弧/加错反向弧也可以AC？interesting 代码为了兼容long long或高精，typedef了Flow_Type，自行更改以适应long long或其它数据。 2018-03-04 13:07:48 Update： 由于原来的代码空间复杂度常数高，于是压了压空间。 该代码用于AcceptedYali 网络流B - Flow Problem或原题HDU3549 - Flow Problem。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Flow_Type;const Flow_Type INF = 0x3f3f3f3f;const int N = 31, M = 1003;struct Edge;int level[N];int head[N];struct Edge &#123; Flow_Type capacity, flow; int to, next;&#125; e[M &lt;&lt; 1];bool levelGraph(int s, int t) &#123; memset(level, 0, sizeof level); queue&lt;int&gt; bfs; bfs.push(s); level[s] = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = head[pos]; i; i = e[i].next) &#123; if (e[i].flow &lt; e[i].capacity &amp;&amp; !level[e[i].to]) &#123; level[e[i].to] = level[pos] + 1; if (e[i].to == t) return true; // 优化一 else bfs.push(e[i].to); &#125; &#125; &#125; return false;&#125;Flow_Type findPath(int s, int t, Flow_Type flow) &#123; if (s == t) &#123; return flow; &#125; Flow_Type ret = 0; for (int i = head[s]; ret &lt; flow &amp;&amp; i; i = e[i].next) &#123; if (level[s] + 1 == level[e[i].to] &amp;&amp; e[i].flow &lt; e[i].capacity) &#123; Flow_Type tmp = findPath(e[i].to, t, min(e[i].capacity - e[i].flow, flow)); ret += tmp; flow -= tmp; e[i].flow += tmp; e[i ^ 1].flow -= tmp; // if (!flow) break; // 优化二 &#125; &#125; if (!ret) level[s] = -1; // 优化三 return ret;&#125;Flow_Type dinic(int s, int t) &#123; Flow_Type ans = 0; while (levelGraph(s, t)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;int cnt = 1;void addUndirectedEdge(int from, int to, int capacity) &#123; // printf("(%d, %d, %d)\n", from, to, capacity); e[++cnt].to = to; e[cnt].next = head[from]; e[cnt].capacity = capacity; head[from] = cnt; e[++cnt].to = from; e[cnt].next = head[to]; e[cnt].capacity = capacity; head[to] = cnt;&#125;void addDirectedEdge(int from, int to, int capacity) &#123; // printf("(%d, %d, %d)\n", from, to, capacity); e[++cnt].to = to; e[cnt].next = head[from]; e[cnt].capacity = capacity; head[from] = cnt; e[++cnt].to = from; e[cnt].next = head[to]; e[cnt].capacity = capacity; e[cnt].flow = capacity; head[to] = cnt;&#125;int t, n, m, a, b, c;int main() &#123; scanf("%d", &amp;t); for (int cn = 1; cn &lt;= t; cn++) &#123; cnt = 1; memset(e, 0, sizeof e); memset(head, 0, sizeof head); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;a, &amp;b, &amp;c); addDirectedEdge(a, b, c); &#125; printf("Case %d: %d\n", cn, dinic(1, n)); &#125;&#125; 最小割 根据最大流最小割定理，得出最大流\(=\)最小割。 内容：最大流就是最小割。 定理证明略 费用流 Edmonds-Karp 求最大流的Edmonds-Karp算法的流程是首先bfs找出任意一条增广路，然后增广，直到无法增广。费用流中的Edmonds-Karp算法则是用spfa(别的也行)找出费用最少的一条 步骤 用SPFA求出费用最少的一条增广路(同时记录路径以便增广)。 对该路径进行增广，流量 += 终点流量, 费用 += 终点流量 * 源点到汇点的距离(费用)。 如果还能增广，就回到步骤1。 代码 该代码用于AcceptedP3381 - 【模板】最小费用最大流。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int from, to, next, capacity, flow, cost;&#125; e[100005];int head[5003], cnt = 1;int prev[5003];int flow[5003];void ek(int s, int t, int&amp; rflow, int&amp; cost) &#123; int dis[5003]; int vis[5003]; queue&lt;int&gt; bfs; while (dis[t] != 0x3f3f3f3f) &#123; memset(prev, 0, sizeof prev); memset(flow, 0, sizeof flow); memset(dis, 0x3f, sizeof dis); memset(vis, 0, sizeof vis); bfs.push(s); flow[s] = 0x3f3f3f3f; dis[s] = 0; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); vis[pos] = 0; for (int i = head[pos]; i; i = e[i].next) &#123; int nx = e[i].to; if (e[i].flow &lt; e[i].capacity &amp;&amp; dis[nx] &gt; dis[pos] + e[i].cost) &#123; dis[nx] = dis[pos] + e[i].cost; flow[nx] = min(flow[pos], e[i].capacity - e[i].flow); prev[nx] = i; if (!vis[nx]) &#123; bfs.push(nx); vis[nx] = 1; &#125; &#125; &#125; &#125; for (int i = prev[t]; i; i = prev[e[i].from]) &#123; e[i].flow += flow[t]; e[i^1].flow -= flow[t]; &#125; rflow += flow[t]; cost += dis[t] * flow[t]; &#125;&#125;void addedge(int x, int y, int z, int w) &#123; e[++cnt] = (edge)&#123;x, y, head[x], z, 0, w&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;y, x, head[y], 0, 0, -w&#125;; head[y] = cnt;&#125;int n, m, s, t, x, y, z, w, rflow, cost;int main() &#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;t); while (m--) &#123; scanf("%d%d%d%d", &amp;x, &amp;y, &amp;z, &amp;w); addedge(x, y, z, w); &#125; ek(s, t, rflow, cost); printf("%d %d", rflow, cost); return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>网络流</tag>
        <tag>图论</tag>
        <tag>最大流</tag>
        <tag>费用流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 3613」Cow Relays - Floyd + 矩阵快速幂]]></title>
    <url>%2F2018%2F05%2F02%2Fpoj-3613%2F</url>
    <content type="text"><![CDATA[题意 传送门：POJ 3613 - Cow Relays 求给定 \(t\) 条边的无向图中 \(s\) 到 \(t\) 长度恰好为 \(n\) 的最短路的长度。 \(t\le100,n\le10^6,\text{点的编号}\le10^3\) 解法 首先离散化点的编号(显然图中最多只有 \(200\) 个点)。 然后考虑 Floyd 最短路的转移过程： 1234for k = 1 .. n for i = 1 ... n for j = 1 ... n g[i][j] = min(g[i][j], g[i][k] + g[k][j]) 再看看矩乘的过程： 1234for k = 1 .. n for i = 1 ... n for j = 1 ... n g[i][j] = add(g[i][j], g[i][k] * g[k][j]) 容易看出，Floyd 只是将矩乘中的 add 换成了 min，乘换成了加而已。 接着考虑一般的情况。 一般地，若 \(G^x\) 代表经过 \(x\) 条边的最短路，那么它满足关系式 \(G^{a+b}=G^a \operatorname{乘} G^b\)。 于是得出“Floyd 运算”也满足结合律。于是可以用矩阵快速幂 \(O(t^3\log n)\) 求出。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;bits/stdc++.h&gt;using namespace std;typedef int gph[502][502];int dcnt;void mul(gph x, gph y) &#123; // mul_equ: *= gph ret; memset(ret, 0x3f, 502 * 502 &lt;&lt; 2); for (int k = 1; k &lt;= dcnt; k++) &#123; for (int i = 1; i &lt;= dcnt; i++) &#123; for (int j = 1; j &lt;= dcnt; j++) &#123; ret[i][j] = min(ret[i][j], x[i][k] + y[k][j]); &#125; &#125; &#125; memcpy(x, ret, 502 * 502 &lt;&lt; 2);&#125;void pow(gph base, int exp, gph res) &#123; memcpy(res, base, 502 * 502 &lt;&lt; 2); exp--; // 弃单位矩阵的新科技 while (exp) &#123; if (exp&amp;1) mul(res, base); mul(base, base); exp &gt;&gt;= 1; &#125;&#125;int n, t, s, e, x, y, z;int disc[1000006];gph rec, ans;int main() &#123; memset(rec, 0x3f, sizeof rec); for (scanf("%d%d%d%d", &amp;n, &amp;t, &amp;s, &amp;e); t--; ) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); if (!disc[y]) disc[y] = ++dcnt; if (!disc[z]) disc[z] = ++dcnt; rec[disc[y]][disc[z]] = rec[disc[z]][disc[y]] = x; &#125; pow(rec, n, ans); printf("%d", ans[disc[s]][disc[e]]); return 0;&#125; 拓展 矩阵快速幂的基础是\(G^{a+b}=G^a\times G^b\)。然后在该式基础上进行倍增优化。 其实上式中的乘法可以换成其他运算(倍增加法求矩阵数乘)。如本题的&quot;Floyd运算&quot;。 在邻接矩阵上做运算，多有意思！ EASY版本： 「HDU 5318改」求无权无向图中长度为\(K\)的路径条数。其中\(n\le50,K\le10^9\) 做法是把邻接矩阵(01矩阵)快速幂一下求和除以二输出就好了。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Floyd</tag>
        <tag>矩阵快速幂</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「POJ 1734」Sightseeing trip - Floyd求最小环]]></title>
    <url>%2F2018%2F05%2F02%2Fpoj-1734%2F</url>
    <content type="text"><![CDATA[题意 传送门：POJ 1734 - Sightseeing trip 求无向图长度最小的点数 \(\ge3\) 的环之一的路径。 解法 令 \(lnk_{i,j}\) 为 \(i\) 到 \(j\) 暂时的最短路的某一个中转点。没有中转点则为 \(0\)。 那么 \(i\) 到 \(j\) 暂时的最短路就是 \(i\) 到 \(lnk_{i,j}\) 和 \(lnk_{i,j}\) 到 \(j\) 的最短路……以此类推。 那么在 Floyd 更新最短路时同时更新 \(lnk\) 数据就可以记录路径了。 然后在每次 Floyd 更新之前算出最小环和路径更新答案即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;bits/stdc++.h&gt;using namespace std;const int oo = 0x3f3f3f3f;int floyd[102][102];int gph[102][102];int lnk[102][102];int n, m, x, y, z;vector&lt;int&gt; loop;int ans = oo;void dfs(int x, int y) &#123; // [x, lnk[x][y]) -- lnk[x][y] -- (lnk[x][y], y] if (!lnk[x][y]) return; // 无中转点 dfs(x, lnk[x][y]); // 搜索中转点前半段 loop.push_back(lnk[x][y]); // 路径中加入中转点 dfs(lnk[x][y], y); // 搜索中转点后半段&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); memset(gph, 0x3f, sizeof gph); while (m--) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); gph[x][y] = gph[y][x] = min(gph[x][y], z); &#125; memcpy(floyd, gph, sizeof floyd); for (int k = 1; k &lt;= n; k++) &#123; for (int i = 1; i &lt; k; i++) &#123; for (int j = i + 1; j &lt; k; j++) &#123; // 对称性, 只需搜索右上三角形部分 if (ans &gt; (long long)floyd[i][j] + gph[j][k] + gph[k][i]) &#123; ans = floyd[i][j] + gph[j][k] + gph[k][i]; // 注意右上三角 loop.clear(); // i -- [中转点] -- j -- k -- i... loop.push_back(i); dfs(i, j); loop.push_back(j); loop.push_back(k); &#125; &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (floyd[i][j] &gt; floyd[i][k] + floyd[k][j]) &#123; floyd[i][j] = floyd[i][k] + floyd[k][j]; lnk[i][j] = k; &#125; &#125; &#125; &#125; if (ans == oo) &#123; puts("No solution."); return 0; &#125; for (int i = 0; i &lt; loop.size(); i++) &#123; printf("%d ", loop[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Floyd</tag>
        <tag>POJ</tag>
        <tag>最小环</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ 2442」修剪草坪 - DP + 单调队列]]></title>
    <url>%2F2018%2F04%2F22%2Fbzoj-2442%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P2627 - 修剪草坪，BZOJ2442。 给一个长度为\(n\)的数组。现在让你选一些数，并且选的数中不能有在数组中长度超过\(k\)的连续段。求选出的数的和的最大值。 解法 令\(dp_i\)为在\([1,i]\)中选数的最大值。那么显然\(dp_i=\max\limits_{i-k\le j\le i}\{dp_{j-1}+\sum\limits_{w=j+1}^ia_w\}\)。 然后发现可以用前缀和优化。那么令\(sum_i=\sum\limits_{j=1}^ia_j\)，则\(dp_i=\max\limits_{i-k\le j\le i}\{dp_{j}+sum_i-sum_{j-1}\}\)，变形得\(dp_i=\max\limits_{i-k\le j\le i}\{dp_{j-1}-sum_{j}\}+sum_i\)。 于是发现这里的方程满足模型\(dp_i=\max\limits_{L(i)\le j\le R(i)}\{dp_j+val(i,j)\}\)且\(val(i,j)\)中每一项只与\(i\)或\(j\)有关，满足决策的单调性，所以开一个单调队列维护\(dp_{j-1}-sum_j\)在\(i-k\le j\le i\)时的最大值即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int head, tail = 1;int que[100015];ll pre[100015];ll dp_[100015];ll dp[100015];int n, k;const int N = 1 &lt;&lt; 20;char buf[N], *ptr = buf;inline int read() &#123; // Powered by LK int k = 0; while (!isdigit(*ptr)) ptr++; while (isdigit(*ptr))&#123; k = k * 10 + (*ptr++ ^ 48); &#125; return k;&#125;inline void add(int x) &#123; dp_[x] = dp[x-1] - pre[x]; while (head &lt;= tail &amp;&amp; dp_[que[tail]] &lt; dp_[x]) tail--; que[++tail] = x;&#125;inline ll query(int x) &#123; while (head &lt;= tail &amp;&amp; que[head] &lt; x-k) head++; return dp_[que[head]];&#125;int main() &#123; fread(buf, 1, N, stdin); n = read(); k = read(); for (int i = 1; i &lt;= n; i++) &#123; pre[i] = read(); pre[i] += pre[i-1]; &#125; for (int i = 1; i &lt;= n; i++) &#123; add(i); dp[i] = pre[i] + query(i); &#125; printf("%lld", dp[n]);&#125; 拓展 满足模型\(dp_i=\max\limits_{L(i)\le j\le R(i)}\{dp_j+val(i,j)\}\)且\(val(i,j)\)中每一项只与\(i\)或\(j\)有关时，可以在用单调队列维护\(j\)，对于每一个\([L(i),R(i)]\)维护最大(小)值。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>DP</tag>
        <tag>单调队列</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「题目汇总」Tarjan题目汇总]]></title>
    <url>%2F2018%2F04%2F16%2Ftarjan-problems%2F</url>
    <content type="text"><![CDATA[这里是一些Tarjan题目的汇总。 进度：ABCDEF。 A, Caocao's Bridges, 桥 传送门：HDU4738，YaliOJ。 题意 曹操在长江上弄了一些点，点之间有桥。每座桥上有若干人守卫。现在刘备有一枚炸弹，问最少带多少人去炸桥可以使点之间不连通。如果不可能输出 \(-1\)。 解法 边 \((u,v)\) （\(u\) 在 dfs 树下为 \(v\) 的子节点） 为桥的充要条件是 \(low_v&gt;dfn_u\)，也就是 \(u\) 的子节点 \(v\) 无法到达 \(u\) 及其之上的点，那么如果切断 \((u,v)\) 那么图将不会联通。 这道题的坑点如下： 如果已经不连通了输出 0。 处理方式：记录 dfs 拓展出的节点数，如果发现不到 \(n\) 那么显然不连通，输出 \(0\) 即可。 (expand+1 == n) * ans 如果没人守卫还是要输出 1。 处理方式：如果 \(ans\) 为 \(0\) 那么取 \(ans\) 和 \(1\) 的 max 就好了。 (expand+1 == n) * max(1, ans) 最后加上对 \(ans=+\infty\) 的特判：ans == 0x3f3f3f3f ? -1 : (expand+1 == n) * max(1, ans) 重边需要特殊处理。（因为 dfs 树的特殊性，只需考虑父节点——子节点的重边即可） 处理方式：如果父节点到子节点只连了一次边，那么不需要用父节点更新。否则把父节点当成子节点更新。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;bits/stdc++.h&gt;using namespace std;struct edge &#123; int to, next, weight;&#125; e[2000006];int dfn[1003], low[1003], head[1003], idx, cnt, ans, expand;void addedge(int x, int y, int z) &#123; e[++cnt] = (edge)&#123;y, head[x], z&#125;; head[x] = cnt; e[++cnt] = (edge)&#123;x, head[y], z&#125;; head[y] = cnt;&#125;void dfs(int x, int par) &#123; dfn[x] = low[x] = ++idx; int f = 0; for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (!dfn[nx]) &#123; dfs(nx, x); expand++; low[x] = min(low[x], low[nx]); if (low[nx] &gt; dfn[x]) &#123; ans = min(ans, e[i].weight); &#125; &#125; else if (nx == par) &#123; if (f) low[x] = min(low[x], dfn[nx]); f = 1; &#125; else low[x] = min(low[x], dfn[nx]); &#125;&#125;int n, m, x, y, z;int main() &#123; while (~scanf("%d%d", &amp;n, &amp;m) &amp;&amp; (n || m)) &#123; memset(head, 0, sizeof head); memset(dfn, 0, sizeof dfn); memset(low, 0, sizeof low); memset(e, 0, sizeof e); idx = cnt = expand = 0; ans = 0x3f3f3f3f; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;x, &amp;y, &amp;z); addedge(x, y, z); &#125; dfs(1, -1); printf("%d\n", ans == 0x3f3f3f3f ? -1 : (expand+1 == n) * max(1, ans)); &#125;&#125; Y三集 B, Railway, 点双+桥 传送门：HDU4738，YaliOJ。 C, Network, 边双 传送门：HDU2460，YaliOJ。 D, TWO NODES, 割点 传送门：HDU4587，YaliOJ。 题意 给你一张图，问你删掉两个点最多能有多少个连通块。\(n,m\le5000\)。 解法 枚举其中一个删除的点，然后 Tarjan 求一遍割点。答案取 max。 未完待续…… 代码 E, Warm up, 边双缩点 F, Important Sisters, 支配树]]></content>
      <categories>
        <category>题目汇总</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>Y</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1997」Planar - 并查集]]></title>
    <url>%2F2018%2F04%2F15%2Fbzoj-1997%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1997 - Planar和洛谷 P3209 给一张图，判断是不是平面图。\(3\le n\le200,m\le10^4\)。 WTF？HNOI考平面图？还是平面图判定？ 当然不是。数据保证图中有汉密尔顿回路。 LYH：一眼看过去就是个假的平面图2333。 解法 首先平面图满足\(m\le3n-6(n\ge3)\)，不满足的直接NO。 既然都有汉密尔顿回路了，那么其它的边要么连在环里面要么连在环外面。 然后平面图要边不相交，那么就可以像团伙那题一样，用\(i+m\)代表与\(i\)相交的边的集合。 然后如果不相交就判断有没有矛盾，相交就直接continue掉(玄学)。 如果不相交没有矛盾就把\(j\)和\(i+m\)以及\(i\)和\(j+m\)连边。 就这么简单，谁说要用什么2-sat？(反正都比一般平面图判定简单) 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;using namespace std;int u[10004], v[10004], id[10004];bool vis[10004];int par[10004];int t, _, n, m;bool cross(int x1, int x2, int y1, int y2) &#123; if (x1 == x2 || y1 == y2 || x1 == y2 || x2 == y1) &#123; return 0; &#125; return (x1 &lt; x2 &amp;&amp; y1 &lt; y2 &amp;&amp; x2 &lt; y1) || (x2 &lt; x1 &amp;&amp; y2 &lt; y1 &amp;&amp; x1 &lt; y2);&#125;int find(int x) &#123; return par[x] ? par[x] = find(par[x]) : x;&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y;&#125;int main() &#123; for (scanf("%d", &amp;t); t--; ) &#123; memset(par, 0, sizeof par); memset(u, 0, sizeof u); memset(v, 0, sizeof v); memset(id, 0, sizeof id); memset(vis, 0, sizeof vis); scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", u+i, v+i); &#125; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;_); id[_] = i; &#125; if (m &gt; 3 * n - 6) &#123; puts("NO"); continue; &#125; for (int i = 1; i &lt;= m; i++) &#123; int x = id[u[i]]; int y = id[v[i]]; u[i] = min(x, y); v[i] = max(x, y); &#125; for (int i = 1; i &lt;= m; i++) &#123; vis[i] = (u[i]%n+1 == v[i]); &#125; for (int i = 1; i &lt;= m; i++) &#123; if (vis[i]) continue; for (int j = 1; j &lt;= m; j++) &#123; if (vis[j]) continue; if (!cross(u[i], u[j], v[i], v[j])) continue; if (find(i) == find(j)) &#123; puts("NO"); goto end; &#125; merge(i, j + m); merge(j, i + m); &#125; &#125; puts("YES"); end:; &#125;&#125; 拓展 下面的玄学我一样都不会： Tarjan的论文Efficient Planarity Testing(一般的平面图判定) BM算法Boyer Myrvold算法(目前最先进的平面图判定算法)]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>HNOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 961E」Tufurama - 树状数组]]></title>
    <url>%2F2018%2F04%2F06%2Fcodeforces-961e%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 961E - Tufurama 有部电视剧有\(n(n\le2\cdot10^5)\)季，第\(i\)季有\(a_i\)集。问有多少个数对\((x,y)(x&lt;y)\)，满足\(x\)季\(y\)集和\(y\)季\(x\)集都在电视剧中存在。 解法 为了简化问题，将数对的限制改为\(x\le y\)。 显然如果有一季集数超过了\(n\)，那么多余部分可以直接cut掉。 根据\(n\)的范围分析，时间复杂度肯定是\(O(n)\)枚举乘上\(O(1)/O(\log n)\)处理。 而且第\(i\)行处理完后所有集数少于\(i\)的都可以删掉了(第\(i\)行之后\(i&lt;x\le y\))。 既然树状数组是沟通原数组和前缀和的桥梁，那么就可以打一个树状数组，代表是否被删除了。统计第\(i\)行的答案只需将答案加上未被删除的季数即可食用。 哦，别忘了\(\div2\)并且处理掉所有\(x=y\)的情况！ 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;int n, rec[200005], tree[200005];vector&lt;int&gt; lst[200005];long long ans;inline lowbit(int x) &#123; return x&amp;-x;&#125;void add(int i, int x) &#123; while (i &lt;= n) &#123; tree[i] += x; i += lowbit(i); &#125;&#125;int query(int x) &#123; int ret = 0; while (x) &#123; ret += tree[x]; x -= lowbit(x); &#125; return ret;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec+i); if (rec[i] &lt;= n) lst[rec[i]].push_back(i); add(i, 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; ans += query(min(rec[i], n)) - (i &lt;= rec[i]); for (int j = 0; j &lt; lst[i].size(); j++) &#123; add(lst[i][j], -1); &#125; &#125; printf("%I64d", ans &gt;&gt; 1); return 0;&#125; 拓展 \(0/1\)树状数组可以很好的维护元素是否被删除的状态数组。 一些不便于维护和处理的限制条件，可以转化成便于维护的限制，再把多余的情况去除。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 961D」Pair Of Lines - 数学 + 几何]]></title>
    <url>%2F2018%2F04%2F06%2Fcodeforces-961d%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 961D - Pair Of Lines 给你\(n(n\le10^5)\)个点，问你能不能用两条直线全部覆盖。 解法 首先，如果\(n\le3\)那么答案肯定是YES。 如果\(n&gt;3\)，那么考虑前\(3\)个点。 前三个点连成的所有直线(不考虑是否共线)至少有一条是两条中的一条。那么枚举每条直线，把所有直线上的点删掉，判断剩下的是不是在一条直线上即可。 代码 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll x[100005], y[100005];bool vis[100005];int n;bool check(int u, int v) &#123; memset(vis, 0, sizeof vis); int fst = 0, snd = 0, cnt = 0; for (int i = 1; i &lt;= n; i++) &#123; vis[i] = ((x[u] - x[v]) * (y[u] - y[i]) == (y[u] - y[v]) * (x[u] - x[i])); if (fst &amp;&amp; !snd &amp;&amp; !vis[i]) snd = i; if (!fst &amp;&amp; !vis[i]) fst = i; cnt += !vis[i]; &#125; if (cnt &lt; 3) return 1; for (int i = 1; i &lt;= n; i++) &#123; if (!vis[i] &amp;&amp; ((x[fst] - x[snd]) * (y[fst] - y[i]) != (y[fst] - y[snd]) * (x[fst] - x[i]))) &#123; return 0; &#125; &#125; return 1;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%I64d%I64d", x+i, y+i); &#125; if (n &lt;= 3) puts("YES"); else puts((check(1, 2) || check(1, 3) || check(2, 3)) ? "YES" : "NO"); return 0; &#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
        <tag>几何</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「JSOI2009」计数问题 - 树状数组]]></title>
    <url>%2F2018%2F04%2F05%2Fjsoi2009-count%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1452 - Count和洛谷 P4054 - 计数问题 一个\(N\times M\)的方格，初始时每个格子有一个整数权值，接下来每次有\(2\)个操作: 改变一个格子的权值 求一个子矩阵中某个特定权值出现的个数 解法 开一个_树状数组数组数组_，即_&quot;二维树状数组&quot;数组_，第\(k\)个树状数组存权值\(k\)的出现次数。然后\(tree_{i,j,k}\)就是权值在\(k\)右下角为\((i,j)\)长\(lowbit(i)\)宽\(lowbit(j)\)子矩阵中的出现次数。 然后只需要写一个支持单点修改、区间查询的树状数组即可。 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;bits/stdc++.h&gt;using namespace std; int rec[302][302][102], src[302][302];int n, m; inline int lowbit(int x) &#123; return x&amp;-x;&#125; void add(int x, int y, int z, int w) &#123; while (x &lt;= n) &#123; int y_ = y; while (y_ &lt;= m) &#123; rec[x][y_][z] += w; y_ += lowbit(y_); &#125; x += lowbit(x); &#125;&#125; int query(int x, int y, int z) &#123; int ret = 0; while (x) &#123; int y_ = y; while (y_) &#123; ret += rec[x][y_][z]; y_ -= lowbit(y_); &#125; x -= lowbit(x); &#125; return ret;&#125; int op, c, q, X1, Y1, X2, Y2; int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", src[i] + j); add(i, j, src[i][j], 1); &#125; &#125; scanf("%d", &amp;q); for (int i = 1; i &lt;= q; i++) &#123; scanf("%d", &amp;op); if (op == 1) &#123; scanf("%d%d%d", &amp;X1, &amp;Y1, &amp;c); add(X1, Y1, src[X1][Y1], -1); add(X1, Y1, src[X1][Y1] = c, 1); &#125; else &#123; scanf("%d%d%d%d%d", &amp;X1, &amp;X2, &amp;Y1, &amp;Y2, &amp;c); printf("%d\n", query(X2, Y2, c) - query(X1 - 1, Y2, c) - query(X2, Y1 - 1, c) + query(X1 - 1, Y1 - 1, c)); &#125; &#125; return 0;&#125; 拓展 在权值的取值范围较小时可以开_树状数组数组数组_解决。 对于单点set操作，可以处理为不同树状数组中的单点修改操作，也可以处理成相同树状数组一次单点加和一次单点减。 区间set就交给lazy tag吧。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>树状数组</tag>
        <tag>JSOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「赛后总结」Codeforces Round #472 (Div. 2) (+2)]]></title>
    <url>%2F2018%2F04%2F01%2Fcodeforces-round-472%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #472 (Div. 2) 这次本来可以做D，可惜只做出A和B。 可惜C我想到了思路但没去做:cry:。 UPD： 2018-03-26 19:25:24：Initial Commit 2018-04-01 00:09:39：Add C A 题意 现在有ABM三种颜色，?是空白。现在问你是否有多余一种方式填满所有的?，并且相邻两个颜色不相同。 解法 很明显，如果?两边的颜色不同，那么这个肯定只有一种填法。 如果?在开头结尾，或者有几个连在一起，那么肯定有至少一种填法。 于是这就很简单了。只是细节很多。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;using namespace std;char last, bcount;string s;int n, f;int main() &#123; cin &gt;&gt; n &gt;&gt; s; for (int i = 0; i &lt; n; i++) &#123; if (s[i] == last &amp;&amp; s[i] != '?') &#123; puts("No"); return 0; &#125; bcount += (s[i] == '?'); last = s[i]; &#125; if (!bcount) &#123; puts("No"); return 0; &#125; for (int i = 0; i &lt; n; i++) &#123; if (s[i] == '?') &#123; if (i == 0 || i == n - 1) f = 1; else if (s[i - 1] == '?' || s[i + 1] == '?') f = 1; else if (s[i - 1] == s[i + 1]) f = 1; &#125; if (f == 1) &#123; puts("Yes"); return 0; &#125; &#125; puts("No");&#125; B 题意 有\(n\)次操作，每一次可以选择一些行和列，然后把它们的交点全部染成黑色。 现在问你，给你一个黑白局面，问你能不能从白棋盘用\(n\)次得到它，并且满足所有操作中的行和列全部不重复。 解法 如图， 显然如果紫色点有任意三个被选了，那么另外一个肯定会也是黑的。 对于所有两两的行和列，如果这样的紫色点有\(1\)个、\(2\)个或者\(4\)个，那么一定是Yes，否则是\(No\)。 代码 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char rec[233][233];int n, m;int main() &#123; scanf("%d%d\n", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; gets(rec[i] + 1); &#125; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (i != j) for (int p = 1; p &lt;= m; p++) &#123; for (int q = 1; q &lt;= m; q++) &#123; if (p == q) continue; int count = 0; if (rec[i][p] == '#') count++; if (rec[i][q] == '#') count++; if (rec[j][p] == '#') count++; if (rec[j][q] == '#') count++; if (count == 3) &#123; puts("No"); return 0; &#125; &#125; &#125; &#125; &#125; puts("Yes"); return 0;&#125; C 题意 一串单调递增序列\(E\)，要你选\(3\)个不相同的下标\((i,j,k),(i\le j\le k)\)，满足\(E_k-E_i \le U\)，并且满足\(\frac{E_k-E_j}{E_k-E_i}\)是所有满足条件的三元组中最小的。求出这个\(\frac{E_k-E_j}{E_k-E_i}\)。 解法 固定\(i\)。那么\(j\)很明显应该等于\(i+1\)。那么\(k\)肯定是满足单调性的。那么只需要找出\(E_k\le E_i+U\)的最大的\(k\)。所以可以二分。时间复杂度\(O(n\log n)\)。 其实还有个更好的办法——two-pointer。枚举\(i\)，然后将\(i-1\)时的\(k\)用一次循环递增到当前\(i\)时最大的\(k\)，然后再更新最终的答案。最终\(k\)移动的次数是\(O(n)\)量级的，所以复杂度降到了\(O(n)\)。 代码 12345678910111213141516171819202122232425#include &lt;bits/stdc++.h&gt;using namespace std;int n, u, k, rec[100005];int ai, aj, ak;double loss;int main() &#123; scanf("%d%d", &amp;n, &amp;u); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i); &#125; loss = -1; for (int i = 1; i &lt; n - 1; i++) &#123; int j = i + 1; k = max(k, i); while (k + 1 &lt;= n &amp;&amp; rec[k + 1] - rec[i] &lt;= u) k++; if (k &lt;= i + 1) continue; double tl = 1. * (rec[k] - rec[j]) / (rec[k] - rec[i]); loss = max(loss, tl); &#125; if (loss == -1) puts("-1"); else printf("%.12lf", loss); return 0;&#125; D 题意 有条河，第\(i(1\le i\le n)\)天水的高度是\(undefined_i\)。如果某个\(undefined_i\)在以前没有出现过，那么就在那里打上标记。水不会冲掉标记。现在已知每一天河水以上(不包括当前标记)的标记数，求河水下(也不包括当前标记)最少有多少个标记。 解法 首先考虑这个思路： 弄一个变量\(m\)，如果每出现一个数字大于\(m\)，那么就m++(因为每多一个标记那么这时河水的位置一定在那时所有标记之前，并且还会增加一个标记)。 如果小于等于\(m\)，那么直接ans += m - 高度。 这个思路的问题是这样的数据就可以hack掉这个思路： 1240 0 0 2 解决方案是把这种数据处理成这样： 1240 0 1 2 再比如这个数据： 12110 0 0 0 0 0 0 2 4 6 8 和这个就是等价的： 12110 0 0 1 2 3 4 5 6 7 8 做法是先前缀最大值一遍，然后在再数据变得&quot;平滑&quot;。也就是把所有前缀最大值中相邻两项差不小于\(2\)的全部&quot;整平&quot;。 &quot;整平&quot;代码如下： 123456789101112131415// 输入for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i);&#125;// "整平"for (int i = 1; i &lt;= n; i++) &#123; smax[i] = max(smax[i - 1], rec[i]);&#125;for (int i = n; i &gt;= 1; i--) &#123; mrec[i] = t = max(smax[i], t - 1);&#125;for (int i = 1; i &lt; n; i++) &#123; mrec[i] = mrec[i + 1] - mrec[i];&#125; 其中mrec代表修改过的数组，smax代表前缀最大值。 代码 1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, rec[100005];int mrec[100005];int smax[100005];long long ans;int t;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i); &#125; for (int i = 1; i &lt;= n; i++) &#123; smax[i] = max(smax[i - 1], rec[i]); &#125; for (int i = n; i &gt;= 1; i--) &#123; mrec[i] = t = max(smax[i], t - 1); &#125; for (int i = 1; i &lt; n; i++) &#123; mrec[i] = mrec[i + 1] - mrec[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; ans += m - rec[i]; m += mrec[i]; &#125; printf("%lld", ans);&#125;]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
        <tag>枚举/暴力</tag>
        <tag>two-pointer</tag>
        <tag>前缀</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Manacher]]></title>
    <url>%2F2018%2F03%2F24%2Fmanacher-notes%2F</url>
    <content type="text"><![CDATA[简介 Manacher 是一种可以在 \(O(n)\) 时间求出字符串的最长回文子串(和附赠的一个数组)的算法。 比较 暴力一：枚举所有字串，判断最长回文。复杂度 \(O(n^3)\)，预处理回文 \(O(n^2)\)。 暴力二：枚举所有中心(奇偶特判)，找出最长回文。复杂度还是 \(O(n^2)\)。 哈希：貌似可以做到 \(O(n\log n)\) Manacher：可以把复杂度降到 \(O(n)\)。 流程 为了防止奇偶特判，这里有一个小 trick：在每一个间隙插入 | 字符，然后在字符串开头加一个 $ 字符(可以换成任何字符串没有的字符，并且 | 和 $ 可以相等)。 如 lrzzqa 就变成了 $|l|r|z|z|q|a| 了。 弄一个数组 int p[N]，代表以某个数为中心时的最长回文的长度。 现在假设我们已经计算到了下面这里，那么 ? 要填什么值呢？ 12 $|a|b|c|b|c|d|c|d|a|p .1312151? 根据回文的对称性，回文中心左边的和右边的正好是镜像关系。于是 ? 直接填左边的 b 对应的 \(2\) 就好了。 那么这种情况呢？ 12 $|x|a|b|a|b|p .1111131? 显然应该填 \(3\)，但是根据对称性，? 处应该填 \(1\)。出现这种情况是因为回文已经突破 |a|b|a| 的边界了。所以这种情况就需要重新计算回文，然后记录下当前回文的中心和右端点，继续通过对称性填 p 数组了。 综上所述，可以写出以下流程： 首先对字符串进行处理。 \(i\) 从 \(1\) 循环到 \(n-1\)（不考虑$字符） 如果 \(i\) 在回文右端点之前，那么 p[i] 就等于他对称点的 p 值和从 \(i\) 到对称点距离的最小值，即 \(p_i=\min(p_{2mid-i},p_{mid}+mid-i)\)。重中之重！ 否则 \(p_i=1\)。 接下来拓展回文。同朴素算法。 如果拓展之后回文超出边界，那么更新回文中心 mid 和右端点。 如果要求最长回文子串的长度，那么 \(ans=\min(ans,p_i)\)。 证明略 代码 该代码用于 Accepted 洛谷 P3805 - manacher算法。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;char tmp[11000007], str[22000007];int p[22000007];int n;int manacher() &#123; int rb = 0, mid, ans = 0; for (int i = 1; i &lt; n; i++) &#123; if (i &lt; rb) p[i] = min(p[2 * mid - i], p[mid] + mid - i); else p[i] = 1; while (str[i + p[i]] == str[i - p[i]]) p[i]++; if (p[i] + i &gt; rb) &#123; rb = p[i] + i; mid = i; &#125; ans = max(ans, p[i]); &#125; return ans;&#125;void init() &#123; gets(tmp); n = strlen(tmp); str[0] = '$'; str[1] = '|'; for (int i = 0; i &lt; n; i++) &#123; str[2 * i + 2] = tmp[i]; str[2 * i + 3] = '|'; &#125; n = strlen(str);&#125;int main() &#123; init(); printf("%d", manacher() - 1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>Manacher</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Tarjan强连通分量]]></title>
    <url>%2F2018%2F03%2F19%2Ftarjan-scc-notes%2F</url>
    <content type="text"><![CDATA[简介 其实杜教在ZROI的时候就讲过了，然后因为某些原因现在才来弄…… 强连通分量，指一张有向图的某个极大子图，满足两两点互相连通。 UPD： 2018-03-04 21:59:42：Initial Commit 2018-03-19 13:11:33：Add缩点 概念 如下面这张图： 从\(1\)点对它进行DFS，可以得到以下的DFS树： 实线边是树边 红边是横叉边 短虚线是返祖边 长虚线是前向边 当然，这些都只是为了交流方便。 现在定义dfn[i]和low[i]。 dfn[i]代表第\(i\)个点的DFS序，low[i]代表第\(i\)个点及其子树上的某个点通过一条横叉边或返祖边能到达的DFS序最小的点的DFS序。 流程 DFS过程中所有经过的点按照DFS序入栈。栈中所有点都没有形成强连通分量。 如果发现一个点\(dfn[u]=low[u]\)，也就是说这个点\(u\)再也不能沿着任何边往上走，那么显然这时栈中从栈顶一直到u的所有元素(子树中的元素)组成一个强连通分量，且它是极大的。 现在假设DFS从一个点\(u\)，沿着某条边搜到了某个点\(v\)，那么会有以下情况： \(u\)沿着树边到了\(v\)：先dfs(v)求出low[v]再\(low[u]=\min(low[u],low[v])\)。 \(u\)沿着返祖边或横叉边到了\(v\)：如果边在栈中，那么\(low[u]=\min(low[u],dfn[v])\)。 没有了？没有了。 学强连通分量：先背代码，再理解。 233333。 代码 该代码用于Accepted洛谷 P1726 - 上白泽慧音。 题意就是求排序后字典序最小的最大强连通分量。 显然只要比较最小的点即可。因为不可能一个点在两个不同的强连通分量中。 我是白泽慧音，我已经报警了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5003, M = 100005;struct Edge &#123; int to, next;&#125; e[M];int head[N];int dfn[N], low[N], vis[N], tmp[N], ans[N], ign[N];int dfn_index, scc_count, ans_len, edge_count;stack&lt;int&gt; st;int n, m;void tarjan(int cur) &#123; dfn[cur] = low[cur] = ++dfn_index; vis[cur] = 1; st.push(cur); for (int i = head[cur]; i; i = e[i].next) &#123; int nxt = e[i].to; if (!dfn[nxt]) &#123; tarjan(nxt); low[cur] = min(low[cur], low[nxt]); &#125; else if (vis[nxt] &amp;&amp; dfn[nxt] &lt; low[cur]) &#123; low[cur] = min(low[cur], dfn[nxt]); &#125; &#125; if (low[cur] == dfn[cur]) &#123; memset(tmp, 0, sizeof(tmp)); scc_count++; int _ = 0; while (!st.empty()) &#123; int x = st.top(); st.pop(); tmp[++_] = x; vis[x] = 0; ign[x] = 1; if (x == cur) break; &#125; sort(tmp + 1, tmp + _ + 1); if (_ &gt; ans_len || (_ == ans_len &amp;&amp; tmp[1] &lt; ans[1])) &#123; ans_len = _; memcpy(ans, tmp, sizeof ans); &#125; &#125;&#125;void addEdge(int u, int v, int _) &#123; e[++edge_count] = (Edge)&#123;v, head[u]&#125;; head[u] = edge_count; if (_ == 2) &#123; e[++edge_count] = (Edge)&#123;u, head[v]&#125;; head[v] = edge_count; &#125;&#125;int u, v, w;int main() &#123; scanf("%d%d", &amp;n, &amp;m); while (m--) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); addEdge(u, v, w); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!ign[i]) &#123; tarjan(i); &#125; &#125; printf("%d\n", ans_len); for (int i = 1; i &lt;= ans_len; i++) &#123; printf("%d ", ans[i]); &#125; // while (1);&#125; 缩点 缩点，就是把每个强连通分量缩成一个点。 缩点很简单：只需要枚举原图所有的边，再把这些边变成强连通分量之间的边。 该代码用于Accepted洛谷 P3387 - 【模板】缩点。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 10004, M = 100005;struct edge &#123; int to, next;&#125; e[M];int head[N &lt;&lt; 1], wgt[N], vis[N], dfn[N], low[N], scc[N], dp[N], nwgt[N];int edge_cnt, dfn_index, scc_count;stack&lt;int&gt; st;void tarjan(int x) &#123; dfn[x] = low[x] = ++dfn_index; vis[x] = 1; st.push(x); for (int i = head[x]; i; i = e[i].next) &#123; int nx = e[i].to; if (!dfn[nx]) &#123; tarjan(nx); low[x] = min(low[x], low[nx]); &#125; else if (vis[nx] &amp;&amp; dfn[nx] &lt; low[x]) &#123; low[x] = min(low[x], dfn[nx]); &#125; &#125; if (dfn[x] == low[x]) &#123; scc_count++; while (!st.empty()) &#123; int _ = st.top(); st.pop(); scc[_] = scc_count; vis[_] = 0; nwgt[scc_count] += wgt[_]; if (_ == x) break; &#125; &#125;&#125;void addEdge(int x, int y) &#123; e[++edge_cnt] = (edge)&#123;y, head[x]&#125;; head[x] = edge_cnt;&#125;void dfs(int x) &#123; if (dp[x]) return; dp[x] = nwgt[x]; int ret = 0; for (int i = head[x]; i; i = e[i].next)&#123; if (!dp[e[i].to]) dfs(e[i].to); ret = max(ret, dp[e[i].to]); &#125; dp[x] += ret;&#125;int n, m, u[M], v[M], ans;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", wgt + i); &#125; for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", u+i, v+i); addEdge(u[i], v[i]); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; tarjan(i); &#125; &#125; memset(head, 0, sizeof head); memset(e, 0, sizeof e); edge_cnt = 0; for (int i = 1; i &lt;= m; i++) &#123; if (scc[u[i]] == scc[v[i]]) continue; addEdge(scc[u[i]], scc[v[i]]); &#125; for (int i = 1; i &lt;= scc_count; i++) &#123; if (!dp[i]) &#123; dfs(i); ans = max(ans, dp[i]); &#125; &#125; printf("%d", ans); return 0;&#125; 拓展 缩点以及一些神奇的缩点DP。 其实求强连通分量有很多别的算法，只是Tarjan知名度较高而已&gt;_&lt;，然后点双边双啥的可以和强连通归在一类，也好处理一些。 Kosaraju算法。复杂度和Tarjan一样，而且貌似好写一些，但是常数好像大一些(反正我们也能背下Tarjan的代码2333)，所以貌似没什么用。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」高斯消元]]></title>
    <url>%2F2018%2F03%2F08%2Fgaussian-elimination-notes%2F</url>
    <content type="text"><![CDATA[简介 高斯消元，是一种一般用来解线性方程组的算法。 不就是个加减消元要说的这么先进么 流程 2018-04-05 18:40:51：准确的说，这是高斯-约旦消元法，高斯消元法是转化为简化梯形矩阵后回代的那种消元法。 比如下面这个线性方程组： \[ \left\{ \begin{array}l -x+y-2z=3\\ 4x-3y+6z=2\\ x-6y-3z=-1 \end{array} \right. \] 它可以被转化为这样一个矩阵： \[ \left( \begin{array}c -1&amp;1&amp;-2&amp;3\\ 4&amp;-3&amp;6&amp;2\\ 1&amp;-6&amp;-3&amp;-1 \end{array} \right) \] 显然，我们希望它变成这样： \[ \left( \begin{array}c 1&amp;0&amp;0&amp;a\\ 0&amp;1&amp;0&amp;b\\ 0&amp;0&amp;1&amp;c \end{array} \right) \] 也就是这样的方程组： \[ \left\{ \begin{array}l x=a\\ y=b\\ z=c \end{array} \right. \] 那么可以考虑从\(x\)开始，一元一元地消元。 首先把第\(1\)行和\(x\)系数绝对值最大的行进行交换，以便减小误差： \[ \left( \begin{array}c 4&amp;-3&amp;6&amp;2\\ -1&amp;1&amp;-2&amp;3\\ 1&amp;-6&amp;-3&amp;-1 \end{array} \right) \] 然后把第 \(1\) 行全部 \(\div 4\)： \[ \left( \begin{array}c 1&amp;-\frac34&amp;\frac32&amp;\frac12\\ -1&amp;1&amp;-2&amp;3\\ 1&amp;-6&amp;-3&amp;-1 \end{array} \right) \] 接下来加减消元把\(2\)、\(3\)行的\(x\)系数变为\(0\)： \[ \left( \begin{array}c 1&amp;-\frac34&amp;\frac23&amp;\frac12\\ 0&amp;\frac14&amp;-\frac12&amp;\frac72\\ 0&amp;-\frac{21}4&amp;-\frac92&amp;-\frac32 \end{array} \right) \] 然后再把\(y\)的系数绝对值最大的与第\(2\)行交换： \[ \left( \begin{array}c 1&amp;-\frac34&amp;\frac23&amp;\frac12\\ 0&amp;-\frac{21}4&amp;-\frac92&amp;-\frac32\\ 0&amp;\frac14&amp;-\frac12&amp;\frac72 \end{array} \right) \] 依此类推，消掉\(y\)： \[ \left( \begin{array}c 1&amp;0&amp;\frac{15}7&amp;\frac57\\ 0&amp;1&amp;\frac67&amp;-\frac27\\ 0&amp;0&amp;-\frac57&amp;\frac{24}7 \end{array} \right) \] 最后消掉\(z\)，流程结束： \[ \left( \begin{array}c 1&amp;0&amp;0&amp;11\\ 0&amp;1&amp;0&amp;\frac{22}5\\ 0&amp;0&amp;1&amp;-\frac{24}5 \end{array} \right) \] 代码 该代码用于Accepted洛谷 P3389 - 【模板】高斯消元法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;using namespace std;const double EPS = 1e-8;const int N = 102;double mat[N][N];int n;void gauss() &#123; for (int i = 1; i &lt;= n; i++) &#123; int piv = i; for (int j = i; j &lt;= n; j++) &#123; if (fabs(mat[j][i]) &gt; fabs(mat[piv][i])) &#123; piv = j; &#125; &#125; if (piv != i) for (int j = 1; j &lt;= n + 1; j++) &#123; swap(mat[i][j], mat[piv][j]); &#125; if (fabs(mat[i][i]) &lt;= EPS) &#123; puts("No Solution"); exit(0); &#125; for (int j = i + 1; j &lt;= n + 1; j++) &#123; mat[i][j] /= mat[i][i]; &#125; for (int j = 1; j &lt;= n; j++) &#123; if (i != j) &#123; for (int k = i + 1; k &lt;= n + 1; k++) &#123; mat[j][k] -= mat[j][i] * mat[i][k]; &#125; &#125; &#125; for (int u = 1; u &lt;= n; u++) &#123; for (int v = 1; v &lt;= n+1; v++) &#123; printf("%.6lf ", mat[u][v]); &#125; puts(""); &#125; puts(""); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= n + 1; j++) &#123; scanf("%lf", mat[i] + j); &#125; &#125; gauss(); for (int i = 1; i &lt;= n; i++) &#123; printf("%.2lf\n", mat[i][n + 1]); &#125; return 0;&#125; 拓展 异或方程组。好像连乘除都省了，只要异或？各种千奇百怪的开灯问题什么就应该好弄多了。 怨念的BZOJ1013……]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>数学</tag>
        <tag>高斯消元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「算法」Tarjan割点]]></title>
    <url>%2F2018%2F03%2F06%2Ftarjan-cut-notes%2F</url>
    <content type="text"><![CDATA[简介 如果在一张无向图上删除它和它的所有边使图的连通性改变，那么这个点就这张无向图的割点。 概念 强烈建议看割点之前先右转看看强连通分量 和强连通分量不同，割点只会在无向图中出现。因为DFS树的特性，这棵树上只会有两种边：树边和反向边。 如下面这张图： 从\(1\)点对它进行DFS，可以得到以下的DFS树(这个例子貌似有点极端)： 还是一样，定义dfn[i]和low[i]。 dfn[i]代表第\(i\)个点的DFS序，low[i]代表第\(i\)个点及其子树上的某个点通过一条横叉边或返祖边能到达的DFS序最小的点的DFS序。 显然无向图的DFS树中不可能存在所谓的横叉边，因为如果存在的话那么这条边也会变成树边。 流程 现在假设DFS从一个点\(u\)，沿着某条边搜到了某个点\(v\)，那么会有以下情况： \(u\)沿着树边到了\(v\)：先dfs(v)求出low[v]再\(low[u]=\min(low[u],low[v])\)。 \(u\)沿着反向边到了\(v\)：\(low[u]=\min(low[u],dfn[v])\)。 既然每棵子树已经完全独立了，那么一个点\(u\)是不是割点就很好定义了： 如果\(u\)是根并且有至少两个儿子，那么断掉根各个子树就会分成几个不同的连通块，所以这个点是割点。 如果\(u\)不是根且搜到的点\(v\)满足\(low[v]\ge dfn[u]\)，那么断掉\(u\)后\(v\)就无法到达low[i]，所以这个点是割点。 结束了？结束了。 代码 该代码用于Accepted洛谷 P3388 - 【模板】割点（割顶）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 100005, M = 200005;struct Edge &#123; int to, next;&#125; e[M];int head[N];int cut_count, edge_count, dfn_index;int n, m, dfn[N], low[N], par[N];bool cut[N];void tarjan(int cur) &#123; dfn[cur] = low[cur] = ++dfn_index; int cnt = 0; for (int i = head[cur]; i; i = e[i].next) &#123; int nxt = e[i].to; if (nxt == par[cur]) continue; if (!dfn[nxt]) &#123; cnt++; par[nxt] = cur; tarjan(nxt); low[cur] = min(low[cur], low[nxt]); if (par[cur] &amp;&amp; low[nxt] &gt;= dfn[cur]) &#123; cut_count += !cut[cur]; cut[cur] = 1; &#125; &#125; else &#123; low[cur] = min(low[cur], dfn[nxt]); &#125; &#125; if (!par[cur] &amp;&amp; cnt &gt;= 2) &#123; cut_count += !cut[cur]; cut[cur] = 1; &#125; &#125;void addEdge(int u, int v) &#123; e[++edge_count] = (Edge)&#123;v, head[u]&#125;; head[u] = edge_count;&#125;int u, v;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;u, &amp;v); addEdge(u, v); addEdge(v, u); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (!dfn[i]) &#123; tarjan(i); &#125; &#125; printf("%d\n", cut_count); for (int i = 1; i &lt;= n; i++) &#123; if (cut[i]) &#123; printf("%d ", i); &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1711」吃饭 - 网络流]]></title>
    <url>%2F2018%2F03%2F04%2Fbzoj-1711%2F</url>
    <content type="text"><![CDATA[题意 传送门：DarkBZOJ 1711 - 吃饭和洛谷 P2891 \(n\)头牛，每头牛只吃给定的食物和饮料，每种食物和饮料只有一个，问最多可以喂饱多少头牛。 解法 这题很神奇的有食物和饮料，如果只有一种那么可以写二分图。 首先把一头牛拆成两个点\(x\)和\(x&#39;\)，食物与\(x\)连边，\(x\)与\(x&#39;\)连边，\(x&#39;\)与饮料连边。 然后开一个超级源\(s\)连向所有的食物，开一个超级汇把所有的饮料连过去。 边权全部为\(1\)。然后最大流即可。 开两个点\(x\)个\(x&#39;\)是为了限制每头牛只吃一种食物和饮料(总不能把一堆饮料全部喂给一头牛吃克隆一群)。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Flow_Type;const Flow_Type INF = 0x3f3f3f3f;const int N = 1606;struct Edge;int level[N];int head[N];struct Edge &#123; Flow_Type capacity, flow; int to, next;&#125; e[6 * N];bool levelGraph(int s, int t) &#123; memset(level, 0, sizeof level); queue&lt;int&gt; bfs; bfs.push(s); level[s] = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = head[pos]; i; i = e[i].next) &#123; if (e[i].flow &lt; e[i].capacity &amp;&amp; !level[e[i].to]) &#123; level[e[i].to] = level[pos] + 1; if (e[i].to == t) return true; else bfs.push(e[i].to); &#125; &#125; &#125; return false;&#125;Flow_Type findPath(int s, int t, Flow_Type flow) &#123; if (s == t) return flow; Flow_Type ret = 0; for (int i = head[s]; ret &lt; flow &amp;&amp; i; i = e[i].next) &#123; if (level[s] + 1 == level[e[i].to] &amp;&amp; e[i].flow &lt; e[i].capacity) &#123; Flow_Type tmp = findPath(e[i].to, t, min(e[i].capacity - e[i].flow, flow)); ret += tmp; flow -= tmp; e[i].flow += tmp; e[i ^ 1].flow -= tmp; &#125; &#125; if (!ret) level[s] = -1; return ret;&#125;Flow_Type dinic(int s, int t) &#123; Flow_Type ans = 0; while (levelGraph(s, t)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;int cnt = 1;void addEdge(int from, int to, int capacity) &#123; e[++cnt].to = to; e[cnt].next = head[from]; e[cnt].capacity = capacity; head[from] = cnt; e[++cnt].to = from; e[cnt].next = head[to]; e[cnt].capacity = capacity; e[cnt].flow = capacity; head[to] = cnt;&#125;int t, food, cow, drink;int n, f, d, x, a, b;// 1是超级源, t是超级汇int main() &#123; scanf("%d%d%d", &amp;n, &amp;f, &amp;d); t = 2 + f + 2*n + d; food = 1; cow = f + 1; drink = f + n + 1; for (int i = 1; i &lt;= n; i++) &#123; scanf("%d%d", &amp;a, &amp;b); for (int j = 1; j &lt;= a; j++) &#123; scanf("%d", &amp;x); addEdge(1 + x, 1 + f + i, 1); &#125; addEdge(1 + f + i, 1 + f + n + i, 1); for (int j = 1; j &lt;= b; j++) &#123; scanf("%d", &amp;x); addEdge(1 + f + n + i, 1 + f + 2*n + x, 1); &#125; &#125; for (int i = 1; i &lt;= f; i++) &#123; addEdge(1, 1 + i, 1); &#125; for (int i = 1; i &lt;= d; i++) &#123; addEdge(1 + f + 2*n + i, t, 1); &#125; printf("%d", dinic(1, t)); return 0;&#125; 拓展 网络流真是博大精深： 一个点拆成多个点用来限制流量/干各种事 &quot;\(k\)分图&quot;问题(传说中的三分图) 一些复杂的构图]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BeiJing2006」狼抓兔子 - 网络流]]></title>
    <url>%2F2018%2F03%2F04%2Fbzoj-1001%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1001 - 狼抓兔子和洛谷 P4001 给一张\(n\times m\)的无向网格图，求图的最小割。 \(n,m\le 10^3\) 解法 因为我们有神奇的最大流最小割定理所以这题就成了裸的最大流。 但是这个范围有点大大啊，看起来Dinic过不了。 Dinic的时间复杂度是\(O(n^2m)\)，感觉这题\(n=10^6\)很难过啊。 但其实大部分网络流算法的时间上界都很松，于是Dinic的时间复杂度变成了\(O(\)玄学\()\)和\(O(\)跑得过\()\):smile:。 **其实这题的正解是转对偶图+最短路(不会写&gt;_&lt;)，但是Dinic复杂度过于玄学于是也能过。** 而且貌似如果写对偶图+最短路据说不能打SPFA(网格图) 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;bits/stdc++.h&gt;using namespace std;typedef int Flow_Type;const Flow_Type INF = 0x3f3f3f3f;const int N = 1000006;struct Edge;int level[N];int head[N];struct Edge &#123; Flow_Type capacity, flow; int to, next;&#125; e[6 * N];bool levelGraph(int s, int t) &#123; memset(level, 0, sizeof level); queue&lt;int&gt; bfs; bfs.push(s); level[s] = 1; while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); for (int i = head[pos]; i; i = e[i].next) &#123; if (e[i].flow &lt; e[i].capacity &amp;&amp; !level[e[i].to]) &#123; level[e[i].to] = level[pos] + 1; if (e[i].to == t) return true; else bfs.push(e[i].to); &#125; &#125; &#125; return false;&#125;Flow_Type findPath(int s, int t, Flow_Type flow) &#123; if (s == t) return flow; Flow_Type ret = 0; for (int i = head[s]; ret &lt; flow &amp;&amp; i; i = e[i].next) &#123; if (level[s] + 1 == level[e[i].to] &amp;&amp; e[i].flow &lt; e[i].capacity) &#123; Flow_Type tmp = findPath(e[i].to, t, min(e[i].capacity - e[i].flow, flow)); ret += tmp; flow -= tmp; e[i].flow += tmp; e[i ^ 1].flow -= tmp; &#125; &#125; if (!ret) level[s] = -1; return ret;&#125;Flow_Type dinic(int s, int t) &#123; Flow_Type ans = 0; while (levelGraph(s, t)) &#123; ans += findPath(s, t, INF); &#125; return ans;&#125;int cnt = 1;void addEdge(int from, int to, int capacity) &#123; e[++cnt].to = to; e[cnt].next = head[from]; e[cnt].capacity = capacity; head[from] = cnt; e[++cnt].to = from; e[cnt].next = head[to]; e[cnt].capacity = capacity; head[to] = cnt;&#125;int n, m, x, u;int main() &#123; scanf("%d%d", &amp;n, &amp;m); if (n == 1 &amp;&amp; m == 1) return puts("2147483647"), 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; scanf("%d", &amp;x); u = (i - 1) * m + j; addEdge(u, u + 1, x); &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; scanf("%d", &amp;x); u = (i - 1) * m + j; addEdge(u, u + m, x); &#125; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int j = 1; j &lt; m; j++) &#123; scanf("%d", &amp;x); u = (i - 1) * m + j; addEdge(u, u + m + 1, x); &#125; &#125; printf("%d", dinic(1, n * m));&#125; 拓展 平面图的性质 最大流最小割定理 PS：谁能告诉我怎样把一般的平面图转成对偶图啊！ 平面图之变诈几何哉？止增笑耳。 不用怕Dinic过不了，只需要学会以下底层优化(奇技淫巧)： inline大法好 __attribute__大法好 #pragma大法好 volitile __asm__大法好 register大法好 inline大法好 指针大法好 cache大法好 SIMD大法好 不用C++大法好 其实根本不需要，只要稍微加点优化就好了。Dinic的优化很多的。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>网络流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Luogu P1886」滑动窗口 - 单调队列]]></title>
    <url>%2F2018%2F03%2F03%2Fluogu-1686%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1886 - 滑动窗口 单调队列的入门题。 给一个序列，求所有长度为 \(k\) 的子段的最小值和最大值。 解法 数据的范围是 \(k\le n\le 10^6\)，暴力当然过不了。 为了简化问题，只考虑最小值。 考虑滑动的过程。 在最开始的 $[1,k] $移向 \([2,k+1]\) 时，第一个元素的生命就结束了，第 \(k+1\) 个元素进入了它的生命周期。 如果有一组数据 \(\{2, 3, 1, 4, 2, 6, 3\}, k = 3\)，那么最开头的 \(2\) 和 \(3\) 肯定“没有前途”作为最小值。 而且窗口每移动一次，就会让一些数字“没有前途”。 如果可以在 \(O(1)\) 的时间处理每一次移动，那么处理 \(10^6\) 的数据将没有任何问题。 现在我们考虑的算法流程是： 移动 -&gt; 删除&quot;没有前途&quot;的元素 -&gt; 添加新元素 -&gt; 删除因为移动而 GG 的元素 -&gt; 输出/保存当前答案 -&gt; 回到第一步。 第二步和第三步可以用单调队列维护。 一个单调队列，就是一个元素按照一定顺序排列的队列。 考虑一个双端队列，（仅）可以从头尾增删元素，（仅）可以获取头尾元素的信息，那我们可以利用双端队列实现单调队列。下面是实现方法（仍然只考虑最小值）： 插入元素 \(x\) （同时删除一些队尾的元素以满足单调性） 先把所有大于等于 \(x\) 的数从队尾删掉 然后把 \(x\) 加入进去 删除队首元素 无脑 pop_front 不久好了？ 然后第二步和第三步对应一次插入，第四步对应一次删除。 然后呢？ 都这么详细了你还要我讲什么？ 代码 注释就不用加了吧，可读性应该还可以。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;deque&lt;int&gt; maxq, minq;int rec[1000006];int n, k;void min_p() &#123; for (int i = 1; i &lt;= n; i++) &#123; while (!minq.empty() &amp;&amp; minq.back() &gt;= rec[i]) &#123; minq.pop_back(); &#125; minq.push_back(rec[i]); if (i &gt; k) if (minq.front() == rec[i - k]) minq.pop_front(); if (i &gt;= k) printf("%d ", minq.front()); &#125; puts("");&#125;void max_p() &#123; for (int i = 1; i &lt;= n; i++) &#123; while (!maxq.empty() &amp;&amp; maxq.back() &lt;= rec[i]) &#123; maxq.pop_back(); &#125; maxq.push_back(rec[i]); if (i &gt; k) if (maxq.front() == rec[i - k]) maxq.pop_front(); if (i &gt;= k) printf("%d ", maxq.front()); &#125; puts("");&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", rec + i); &#125; min_p(); max_p();&#125; 拓展 这个拓展包括的就不是滑动窗口了。话说滑动窗口到底有什么用 单调队列优化DP、递推等一系列东西 其实我也不知道啊……我太弱了]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>单调队列</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「BZOJ1214」团伙 - 并查集]]></title>
    <url>%2F2018%2F02%2F22%2Fbzoj-1214%2F</url>
    <content type="text"><![CDATA[题意 传送门：BZOJ1214 - 团伙 有 \(n\) 个人，有 \(m\) 对朋友或敌人的关系。并且满足以下性质： 朋友的朋友也是朋友。 敌人的敌人也是朋友。 所有的朋友组成一个团伙。 现在问你根据这些信息，最多可能有几个团伙。 解法 首先题面中的 最多 省去，那么问题就转化为求团伙的数量。 求连通块数量可以很容易想到并查集。 朋友关系很好处理，只需要两两 merge 即可。 敌人咋处理？ 可以考虑把一个人 \(A\) 拆成两个点 \(A\) 和 \(A&#39;\)。其中 \(A&#39;\) 代表 A 的所有敌人的集合。 那么根据 敌人的敌人是朋友 ，可以得出，如果 \(A\) 和 \(B\) 是敌人，那么我们要 merge 以下两对： \(\operatorname{merge}(A,B&#39;)\) 和 \(\operatorname{merge}(A&#39;,B)\)。 于是只要开到两倍空间就好了。 统计连通块数只需统计 \(1 \sim n\) 的连通块个数即可。 代码 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;int par[10003];int src[10003];int n, m, a, b;char s[2];int ans;int find(int x) &#123; return par[x] == x ? x : par[x] = find(par[x]);&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y;&#125;int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= 2 * n; i++) &#123; par[i] = i; &#125; while (m--) &#123; scanf("%1s%d%d", s, &amp;a, &amp;b); if (*s == 'F') &#123; merge(a, b); &#125; else &#123; merge(n + a, b); merge(a, n + b); &#125; &#125; for (int i = 1; i &lt;= n; i++) &#123; src[find(i)] = 1; &#125; for (int i = 1; i &lt;= 2 * n; i++) &#123; ans += src[i]; &#125; printf("%d", ans);&#125; 拓展 求连通块个数当然用并查集啦！ 如果关系种类繁多，错综复杂，可以考虑把一个点&quot;拆&quot;成多个点。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「赛后总结」Codeforces Round #464 (Div. 2) (+1)]]></title>
    <url>%2F2018%2F02%2F17%2Fcodeforces-round-464%2F</url>
    <content type="text"><![CDATA[传送门：Codeforces Round #464 (Div. 2) 今天的状态差到一种境界&gt;_&lt;。然后估计这几次比赛会炼成 High Frequency Rating。 本来可以做出 C、D 的，顿时感觉被出题人坑了。 原来坑题不止中国出，俄罗斯也出。 A 比赛时竟然写了个 dfs…… 然后获得了 # When Who Problem Lang Verdict Time Memory 2018-02-17 13:27:26 A - Love Triangle GNU C++ Time limit exceeded on pretest 4 1000 ms 2200 KB 2018-02-17 13:23:57 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2200 KB 2018-02-17 13:22:58 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2200 KB 2018-02-17 13:19:46 A - Love Triangle GNU C++ Wrong answer on pretest 7 15 ms 2000 KB 2018-02-17 13:15:25 A - Love Triangle GNU C++ Memory limit exceeded on pretest 6 140 ms 262100 KB 直到我发现只要判断 a[a[a[i]]] == i 是否成立就可以通过。 然后我终于…… # When Who Problem Lang Verdict Time Memory 2018-02-17 14:21:19 A - Love Triangle GNU C++ Pretests Passed 30 ms 2000 KB 然而那时我已经早就 AC 了 B 题…… 最后 A 我只拿了 \(150\) 分。然并卵 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int a[5003];int n;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", a+i); &#125; for (int i = 1; i &lt;= n; i++) &#123; if (a[a[a[i]]] == i) &#123; puts("YES"); return 0; &#125; &#125; puts("NO");&#125; 教训 不要想多！不要想多！！不要想多！！！ 这堆数据发现了你的想多。 我是这堆数据中的一个超级水数据，我先发现你的想多是你 Rating 的幸运。警告你：不要想多！不要想多！！不要想多！！！ 你的的方向上有千万个参赛者，只要不想多，这堆数据就无法定位想多者。 如果想多，想多者将被定位，你的 Rank 将会遭到打击，你的 Rating 将会被降低！ 不要想多！不要想多！！不要想多！！！ B 因为我没考虑到无解时全部输出 \(0\) 的情况，所以我又 WA 了一发。还有一发是我没判断仓鼠数量。 然后我一直没调到错误。 直到我发现我在 if 中的判断少写了个 =。 代码 123456789101112131415161718#include &lt;bits/stdc++.h&gt;using namespace std;long long n, x, ax, bx, cx;int k;int main() &#123; scanf("%I64d%d", &amp;n, &amp;k); for (int i = 1; i &lt;= k; i++) &#123; scanf("%I64d", &amp;x); if (n - n % x &gt;= cx) &#123; ax = i; bx = n / x; cx = n - n % x; &#125; &#125; printf("%I64d %I64d", ax, bx);&#125; 教训 小心无解情况。如果允许输出多组解中的任意一个，请不要使用 &lt; 或者 &gt;，用 &lt;= 和 &gt;= 替代它们。如果不允许，则将当前答案设置成无解。 C 令 \(f-s=k\)。 最开始我写了个前缀和，然后在最后追加 \(k\) 个数，把每个长度为 \(k\) 的子段算出来然后取个 max。 无数次 Wrong answer on test 20 之后还是没有发现错在哪里。 然后我比赛时就没过这题…… 比赛结束后，我改成了另外一种写法，又无数次 Wrong answer on test 9 后也没有发现问题。 最后我写了个 尺取法 或 two-pointer，然后还是 Wrong answer on test 9。 在我砸键盘前的那一刻，我提交了一份骗数据的代码。于是…… Output 12320280: 5007229129971799717: 500722912 Answer 120280 卧槽（上这么难你是人吗）答案一样为什么是 \(20280\) ？百思不得姐。 直到我看见了这句话： If there are many answers, output the smallest among them. mmp。 更错 上面这 \(3\) 个算法，虽然是正着枚举，但是时间是反的。 于是就 Wrong answer on test 9了。 估计是 LJ 出题人不想写太长的 SPJ，然后就在 Output 最后写了这句话。 前缀和算法的最后 我的前缀和还是莫名其妙的 Wrong answer on test 20 了，估计算法还是有问题。 代码(双指针) 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#ifdef LOCAL#define lld "%lld"#else#define lld "%I64d"#endifusing namespace std;long long arr[200005];long long ax, ai, cur;int n, s, f, t;int main() &#123; scanf("%d", &amp;n); for (int i = 0; i &lt; n; i++) &#123; scanf("%lld", arr+i); &#125; scanf("%d%d", &amp;s, &amp;f); s--; f -= 2; for (int i = s; i &lt;= f; i++) &#123; cur += arr[i]; &#125; for (int i = 1; i &lt;= n; i++) &#123; if (cur &gt;= ax) &#123; ai = t + 1; ax = cur; &#125; f = (f + 1) % n; cur += arr[f] - arr[s]; s = (s + 1) % n; t = (t + n - 1) % n; &#125; printf(lld, ai);&#125; 教训 防被坑最好的方法是多读题。 D 第一感图论，然后写了个枚举。如果 a[i] == b[i] 那么 gph[ax][bx] = 1，然后把所有连边输出。 然后挂在了这个数据上： 1233abcbca 接下来我写了个初始化为 \(0\) 的并查集，然后因为有 \(0\) 点，与初始值矛盾，于是第二个样例挂了。 最后我写了个把所有字母替换成一个字符串中存在的字符的代码，于是 Wrong answer on pretest 4。类似这样： 1232abcd 比赛完我才发现，（卧槽上这么难你是人吗）我把并查集的初始值设矛盾了，于是我把初始值设为\(-1\)，然后就 Accepted 了！ 代码 1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;char a[100005], b[100005];int par[31];int n, ans;int find(int x) &#123; return ~par[x] ? par[x] = find(par[x]) : x;&#125;void merge(int x, int y) &#123; if ((x = find(x)) != (y = find(y))) par[x] = y, ans++;&#125;int main() &#123; memset(par, -1, sizeof par); scanf("%d\n", &amp;n); gets(a + 1); gets(b + 1); for (int i = 1; i &lt;= n; i++) &#123; if (a[i] != b[i]) &#123; int ax = a[i] - 'a'; int bx = b[i] - 'a'; merge(ax, bx); &#125; &#125; printf("%d\n", ans); for (int i = 0; i &lt; 26; i++) &#123; find(i); if (par[i] != -1) printf("%c %c\n", i + 'a', par[i] + 'a'); &#125;&#125; 教训 乱初始化的后果是很严重的。写并查集前先想想有没有0号点。 E 二分三分不会写不好写，于是来优化暴力。 令\(f(x,i)\)代表选择最大的数\(x\)和前\(i\)个数时的\(max-mean\)。 显然添加数字之后并不会影响以前的答案。 于是可以\(O(n)\) Accepted 这道题。 代码 123456789101112131415161718192021222324252627282930313233343536// mmp为什么只有C++14及以上可以通过编译?详见下一篇底层博客————坑爹的编译器。#include &lt;bits/stdc++.h&gt;#ifdef LOCAL#define lld "%lld"#else#define lld "%I64d"#endifusing namespace std;typedef long long ll;typedef long double ld;int q, l, n, op, ptr;ll arr[500005];ld ans;ld f(ll x, int i) &#123; return (x * i - arr[i]) / ld(i + 1);&#125;int main() &#123; scanf("%d", &amp;q); ll x; while (q--) &#123; scanf("%d", &amp;op); if (op &amp; 1) &#123; scanf(lld, &amp;x); while (ptr &lt; n &amp;&amp; f(x, ptr) &lt;= f(x, ptr + 1)) ptr++; ans = max(ans, f(x, ptr)); arr[n+1] = arr[n] + x; n++; &#125; else &#123; printf("%.10Lf\n", ans); &#125; &#125;&#125;]]></content>
      <categories>
        <category>赛后总结</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>并查集</tag>
        <tag>Codeforces</tag>
        <tag>模拟</tag>
        <tag>two-pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「SDOI2009」HH 的项链 - 莫队]]></title>
    <url>%2F2018%2F02%2F16%2Fsdoi2009-diff%2F</url>
    <content type="text"><![CDATA[:warning:注意：\(\colorbox{lightgray}{「SDOI2009」HH 的项链 - 莫队}\Leftrightarrow\colorbox{lightgray}{「算法」莫队}\)。 题意 传送门：BZOJ1878 - HH的项链 莫队模板题。 给一个长度为\(n\)数列，要你查询\(m\)次\([l,r]\)区间中不同的数字的个数。 \(n\le 10^6,m\le 10^5\) 解法 虽然看起来这题可以卡掉莫队，但是我还是用莫队AC了。 然后直接套模板即可。 2018-05-12 UPD：洛谷的数据加强了，把莫队卡过了。 存储结构 1234567struct query &#123; int l, r, *ans; bool operator&lt;(const query&amp; x) const &#123; if (l / blockSize == x.l / blockSize) return r &lt; x.r; return l / blockSize &lt; x.l / blockSize; &#125;&#125; q[200005]; \(l\)和\(r\)代表查询中的\(l,r\)，\(ans\)代表保存答案的位置的指针(这样排序之后输出的顺序就不会乱)。 blockSize是每个块的大小。 修改操作 1234int extend(int x, int offset) &#123; if (~offset) return 1 == ++cnt[x]; // +1 else return -!--cnt[x]; // -1&#125; \(x\)代表更新的数字，offset代表加还是减\((1,-1)\)，返回值用来更新答案。 如果\(+1\)之后cnt[x]正好为\(1\)，那就是新增了一种数字，返回\(1\)。 如果\(-1\)之后cnt[x]正好为\(0\)，那就是减少了一种数字，返回\(-1\)。 莫队算法 12345678int l = 1, r = 0, lans = 0;for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) lans += extend(src[++r], 1); while (r &gt; q[i].r) lans += extend(src[r--], -1); while (l &gt; q[i].l) lans += extend(src[--l], 1); while (l &lt; q[i].l) lans += extend(src[l++], -1); *q[i].ans = lans;&#125; lans代表当前查询的答案。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, blockSize, src[50004], ans[200005], cnt[1000006];struct query &#123; int l, r, *ans; bool operator&lt;(const query&amp; x) const &#123; if (l / blockSize == x.l / blockSize) return r &lt; x.r; return l / blockSize &lt; x.l / blockSize; &#125;&#125; q[200005];int extend(int x, int offset) &#123; if (~offset) return 1 == ++cnt[x]; else return -!--cnt[x];&#125;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", src+i); &#125; blockSize = ceil(sqrt(n)); scanf("%d", &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d", &amp;q[i].l, &amp;q[i].r); q[i].ans = ans+i; &#125; sort(q + 1, q + m + 1); int l = 1, r = 0, lans = 0; for (int i = 1; i &lt;= m; i++) &#123; while (r &lt; q[i].r) lans += extend(src[++r], 1); while (r &gt; q[i].r) lans += extend(src[r--], -1); while (l &gt; q[i].l) lans += extend(src[--l], 1); while (l &lt; q[i].l) lans += extend(src[l++], -1); *q[i].ans = lans; &#125; for (int i = 1; i &lt;= m; i++) &#123; printf("%d\n", ans[i]); &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>模板</tag>
        <tag>BZOJ</tag>
        <tag>莫队</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day6上午 - 分治]]></title>
    <url>%2F2018%2F02%2F12%2Fday6-morning-notes%2F</url>
    <content type="text"><![CDATA[:warning:注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： 分治 归并排序 将两个已经有序的数组用\(O(n)\)合并成一个有序的数组。 时间复杂度\(O(n\log n)\) 树的深度\(O(\log n)\)层，归并整个一层\(O(n)\)，共\(O(n\log n)\)。 使用范围 规模小可以方便计算 可以划分成较小子问题 子问题全部解出后可以解决原问题 子问题独立 Master Theorem 设 \(a\ge 1,b\ge 1\)，设 \(f(n)\) 为一函数，\(T(n)\) 由递归式$ T(n)=aT(nb)+f(n)$ 定义。 若 \(f(n)&lt;n^{\log_ba}\)，则 \(T(n)=O(n^{\log_ba})\) 若 \(f(n)=n^{log_ba}\)，则 \(T(n)=O(n^{log_ba}log_2n)\) 若 \(f(n)&gt;n^{log_ba}\)，且对于任意 \(c&lt;1\) 与所有足够大的 \(n\)，都有 \(af(\frac nb)\le cf(n)\)，则 \(T(n)=O(f(n))\)。 逆序对 \(n\le10^5\) 一分为二。考虑左边自身、右边自身、跨两边。跨两边就two-pointers解决。 快速幂 分治大法好==位运算大法好== 即时战略(WC2018T2) 35pts 从一个点开始，枚举所有其它点，然后把它周围所有点探索出来，类似于bfs。\(O(n^2)\)。 完全二叉树 Solution 1 \(O(\frac n2)\)查出一个点在哪个子树。 然后查下面的\(O(n)\)个点，在标记中使用堆式编号。 然后就用主定理证出\(O(n\log n)\)了。 Solution 2 因为完全二叉树的深度是\(O(\log n)\)的，所以可以用\(O(n\log n)\)过掉。 Solution 3 在完全二叉树上BFS！ 百度地图的实时路况 分治严格不经过的点，\(solve(l,r)\)代表\([l,r]\)都没有被考虑。 = = 区间的价值 枚举最小值。然后从左右两端找最大值。 BD String 超淼题。 可以证明，\(S(n)\)中B的数量是\(2^{n-1}\)。 然后计算\(solve(n)\)： \(n=0\)返回\(0\)。 \(n=1\)返回\(1\)。 \(mid=2^{\lfloor\log_2n\rfloor}\)。如果\(2mid-1=n\)，返回\(mid\)。 否则返回\(f(2mid-1-n)+n+1-mid\)。 My solution 令\(f(x)\)为\(S(n)\)中\([0,x)\)的B的数量。 那么答案就等于\(f(l)-f(r-1)\)。 然后考虑\(x\)的位置。如果在后半段就将\(2^{n-1}+1\)加上后半段。 前半段就直接从\(n-1\)算。 欧几里得最近点对 先按\(x\)排序，然后把点分成两半。 然后初始化答案\(d=+\infty\)。 然后在左右两边枚举点，对答案更新有用的点一定是在该点为圆心半径为\(d\)的点。这样的点最多只有不到\(6\)个。 Tricky Function \(g(i,j)\)就是算\((i,j]\)的区间和。 令\(b\)为\(a\)的前缀和，那么\(g(i,j)=b[i]-b[j]\)。 \(x\)坐标为编号，\(y\)坐标为前缀和。 然后就差一个根号！ 然后交个板子就AC了。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day4 - 图论]]></title>
    <url>%2F2018%2F02%2F10%2Fday4-notes%2F</url>
    <content type="text"><![CDATA[:warning:注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： 搜索 DFS 二分图判定 dfs即可。\(1\)相邻\(2\)，\(2\)相邻\(1\)。 不是二分图则会染色矛盾。 时空阵 先不考虑距离为\(m\)。 考虑bfs的分层。 \(dp_{i,j,k}\)前\(i\)层，\(j\)个点，第\(i\)层\(k\)个点的方案数。 枚举第\(i+1\)层的点数\(x\)。 ​ 标号 层内 跨层 转移：\(dp_{i+1,j+x,x}=dp_{i,j,k}\cdot\binom{n-j}x\cdot 2^\binom x2\cdot(2^k-1)^x\) 现在考虑距离为\(m\)。 \(dp_{m,j,k}\cdot \frac k{n-1}\)第\(m\)层，\(j\)个点，第\(m\)层\(k\)个点。\(k\over n-1\)是因为概率和对称性。 每个k元组出现的概率是相等的。 再考虑剩下的\(n-j\)个点连边。 它们可以内部连边，并且只能和第\(m\)层(k个点)连边。 ​ 内部 外部 所以\(dp_{m,j,k}\cdot\frac k{n-1}\cdot 2^\binom {n-j}2\cdot 2^{k(n-j)}\)。 欧拉回路 正常版 图必须联通，小心孤立点 充要条件： 欧拉路：\(0\)或\(2\)个奇点。 欧拉回路：全是偶点。 证明略 &quot;回溯算法&quot; 算法证明略 代码： 12345678910111213void dfs(int u, int c) &#123; // O(n+m) void dfs(int u) &#123; while (!e[u].empty()) &#123; int v = e[u][e[u].size()-1].first; int id = e[u][e[u].size()-1].second; e[u].pop_back(); // O(1) 减小循环代价 if (vis[id]) continue; // 有向图删了 vis[id] = 1; // 有向图删了 dfs(v); ans.push_back(id);// auto it=--e[u].end(); &#125;&#125; 高端版 最少路径数覆盖整张图？ 先往\(2k\)个奇点之间加\(k\)条边让奇点消失。然后跑欧拉回路，然后拆边，会拆成\(k\)条路径。 然后这题就成了结论题。 例题 1 ? 2 将区间中的\(l\)和\(r\)构点建边，然后判跑一遍欧拉回路。 如果有欧拉回路，那么方向是→就将区间设为\(1\)，如果是←就设为\(-1\)。 没有欧拉回路就把点全部升序排序，然后\(12\)、\(34\)、\(56\)......的连边。 然后去掉加的边按方向设置\(1\)或\(-1\)。 证明略 Dijkstra 每次将最短路最短的未确定点确定，然后再将新确定点相邻的点更新，直到跑完为止。 可以利用小根堆将复杂度优化至\(O((n+m)\log n)\)。 平板电视大法好 稠密图用naive算法，不要优化！不要优化！！不要优化！！！ Bellman-Ford \(O(nm)\) 不怕负权边。 \(dis[u][i]\)走不超过\(i\)步到\(u\)点 方程：\(dis[u][i]=min(dis[u][i-1], dis[v][i-1]+w[v][u])\) 华容道 并没有 \(dis(x,y,dir)\)表示把\((x,y)\)往\(dir\)方向移动。 将空格移到\((x,y)\)附近需要\(c\)的代价，可以预处理。 多点最短路 HDU 6166 简单版 考虑无向图。 先把所有\(k\)中的点的\(dis\)设为\(0\)，然后松弛时记录父节点。 然后枚举所有边，如果边的两边是来自不同的源点，那么用\(dis[u]+dis[v]+w[u][v]\)更新答案。 正常版 ????? 定义\(f(u,v)\)为\(u\)点集到\(v\)点集的最短路。 然后弄一个超级源和一个超级汇，一个连整个\(u\)，一个连整个\(v\)，然后算一下最短路即可。 然后做\(2log_2n\)跑出对于\(u,v\in S,u\ne v\)中\(f(u,v)\)。 复杂度\(nlog^2n\)。 强连通分量 如果一张图中所有的点对\((u,v)\)中的\(u,v\)可以互相到达，那么张图是强连通的。 树边：从父亲跑到儿子的边。 返祖边：从晚辈跑到祖辈的边。 前向边：从祖辈跑到晚辈的边。(不包括树边) 横叉边：乱连的边。 Low Case：树边+返祖边\((u,v)\) 那么\(u\)到\(v\)的路径全部在同一个强连通分量里。 首先弄一个时间戳，也就是dfn。 定义low[i]代表\(i\)子树能通过返祖边和横叉边能够到的的最浅的点(跳出子树为止)。 如果dfn[i]=low[i]，那么\(i\)子树再也跳不上去了，所以\(i\)子树组成一个强连通分量。 注意！如果你通过横叉边往上跑的时候跑到的是一个完整的强连通分量，那么Congratulations，这个作废。 12345678910111213141516171819202122void dfs(int u) &#123; dfn[u] = low[u] = ++ind; // index ins[u] = 1; // instack(没形成强连通分量的栈) st[++top] = u; for (int i = 0; i &lt; e[u].size(); i++) &#123; int v = e[u][i]; if (!dfn[v]) &#123; dfs(v); low[u] = min(low[u], dfs(low[v])); &#125; else if (ins[v]) &#123; // 不是强连通分量 low[u] = min(low[u], dfn[v]); // 可以换成low[v] &#125; &#125; if (dfn[u] == low[u]) &#123; ++cnt; while (1) &#123; bel[st[top]] = cnt; // belong ins[st[top]] = 0; if (st[top--] == u) break; &#125; &#125;&#125; 缩点 缩点后一定是个DAG。 最大半联通子图 先缩点。 如果图有分叉就会发现不可达，然后求最长链即可。 于是每个点都有了权值\(w[i]\)。 最后就直接\(dp[u]=\max(dp[v]+w[v]), (u,v)\in E\)。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day3 - DP]]></title>
    <url>%2F2018%2F02%2F09%2Fday3-notes%2F</url>
    <content type="text"><![CDATA[:warning:注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： day2 欠账 最长简单环 \(f_{p,s,t}\)从\(s\)到\(t\)经过点集\(p\)是否存在。 初始：\(f_{2^{i-1},i,i}=1\) 如果\(i\)满足\((t, i) \in E, (p&gt;&gt;(i+1)\&amp;1)=0\)，就可以转移\(f_{p|(1&lt;&lt;(i-1)),s,i}\) \(f_{p,s,t}=1\)且\((t,s) \in E\)，则长度为__builtin_popcount(p)。 复杂度：\(2^nn^3\) 优化 限定\(s\)是环中最小的编号，其它条件不变。 转移时枚举\(s+1...n\) \(\sum_i^n2^nn=n\sum_{i=1}^n2^i=O(2^nn)\) 例题6 \(f_p\)在组里的最大收益。 \(f_p=\max\limits_s w[s]+f_{p-s}\) \((p\&amp;s)=s\) \(O(4^n)\)并不能跑过\(n=16\)。 优化 \(p\)有\(2^{k-1}\)个非空子集，可以用\(0\)~\(2^{k-1}\)表示所有的子集。只需\(2^{k-1}\)枚举子集。 对于每一个集合\(P\)，那么子集数为\(2^{|P|}\)。 复杂度\(O(3^n)\) 123for (s=p; s; s=(s-1)&amp;p) &#123; // 不重复枚举所有p的子集 // do something...&#125; 生成树计数 令\(1\)为根。 \(f_{i,p}\)代表\(i\)的子树中，有\(p\)个点的子树个数。 1init : f[i][1&lt;&lt;(i-1)] = 1; \(f_{i,p}=\sum f_{j,s}f_{i,p-s}, s\subseteq P-\{i\} , j\in s\) 设\(\min(P-\{i\})=k\)。 复杂度\(O(3^nn^2)\) 枚举顺序 i 1~n P 0~2^n-1 斯坦纳树 \(f_{i,p}\)以\(i\)为根，经过关键点集合\(p\)。 \(i,j\)是关键点\(f_{i,p}=\min f_{j,s}+f_{i,p-s}+w_{i,j}\) 孤立点从子树接边\(f_{i,p}=\min f_{j,p}+w_{i,j}\) 带环，需要用最短路转移！ 轮廓线DP\(\subseteq\)状压 例题9 暴力 \(f_{i,p}\)代表扫到了\(i\)列，\(p\)从上一行突出来了。 Procedure： \(p\)碰到障碍点，直接扔掉。 枚举\(s\)，代表在第\(i\)行会横出下一行。 满足s&amp;(p|障碍)=0。 而且竖着的骨牌必须可以摆在~(s|障碍|p)中。 复杂度\(3^nn^{很多次方}\) 高端操作(轮廓线DP) 首先一列一列放骨牌，然后总共有\(n+1\)个边界。 放置的方式： 12345671 8 15 . #2 9 . . #3 10. . #4 11. #5 12. #6 13. #7 14. # 边界： 1234567. . . . # 1. . . . # 1. . . . # 1. . . # 2. . . # 1. . . # 1. . . # 1 如图，有\(n+1\)个边界。 可以记录状态\(f_{i,j,p}\)代表放到了\((i,j)\)点，边界\(p\)方案数。 不合法状态： \(i\)要长出来或\(i+1\)要长出来并且\((i,j)\)是障碍。 \(i\)和\(i+1\)都要长出来。 合法状态： \(i\)和\(i+1\)只有一个长出来并且\((i,j)\)不是障碍， 转移到\(P-(1&lt;&lt;(i-1))\)或\(P-(1&lt;&lt;i)\)。 其它长出情况直接转移到\(P+(1&lt;&lt;(i-1))\)或\(P+(1&lt;&lt;i)\)。 最后扫完一行后需要更新轮廓线才可以继续DP。 新的轮廓线中的第一个一定是\(0\)(边界外不可能有股牌下来) 如果\(n+1\)为\(1\)就直接丢掉(伸到了边界外面) 然后就直接左移一位(\(1\)移到\(2\) \(2\)移到\(3\)...\(n\)移到\(n+1\)) 复杂度\(O(2^nn^2)\) 枚举顺序\(j\)、\(i\)、\(p\)。 k国王问题 \(f_{i,j,k,p}\) 放到\((i,j)\)，放了\(k\)个国王，轮廓线外的\(p\)格会被攻击。 讨论两种情况：放还是不放。 放就把周围一圈的\(p\)更新，否则直接转移。 \(\max\limits_i=0\) day2e B \(f_{叶子}=+\inf,f_.=0\) \(f_i+=\min(w,f_j)\) C \(f_{i,p}\) 前\(i\)选\(p\)是否能到达 枚举\(a\)、\(b\)。 \(f_{i,p}-&gt;f_{i+1,p+(1&lt;&lt;(a-1))+(1&lt;&lt;(b-1))}\) \((p&gt;&gt;(a,b-1))\&amp;1=0\)，满足边 A \(f_{i,j}=\sum_{k=0}^{w_i}f_{i-1,j-k}\binom jk\) \(O((\sum w_i)^2)\) D 改板轮廓线DP模板 E \(f_{i,j}\)深度\(\le j\)，有\(i\)点。 \(f_{i-1,j-1}\cdot 2\cdot i\) \(\sum_{k=1}^{i-2}f_{k,j-1}\cdot f_{i-k-1,j-1}\cdot i\cdot \binom{i-2}{i-k-2}\) \(f_{0,i}=1\) \(f_{1,i}=1\) 状态\(O(nd)\)，转移\(O(n)\) 复杂度\(O(n^2d)\)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day2 - DP]]></title>
    <url>%2F2018%2F02%2F08%2Fday2-notes%2F</url>
    <content type="text"><![CDATA[:warning:注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： day1欠账 简单题 \(f_{n,x,y}\)长度\(a\)，\(x,y\)表示\(1\)和\(0\)的奇偶性。 \(f_{n,0,y} -&gt; f_{n,0,y\ xor\ 1}\) \(f_{n,x,0} -&gt; f_{n,x\ xor\ 1,0}\) 矩阵优化 \(f_{n+1,0,0}, f_{n+1,0,1}, f_{n+1,1,0}, f_{n+1,1,1}\) \(0\) \(0/1\) 不放 \(1\) 转移矩阵 \[ \left[ \begin{array}{c} 0 &amp; 1 &amp; 0 &amp; 0\\ 1 &amp; 0 &amp; 0 &amp; 1\\ 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; 1 &amp; 0 &amp; 0 \end{array} \right] \] 树形DP 重点！如果合并两个子树时间是两个子树的乘积，那么这个树形DP是平方的 模板 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;using namespace std;void merge(int x, int p) &#123; // 合并子树 f[p][0] = f[p][1] + /* max(f[k][0], f[k][1]) */; f[p][1] = f[p][0] + f[x][1];&#125;void init(int x) &#123; // 初始化 // f[k][0] = 0;// f[k][1] = 1;&#125;void treedp(int x) &#123; // 树形dp 不需要改 for (int i = 0; i &lt; c[x].size(); i++) &#123; treedp(c[x][i]); &#125; init(x); for (int i = 0; i &lt; c[x].size(); i++) &#123; merge(c[x][i], x); &#125;&#125;int main() &#123; // 状态 -&gt; init -&gt; merge &#125; 最大独立集 同模板 例题2 123456state: f[i][0], f[i][1]init : f[i][1] = f[i][0] = 0;merge: f[x][1] = max(f[p][1] + max(f[x][1], f[x][0]), f[p][0] + f[x][0] + 1); : f[x][0] = f[p][0] + max(f[x][1], f[x][0]); // 缺失部分 例题3 12345state: f[i][0] 我不是，孩子也不是[不合法] : f[i][1] 我不是，孩子是[合法] : f[i][2] 我是[满足]init : f[i][0] = 0, f[i][2] = 1, f[i][1] = 0x3f3f3f3fmerge: x 0 1 2 0 2 1 0 1 2 2 1 1 2 HOMEWORK：距离为\(2\) 例题4 简化版(只考虑子树) 12345f[i][x][y] 当前子树关键点 当前子树的子树f[i][0][0] = 0f[i][1][0] = 1f[i][0][1] = f[i][1][1] = 0x3f3f3f3f x 0,0 0,1 1,0 1,1 0 0,1 1,1 1 1,0 1,1 1,0 1,1 普通版 存在度数大于\(3\)的点 贪心地选一个度大于\(3\)的点为根，然后同简化版 不存在(链)，输出\(1\)。 例题5 1234567f[i]表示只删以i为根的子树的ans(minimal maximum)f[叶子]=0x3f3f3f3ff[其它]=0merge:f[i]=max(f[i], x); 练习1 1234 0 1 ---0|0 11|0 x ans = 5471492 [暂缺] 例题6 简化版(只考虑子树) \(f_f=\max(f_f, f_j-w_j)\) 普通版 令子树外最长路为\(u_i\)。 维护次大值\(g_f\)和\(f_f\)的来源\(where_f\)。 \(g_f\)初始\(0\)。 1234if (f[k] + w &gt; f[f]) &#123; g[f] = f[k]; &#125; 123456User -&gt; Web: SubmitWeb -&gt; Judger: SubmitNote right of Judger: Waiting &amp; JudgingJudger -&gt; Web: WAWeb -&gt; User: WANote left of User: MMP 123456789101112131415161718start=&gt;start: 做题needIOOptimize=&gt;condition: 需要快速IO?kengDie=&gt;operation: 坑爹,命题人SBimplementation=&gt;condition: 大模拟题?codeLong=&gt;operation: 难写,命题人SBconstant=&gt;condition: 题目还卡常?boring=&gt;operation: 无聊,命题人SBisEasy=&gt;condition: 题目太简单?water=&gt;operation: 太水,命题人SBend=&gt;end: 婊死出题人start-&gt;needIOOptimizeneedIOOptimize(yes)-&gt;kengDie-&gt;endneedIOOptimize(no)-&gt;implementationimplementation(yes)-&gt;codeLong-&gt;endimplementation(no)-&gt;constantconstant(yes)-&gt;boring-&gt;endconstant(no)-&gt;water-&gt;end 例题7 令每条边经过\(f_i\)次，那么\(ans = \sum d_if_i\)，\(d_i\)是权值。 dfs求出\(f_i\)即可。 监测站 乱搞 树形背包 \(f_{i,j}\)表示\(i\)子树\(j\)容量 \(g_{i,j}\)表示不选\(i\)的子树\(j\)容量 初始\(g_{i,j}=0\) 如果选\(i\)就一定选整个子树 ：\(max(g_{i,j},\sum v_i)(j \ge \sum v_i)\) \(g&#39;_{i,a+b}=g_{i,a}+f_{c,b}\) \[ f_{i,j}=\left\{\begin{array}l g_{i,j} &amp; j&gt;\sum v_i,\\ max(g_{i,j}, \sum v_i) &amp; j\ge \sum v_i. \end{array}\right. \] 时间复杂度\(O(n^3)\) 状压DP 例题1 \(f_{i,p[n]}\)前\(i\)衣服，\(p_i\)裤子是否配对。 for j=1...n (i+1, j)可配对，\(p_j=0\) f[i+1][j|(1&lt;&lt;(j-1))] += f[i][j]; 12343 91 1 1 2 1 32 1 2 2 2 33 1 3 2 3 3 例题2 拓扑排序计数(NP-Hard) \(f_p\)选的点数。 对于所有满足要求的(k, j)，\(j\)没被选，\(k\)放了，\(f_{p|(1&lt;&lt;(j-1))} += f_p\)。 \(20: 2^n\) \(18: 2^nn\) \(16: 2^nn^2 / 3^n\) 例题3 \(t_i\)代表第\(i\)条直线覆盖点的。 \(f_p=\min(f_{p|t_i},...,f_p+1)\) 固定一个端点，可以将枚举直线改为\(O(n)\)。 2n个点最短路乱搞？ 例题4 Who knows？ for i=1..m \(f_{p|t_i}=\max(..., f_p+1)(p\&amp;t_i=0)\) 例题5 最长简单环(NP-Hard NPC) 实现例题2 (选做例题5)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「笔记」day1 - DP]]></title>
    <url>%2F2018%2F02%2F07%2Fday1-notes%2F</url>
    <content type="text"><![CDATA[:warning:注意：这是ZROI集训的源笔记，其中有很多缺失和遗漏以及无法看懂的部分，大家就不要看了吧。 以下是原笔记： \(f_{i,j}+1=f_{a,b}(A_a=A_b, A_i=A_j, A_a &gt; A_i, i&lt;a, j&lt;b)\) 二叉树枚举\(a\)，求出\(j\)之后第一个\(A_a = A_b\) 预处理？ \(n_{i,x} \ne i+1, n_{i,x}=n_{i+1,x}\) \(n_{i,x} = i+1, n_{i,x} = i+1\) 1| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | \(f_{n,m} = \binom {s-1} {n-1}\sum_{s=1}^nf_{n-s,m-1}\) \(f_{n,m}=mf_{n-1,m}+f_{n-1,m-1}\) 优化状态？转移？ 错排问题 \(f_n\) 当\(a \ne n\)时，\((n-1)f_{n-2}\) 当\(a=n\)时，\((n-1)f_{n-1}\) \(f_n=(n-1)(f_{n-1}+f_{n-2})\) 逆序对 \(f_{n,m}\)代表\(n\)个数产生\(m\)个逆序对的数量。 \(f_{n,m}=\sum_{k=1}^nf_{n-1,m-k+1}\) 前缀和优化 \((m-n,m]\) \(f_{n,m}=g_{i,m}-g_{i,m-n}\) 例题2 【IMPOSSIBLE】 f_{i,j}前\(i\)物品，取\(j\)的长度，方案数。 f_{i,j}={k=0}^{w_i}g{j-k,k}f_{i-1,j-k} 例题3 二叉树：\(f_n=\sum_{i=0}^{n-1}f_if_{n-i-1}\binom {n-1} i\) 二叉树的子结构性质 有根树：\(f_n = \sum_{i=1}^{n-1}f_if_{n-i}\binom{n-2}{i-1}\) 去掉一棵子树还是一棵树 \(k\)叉树：f_{n,k}={i=1}^{n-1}f{i,1}f_{n-i,k-1} \(g_{n,m}=\sum_{i=1}^{n-1}g_{n-i,m-1}f_i\) \(f_i=\sum_{j=0}^kg_{i,j}\) \(g_{n,m}\) 根\(m\)其它\(n\) 拆分数 \(f_{i, j} = f_{i, j-i} + f_{i-1, j} - i\) \(n \le 10^5\)情况 \(g_{i,j}\) \(i\)个数，和为\(j\)。 \(i \le \sqrt n\)时：\(f_{i,j}=f_{i-1,j}+f_{i,j}-i\) \(i \ge \sqrt n\)时：\(g_{i,j}=g_{i-1,j-1}+g_{i,j-i}\) \(h_j = \sum_{i=0}^\sqrt ng_{i,j-i\sqrt n}\) \(Ans = \sum_{A=0}^nf_{\sqrt n, A}h_{n-A}\) Alt+F4 \(F(U)\subset K\)ING HOMEWORK \(Y\emptyset\cup R\) \(\log n\) \(20\) \(\sqrt n\) \(300\) 求长度为\(5000\)恰好有\(100000\)个逆序对的排列个数 \(n\)个点带标号的无向图个数 \(n\)个点带标号的无向连通图个数 \(n \le 5000\) = = ​ \(2^\binom n2\) \(f_n=2^\binom n2-\sum_{i=1}^nf_i\times2^\binom{n-2}2\times\binom{n-1}{i-1}\) 选标号\(\binom{n-1}{i-1}\)]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 886C」Petya and Catacombs - 贪心]]></title>
    <url>%2F2018%2F02%2F06%2Fcodeforces-886c%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 886C - Petya and Catacombs Petya在图上探险。每一分钟随机走动一次(可以原地)。 如果走到的是一个新点，随机写一个数字。 如果以前来过，写最近一次到这里的时间。 第\(0\)分钟Petya在原地并且没有写数字。 给你Petya写的一串数字，问你最少有几个点。 解法 题目绕了半天&gt;_&lt;。 TLE做法 记录每个点最后一次到的时间，每输入一个数字，\(O(n)\)地查询有没有踩过的点，如果没有就开新点，否则用久点。时间复杂度\(O(n^2)\)，完美TLE。 AC做法1 考虑每一个数字。每出现一个数字，可能是以前踩过的点，也可能是随机数(新点)。 并且不可能同时踩到两个不同的点，那么同一个数字出现\(n\)次，至少\(n-1\)次是随机数。 时间复杂度\(O(n)\)。 AC做法2 考虑优化TLE做法。根据AC做法1中得出的结论，每一个点最后一次到达的时间是不同的。 开一个长度为\(n\)的数组记录每一个时间是否是某个点的最后一次到达的时间。 然后for i=1...n scanf(&quot;%d&quot;, &amp;x)。 如果\(x\)是某个点最后一次到达的时间，那么就让它不是(因为那个点已经被更新了)。 否则(这是个随机数)就ans++。 并且无论是以上哪种情况，某个点最后一次到达的时间都一定会被置为\(i\)，所以vis[i]=1。 代码 思路1 1234567891011121314#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, ans = 1;int vis[200005];int main() &#123; for(scanf("%d", &amp;n); n--; ) &#123; scanf("%d", &amp;x); if (!vis[x]) vis[x] = 1; else ans++; &#125; printf("%d", ans);&#125; 思路2 1234567891011121314151617#include &lt;bits/stdc++.h&gt;using namespace std;int n, x, ans = 1;int vis[200005];int main() &#123; scanf("%d", &amp;n); vis[0] = 1; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); if (vis[x]) vis[x] = 0; else ans++; vis[i] = 1; &#125; printf("%d", ans);&#125; 拓展 话说两段代码长得好像啊~]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 872C」Maximum splitting - 数学]]></title>
    <url>%2F2018%2F02%2F06%2Fcodeforces-872c%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 872C - Maximum splitting 给你\(n\)个数，问你这些数最多可以写成多少个合数的和。\(n \le 10^5, 1 \le x \le 10^9\) 解法 考虑分解的策略。 首先，最小的\(4\)个合数分别是\(4, 6, 8, 9\)。 很明显，分解得到的合数越小越好。分类讨论： 当\(x\)是\(1, 2, 3, 5, 7, 11\)时无解，输出\(-1\)。 当\(x\)是偶数时，因为\(x&gt;2\)，而且\(4\)和\(6\)可以组成所有大于\(2\)的偶数。所以只需要用\(4\)和\(6\)即可。 当\(x\)是奇数时，因为大于\(11\)的奇数和\(9\)自身都有解，并且大于\(11\)的奇数都可以写成\(9\)和大于\(4\)的偶数的和。所以只需要用\(x-9\)再按情况2计算即可。 综上所述，需要用到的数字只有\(4, 6, 9\)。 现在考虑分解出的数的个数。 当\(x\)是\(1, 2, 3, 5, 7, 11\)时，输出\(-1\)。 当\(x\)能被\(4\)整除时，输出\(\frac x4\)。 当\(x\)是偶数且不能被\(4\)整除时，输出\(\frac{x-6}4+1\)。 当\(x\)是奇数时，输出\(\frac{x-9}4+1\)。 代码 12345678910111213141516171819#include &lt;bits/stdc++.h&gt;using namespace std;int n, x;int f(int x) &#123; if (!x) return 0; if (x &lt; 4 || x == 5 || x == 7 || x == 11) return -1; if (x &amp; 1) return f(x-9) + 1; if (x &amp; 2) return f(x-6) + 1; return x&gt;&gt;2;&#125;int main() &#123; for (scanf("%d", &amp;n); n--; ) &#123; scanf("%d", &amp;x); printf("%d\n", f(x)); &#125;&#125; 拓展 对于分解性的问题，如果需要最大化某个量，则极端地考虑可能的取值。 如最大化数量，可以考虑让数字尽可能小。 如最大化乘积，可以考虑让\(2, 3\)尽可能多。 然后再证明自己的猜想，如本题的&quot;\(4, 6, 9\)&quot;。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「Codeforces 879C」Short Program - 位运算]]></title>
    <url>%2F2018%2F01%2F01%2Fcodeforces-879c%2F</url>
    <content type="text"><![CDATA[题意 传送门：Codeforces 879C 给一串位运算操作(包含| &amp; ^，每个操作数均落在\(。\)中)，将其简化到5次运算以内并输出。 解法 过程 考虑交换律和结合律。显然1|1^1$$1^1|1。所以要换一种思路。 我们可以将\(1023\)和\(0\)同时进行运算。 再考虑将&amp; | ^三种运算转化为| ^两种。 如将\(1023\)和\(0\)带入以下运算： 123456789101110 1111111111 0000000000^ 218 0011011010 1100100101&amp; 150 0010010010 0000000100| 935 1110110111 1110100111&amp; 61 0000110101 0000100101| 588 1001111101 1001101101&amp; 897 1000000001 1000000001| 411 1110011011 1110011011| 584 1111011011 1111011011^ 800 0011111011 0011111011| 704 1011111011 1011111011 使用| ^代替&amp; | ^的方法： 置零，使用|1^1 置一，使用|1^0 不变，使用|0^0 反转，使用|0^1 令\(1023\ or\ x\ xor\ y=a=763\)，\(0\ or\ x\ xor\ y=b=763\) 即如果\(a\)和\(b\)某一位一样，\(x\)的那一位就是1，\(y\)的那一位就是\(b\)那一位的反码。 如果不一样，\(x\)的那一位就是\(0\)，\(y\)的那一位也是\(b\)那一位的反码。 两数每一位相同得\(1\)，不同得\(0\)，就是\(a\ xor\ b\ xor\ 1023\)的值。 \(b\)的反码即\(b\ xor\ 1023\)。 结论 \(x = a\ xor\ b\ xor\ 1023\) \(y = b\ xor\ 1023\) \(O(n)\)边读边算\(a\)和\(b\)，最后\(O(1)\)算\(x\)和\(y\)即可。 代码 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define p(q) ((q) &amp;&amp; (q) != X)#define X 0x3f3f3f3fusing namespace std;int a = 0, b = 1023;char op[1];int n, t;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%s%d", op, &amp;t); switch (*op) &#123; case '&amp;': a &amp;= t; b &amp;= t; break; case '|': a |= t; b |= t; break; case '^': a ^= t; b ^= t; break; &#125; &#125; printf("2\n| %d\n^ %d", a ^ b ^ 1023, b ^ 1023);&#125; 拓展 位运算+构造算法(bitmasks+constructive algorithms)的题目的几种思考方式： 对每一位考虑(位运算都是隔离每位的，不存在借位进位这种影响其它位的运算) 对逆运算考虑(如1216-D，前缀和转为差分) 对结果考虑(结果反向构造过程)]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1216-D - 差分]]></title>
    <url>%2F2017%2F12%2F20%2Fyali-1216-d%2F</url>
    <content type="text"><![CDATA[题意 有一个 \(n\) 个数的序列，一开始所有的数都是 \(0\)，每次可以将一个区间 \([l,r]\) \((l≤r)\) 内的数 \(+1\)，求到达最终状态的最少操作次数。 \(n \le 10^5,m \le 10^5\)，\(m\) 为操作次数。 解法 正难则反：考虑已知每次操作，求序列。可使用前缀和。 如样例输出： 123431 61 62 6 将闭区间转为左闭右开，即 \([1, 7), [1, 7), [2, 7)\)，则可得到： 1234下标: 1 2 3 4 5 6 7数组: 2 1 0 0 0 0 -3前缀和后得到原序列:原序列: 2 3 3 3 3 3 0 根据前缀和的逆运算是差分，得到 \(O(n+m)\) 解法。 优化 既然差分之后就可以求出所有区间，为什么不直接往队列里面丢呢？ 如差分序列 2 1 0 0 0 0 -3，进行以下处理： 遇到正数\(2\)，直接丢\(2\)个下标\(1\)在存\(l\)的队列中。 123l队列 r队列11 遇到正数\(1\)，直接丢\(1\)个下标\(2\)在存\(l\)的队列中。 1234l队列 r队列112 遇到负数 -3，直接丢 \(|-3|=3\) 个下标 \(7-1=6\) 在存 \(r\) 的队列中。 1234l队列 r队列1 61 62 6 输出即可。 123431 61 62 6 时间复杂度 \(O(n+m)\)。 代码 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;using namespace std;int out[100005][2]; //模拟队列int n, x, m1, m2, r;int main() &#123; scanf("%d", &amp;n); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;x); if (r &lt; x) for (int j = x-r; j--;) out[m1++][0] = i; if (r &gt; x) for (int j = r-x; j--;) out[m2++][1] = i-1; r = x; &#125; for (int j = r; j--;) out[m2++][1] = n; printf("%d\n", m1); for (int i = 0; i &lt; m1; i++) &#123; printf("%d %d\n", out[i][0], out[i][1]); &#125;&#125; 拓展 正难则反：很多题目需要逆向思考。如将差分题逆向思考得到前缀和。多考虑互逆运算之间的转化关系。]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>Y</tag>
        <tag>差分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「洛谷 P1704」寻找最优美做题曲线 - DP]]></title>
    <url>%2F2017%2F12%2F09%2Fluogu-1704%2F</url>
    <content type="text"><![CDATA[题意 传送门：洛谷 P1704 - 寻找最优美做题曲线 现在给出每一天刷题的题数，并且有几天必须刷题，问最多可以刷多少天的题并且满足严格递增。 说白了就是，给一个序列，告诉你有一些下标上的数 必须 包含在 LIS 中，求满足条件的 LIS，就是被禁锢的 LIS。 解法 变量定义 12345int p[500005], t[500005]; // p代表必须刷题的时间, t代表每天刷题的题数int lis[500005]; // LIS数组int c[500005]; //处理过的刷题题数int n, m, x; // n天, m天必须刷题int ans; // 答案 读入 贴代码不解释： 12345678scanf("%d%d", &amp;n, &amp;m);for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", p+i);&#125;sort(p+1, p+m+1);for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", t+i);&#125; 处理 首先，如果必须刷题的那几天不严格递增，咳咳。 1234567for (int i = 2; i &lt;= m; i++) &#123; if (t[p[i]] &lt;= t[p[i-1]]) &#123; puts("impossible"); return 0; &#125;&#125;proc(); 接下来是对LIS做一些处理。 首先，如果一个序列中的数比前面的数都大，比后面的数都小，那这个数一定包含在LIS中。 那么我们可以使需要刷题的每一天都满足这个要求。 如数据：12 6 10 11 8 12 10 11 16 14 17 13 14 18，我们可以进行以下骚操作： 12 6 10 11 8 12 10 11 16 14 17 13 14 18 得到6 10 11 16 17 18。 代码如下： 123456789101112131415161718192021void proc() &#123; // int new_n = 0; c[0] = t[0] // t中的内容处理后被存入c中 int nx = 0; *c = *t; for (int i = 1; i &lt;= m; i++) &#123; if (i &gt; 1) c[++nx] = t[p[i-1]]; for (int j = p[i-1]+1; j &lt; p[i]; j++) &#123; // 两个必须刷题的日子的中间 if (t[p[i-1]] &lt; t[j] &amp;&amp; t[j] &lt; t[p[i]]) &#123; c[++nx] = t[j]; &#125; &#125; &#125; c[++nx] = t[p[m]]; for (int i = p[m]+1; i &lt;= n; i++) &#123; // 最后一个必须刷题的日子之后 if (t[p[m]] &lt; t[i]) &#123; c[++nx] = t[i]; &#125; &#125; c[++nx] = t[p[m]]; n = nx;&#125; LIS \(O(n \log n)\)的LIS算法参见这里，代码如下： 123456for (int i = 1; i &lt;= n; i++) &#123; int pos = lower_bound(lis+1, lis+ans+1, c[i]) - lis; lis[pos] = c[i]; ans = max(ans, pos);&#125;printf("%d", ans); 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;int p[500005], t[500005];int lis[500005];int c[500005];int n, m, x; int ans;void proc() &#123; int nx = 0; *c = *t; for (int i = 1; i &lt;= m; i++) &#123; if (i &gt; 1) c[++nx] = t[p[i-1]]; for (int j = p[i-1]+1; j &lt; p[i]; j++) &#123; if (t[p[i-1]] &lt; t[j] &amp;&amp; t[j] &lt; t[p[i]]) &#123; c[++nx] = t[j]; &#125; &#125; &#125; c[++nx] = t[p[m]]; for (int i = p[m]+1; i &lt;= n; i++) &#123; if (t[p[m]] &lt; t[i]) &#123; c[++nx] = t[i]; &#125; &#125; c[++nx] = t[p[m]]; n = nx;&#125; int main() &#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 1; i &lt;= m; i++) &#123; scanf("%d", p+i); &#125; sort(p+1, p+m+1); for (int i = 1; i &lt;= n; i++) &#123; scanf("%d", t+i); &#125; for (int i = 2; i &lt;= m; i++) &#123; if (t[p[i]] &lt;= t[p[i-1]]) &#123; puts("impossible"); return 0; &#125; &#125; proc(); for (int i = 1; i &lt;= n; i++) &#123; int pos = lower_bound(lis+1, lis+ans+1, c[i]) - lis; lis[pos] = c[i]; ans = max(ans, pos); &#125; printf("%d", ans);&#125; 拓展 对于限制或改版LIS问题，可以做一定的处理，使其变为正常LIS，然后再使用裸LIS算法解决。或者设计针对题目的算法。 这里列出一些相关的题目： LICS 最长上升公共子序列 二元组LIS 最长震荡子序列]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「经典」八数码问题 - BFS]]></title>
    <url>%2F2017%2F11%2F24%2Feight-digits-puzzle%2F</url>
    <content type="text"><![CDATA[题意 这么经典的题目还要题意... 传送门：洛谷 P1379（让我想到了 1379 号监听员:laughing:） 思路 不会写康托展开，遂用数字存储，然后使用 bitset 存储 visited 数组。 输入后对输入的局面 BFS。 交换整数中的数字 首先，数字中的下标对应以下表格： 1230 1 23 4 56 7 8 那么， 上下交换就是 \(x\) 和 \(x+3\) 交换 \((x&lt;5)\)， 左右交换就是 \(x\) 和 \(x+1\) 交换 \((x&lt;7)\)。 但有个问题，如果 \(2\) 和 \(3\) 交换或者 \(5\) 和 \(6\) 交换那就不行了。 所以有一个神奇的方法：判断两数相乘是否为 \(6\) 或 \(30\):laughing:。 123456780，若要将 \(3\) 和 \(7\) 交换， 首先记忆 \(3\)，接下来减 \(7 \times 10^2\)，然后加 \(3 \times 10^2\)， 再减 \(3 \times 10^6\)，最后加 \(7 \times 10^6\)。 输出路径？ 集训的题目要输出路径，那就加个 map 存前驱，然后递归打出来。 代码 代码在这里： 可以 AC 洛谷 P1379 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;#define t(x) ((((x)&lt;&lt;2)+(x))&lt;&lt;1)#define l(x, i) ((x)/p10[i]%10)#define w(x, i) (*(x+i))using namespace std;// 预处理10^nconst int p10[] = &#123;1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000&#125;;const int dir[4] = &#123;3, -3, 1, -1&#125;; // 方向矢量map&lt;int, int&gt; dep; // 深度queue&lt;int&gt; bfs; // 广搜队列int n; // 数字int main() &#123;// #ifndef __TIGER0132__// freopen("9gong.in", "r", stdin);// freopen("9gong.out", "w", stdout);// #endif scanf("%d", &amp;n); bfs.push(n); dep[n] = 0; // 初始深度 while (!bfs.empty()) &#123; int pos = bfs.front(); bfs.pop(); int cdep = dep[pos] + 1; // 现在搜到的数字的深度 int _0; // 数字中0的位置// printf("%d\n", pos); if (pos == 123804765) &#123; printf("%d", dep[pos]); return 0; &#125; for (_0 = 0; _0 &lt; 9; _0++) &#123; // 搜索0的位置 if (!l(pos, _0)) break; &#125; for (int i = 0; i &lt; 4; i++) &#123; int p0 = _0; // 第一个要交换的数的下标 int p1 = _0+w(dir, i); // 第二个要交换的数的下标 int p2 = pos, p3; // p2是pos的拷贝, p3临时变量 // 判断交换是否合法 if (p0 &lt; 0 || p1 &lt; 0 || p0 &gt; 8 || p1 &gt; 8 || p0*p1 == 6 || p0*p1 == 30) continue; p3 = l(p2, p0); // t = a; p2 += (l(p2,p1) - l(p2,p0))*p10[p0]; // a = b; p2 += (p3 - l(p2,p0))*p10[p1]; // b = t; if (dep.count(p2)) continue; // 判断是否搜过 bfs.push(p2); // 入队 dep[p2] = cdep; // 更新深度 &#125; &#125; puts("Oh no! Where's my solution?");&#125; 教训 :warning:不要无脑register，不然TLE自己负责！]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>BFS</tag>
        <tag>经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见错误]]></title>
    <url>%2F2017%2F10%2F12%2Fmistakes%2F</url>
    <content type="text"><![CDATA[本文收集常见以及不常见的各种错误！ 分块时： be(i) = (i-1)/m+1 第 \(x\) 块的范围是：\([(x-1) \cdot m + 1, x \cdot m]\)。 \(l \sim L\) 的正确写法：for (int i = l; i &lt;= std::min(L*m, r); i++) \(R \sim r\) 的正确写法：if (L != R) for (int i = (R-1)*m+1; i &lt;= r; i++) 123 L | L+1 | L+2 | ... | R-1 | R |---+-----+-----+-----+-----+---+ l==========================r 整块部分只有 \(\mathbf{[L+1, R)}\)。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>常见错误</tag>
      </tags>
  </entry>
</search>
